DIRECTORY TREE
ğŸ“ frontend/
â”‚ ğŸ“„ Dockerfile
â”‚ âš™ï¸ tsconfig.app.json
â”‚ âš™ï¸ tsconfig.json
â”‚ âš™ï¸ tsconfig.spec.json
â”‚ ğŸ“ .claude/
â”‚ ğŸ“ public/
â”‚ ğŸ“ src/
â”‚ â”‚ ğŸŒ index.html
â”‚ â”‚ ğŸ“˜ main.ts
â”‚ â”‚ ğŸ“ app/
â”‚ â”‚ â”‚ ğŸ“˜ app.config.ts
â”‚ â”‚ â”‚ ğŸŒ app.html
â”‚ â”‚ â”‚ ğŸ“˜ app.routes.ts
â”‚ â”‚ â”‚ ğŸ“˜ app.spec.ts
â”‚ â”‚ â”‚ ğŸ“˜ app.ts
â”‚ â”‚ â”‚ ğŸ“ core/
â”‚ â”‚ â”‚ â”‚ ğŸ“ config/
â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“˜ environment.ts
â”‚ â”‚ â”‚ â”‚ ğŸ“ constants/
â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“˜ categories.ts
â”‚ â”‚ â”‚ â”‚ ğŸ“ firebase/
â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“˜ firebase.ts
â”‚ â”‚ â”‚ â”‚ ğŸ“ guards/
â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“˜ admin-guard.ts
â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“˜ auth-guard.ts
â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“˜ guest-guard.ts
â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“˜ role-guard.ts
â”‚ â”‚ â”‚ â”‚ ğŸ“ interceptors/
â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“˜ error-interceptor.ts
â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“˜ jwt-interceptor.ts
â”‚ â”‚ â”‚ â”‚ ğŸ“ models/
â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“˜ admin.model.ts
â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“˜ auth.model.ts
â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“˜ comment.model.ts
â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“˜ notification.model.ts
â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“˜ post.model.ts
â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“˜ user.model.ts
â”‚ â”‚ â”‚ â”‚ ğŸ“ services/
â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“˜ admin.ts
â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“˜ auth.ts
â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“˜ favorite.ts
â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“˜ notification.ts
â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“˜ permission.ts
â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“˜ theme.ts
â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“˜ vote-state.ts
â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“˜ websocket.ts
â”‚ â”‚ â”‚ ğŸ“ features/
â”‚ â”‚ â”‚ â”‚ ğŸ“ admin/
â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“ admin-comments/
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸŒ admin-comments.html
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“˜ admin-comments.ts
â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“ admin-dashboard/
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸŒ admin-dashboard.html
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“˜ admin-dashboard.ts
â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“ admin-posts/
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸŒ admin-posts.html
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“˜ admin-posts.ts
â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“ admin-users/
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸŒ admin-users.html
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“˜ admin-users.ts
â”‚ â”‚ â”‚ â”‚ ğŸ“ auth/
â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“ login/
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸŒ login.html
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“˜ login.ts
â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“ signup/
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸŒ signup.html
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“˜ signup.ts
â”‚ â”‚ â”‚ â”‚ ğŸ“ comments/
â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“ comment-form/
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸŒ comment-form.html
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“˜ comment-form.ts
â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“ comment-item/
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸŒ comment-item.html
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“˜ comment-item.ts
â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“ comment-thread/
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸŒ comment-thread.html
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“˜ comment-thread.ts
â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“ services/
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“˜ comment.ts
â”‚ â”‚ â”‚ â”‚ ğŸ“ notifications/
â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“ notification-bell/
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸŒ notification-bell.html
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“˜ notification-bell.ts
â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“ notification-item/
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸŒ notification-item.html
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“˜ notification-item.ts
â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“ notification-list/
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸŒ notification-list.html
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“˜ notification-list.ts
â”‚ â”‚ â”‚ â”‚ ğŸ“ posts/
â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“ post-card/
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸŒ post-card.html
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“˜ post-card.ts
â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“ post-create/
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸŒ post-create.html
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“˜ post-create.ts
â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“ post-detail/
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸŒ post-detail.html
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“˜ post-detail.ts
â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“ post-list/
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸŒ post-list.html
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“˜ post-list.ts
â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“ services/
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“˜ post.ts
â”‚ â”‚ â”‚ â”‚ ğŸ“ user/
â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“ profile/
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸŒ profile.html
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“˜ profile.ts
â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“ services/
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“˜ user.ts
â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“ settings/
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸŒ settings.html
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“˜ settings.ts
â”‚ â”‚ â”‚ ğŸ“ pages/
â”‚ â”‚ â”‚ â”‚ ğŸ“ category/
â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“˜ category.ts
â”‚ â”‚ â”‚ â”‚ ğŸ“ feed/
â”‚ â”‚ â”‚ â”‚ â”‚ ğŸŒ feed.html
â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“˜ feed.ts
â”‚ â”‚ â”‚ â”‚ ğŸ“ home/
â”‚ â”‚ â”‚ â”‚ â”‚ ğŸŒ home.html
â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“˜ home.ts
â”‚ â”‚ â”‚ â”‚ ğŸ“ not-found/
â”‚ â”‚ â”‚ â”‚ â”‚ ğŸŒ not-found.html
â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“˜ not-found.ts
â”‚ â”‚ â”‚ â”‚ ğŸ“ saved-posts/
â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“˜ saved-posts.ts
â”‚ â”‚ â”‚ ğŸ“ shared/
â”‚ â”‚ â”‚ â”‚ ğŸ“ components/
â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“ confirm-dialog/
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸŒ confirm-dialog.html
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“˜ confirm-dialog.ts
â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“ error-message/
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸŒ error-message.html
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“˜ error-message.ts
â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“ header/
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸŒ header.html
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“˜ header.ts
â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“ loading-spinner/
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸŒ loading-spinner.html
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“˜ loading-spinner.ts
â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“ sidebar/
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸŒ sidebar.html
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“˜ sidebar.ts
â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“ user-avatar/
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸŒ user-avatar.html
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“˜ user-avatar.ts
â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“ vote-buttons/
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸŒ vote-buttons.html
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“˜ vote-buttons.ts
FILE CONTENTS
FILE: Dockerfile
# Build stage - Node.js with Alpine for smaller size
FROM node:20-alpine AS builder

# Set working directory
WORKDIR /app

# Copy package files first (for better caching)
COPY package*.json ./

# Install dependencies with cache mount (Docker BuildKit)
RUN --mount=type=cache,target=/root/.npm \
    npm ci --only=production=false

# Copy source code
COPY . .

# Build with production config
RUN npm run build -- --configuration=production

# Production stage - Nginx Alpine
FROM nginx:1.25-alpine

# Copy built app
COPY --from=builder /app/dist/frontend/browser/ /usr/share/nginx/html/

# Copy nginx config
COPY nginx.conf /etc/nginx/conf.d/default.conf

# Expose port
EXPOSE 80

# Health check (optional but good)
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
    CMD curl -f http://localhost/ || exit 1

# Start nginx
CMD ["nginx", "-g", "daemon off;"]
FILE: src/app/app.config.ts
import { ApplicationConfig, provideZoneChangeDetection } from '@angular/core';
import { provideRouter } from '@angular/router';
import { provideHttpClient, withInterceptors } from '@angular/common/http';
import { provideAnimations } from '@angular/platform-browser/animations';
import { routes } from './app.routes';
import { jwtInterceptor } from './core/interceptors/jwt-interceptor';
import { errorInterceptor } from './core/interceptors/error-interceptor';
export const appConfig: ApplicationConfig = {
  providers: [
    provideZoneChangeDetection({ eventCoalescing: true }),
    provideRouter(routes),
    provideHttpClient(
      withInterceptors([jwtInterceptor, errorInterceptor])
    ),
    provideAnimations()
  ]
};
FILE: src/app/app.html
@if (!auth.isReady()) {
  <app-loading-spinner
    [fullscreen]="true"
    message="Loading application..."
  ></app-loading-spinner>
} @else {
  <div class="app-container">
    <app-header></app-header>
    <div class="app-body">
      <app-sidebar></app-sidebar>
      <main class="main-content">
        <router-outlet></router-outlet>
      </main>
    </div>
  </div>
}
FILE: src/app/app.routes.ts
import { Routes } from '@angular/router';
import { Feed } from './pages/feed/feed';
import { Login } from './features/auth/login/login';
import { Signup } from './features/auth/signup/signup';
import { PostDetail } from './features/posts/post-detail/post-detail';
import { PostCreate } from './features/posts/post-create/post-create';
import { Profile } from './features/user/profile/profile';
import { Settings } from './features/user/settings/settings';
import { SavedPosts } from './pages/saved-posts/saved-posts';
import { Category } from './pages/category/category';
import { NotFound } from './pages/not-found/not-found';
import { authGuard } from './core/guards/auth-guard';
import { guestGuard } from './core/guards/guest-guard';
export const routes: Routes = [
  { path: '', redirectTo: '/feed', pathMatch: 'full' },
  { path: 'feed', component: Feed, canActivate: [authGuard] },
  { path: 'feed/:filter', component: Feed, canActivate: [authGuard] },
  { path: 'post/:id', component: PostDetail, canActivate: [authGuard] },
  { path: 'create-post', component: PostCreate, canActivate: [authGuard] },
  { path: 'saved', component: SavedPosts, canActivate: [authGuard] },
  { path: 'category/:slug', component: Category, canActivate: [authGuard] },
  { path: 'profile/:username', component: Profile, canActivate: [authGuard] },
  { path: 'settings', component: Settings, canActivate: [authGuard] },
  { path: 'login', component: Login, canActivate: [guestGuard] },
  { path: 'signup', component: Signup, canActivate: [guestGuard] },
  { path: '**', component: NotFound, canActivate: [authGuard] },
];
FILE: src/app/app.spec.ts
import { TestBed } from '@angular/core/testing';
import { App } from './app';
describe('App', () => {
  beforeEach(async () => {
    await TestBed.configureTestingModule({
      imports: [App],
    }).compileComponents();
  });
  it('should create the app', () => {
    const fixture = TestBed.createComponent(App);
    const app = fixture.componentInstance;
    expect(app).toBeTruthy();
  });
  it('should render title', async () => {
    const fixture = TestBed.createComponent(App);
    await fixture.whenStable();
    const compiled = fixture.nativeElement as HTMLElement;
    expect(compiled.querySelector('h1')?.textContent).toContain('Hello, frontend');
  });
});
FILE: src/app/app.ts
import { ChangeDetectionStrategy, Component, inject } from '@angular/core';
import { RouterOutlet } from '@angular/router';
import { Header } from './shared/components/header/header';
import { Sidebar } from './shared/components/sidebar/sidebar';
import { Auth } from './core/services/auth';
import { LoadingSpinner } from './shared/components/loading-spinner/loading-spinner';
@Component({
  selector: 'app-root',
  standalone: true,
  imports: [RouterOutlet, Header, Sidebar, LoadingSpinner],
  templateUrl: './app.html',
  styleUrls: ['./app.css'],
  changeDetection: ChangeDetectionStrategy.OnPush,
})
export class App {
  protected readonly auth = inject(Auth);
}
FILE: src/app/core/config/environment.ts
export const environment = {
  apiUrl: 'http://localhost:8000/api/v1',
  websocketUrl: 'ws:
  storageKeys: {
    auth: 'memeforum.auth',
  },
  firebase: {
    apiKey: 'AIzaSyBhytWfxcCQvuLeggoWVHzwEBFd9-yi2Vk',
    authDomain: 'my-metkit18.firebaseapp.com',
    databaseURL: 'https://my-metkit18-default-rtdb.asia-southeast1.firebasedatabase.app',
    projectId: 'my-metkit18',
    storageBucket: 'my-metkit18.firebasestorage.app',
    messagingSenderId: '405491881603',
    appId: '1:405491881603:web:56e6e072d78ed32fca2db6',
    measurementId: 'G-45Q2DK9C36',
  },
};
FILE: src/app/core/constants/categories.ts
export interface Category {
  id: string;
  name: string;
  emoji: string;
  slug: string;
}
export const CATEGORIES: Category[] = [
  { id: 'funny', name: 'Funny', emoji: 'ğŸ˜‚', slug: 'funny' },
  { id: 'gaming', name: 'Gaming', emoji: 'ğŸ®', slug: 'gaming' },
  { id: 'programming', name: 'Programming', emoji: 'ğŸ’»', slug: 'programming' },
  { id: 'dank', name: 'Dank', emoji: 'ğŸŒš', slug: 'dank' },
  { id: 'wholesome', name: 'Wholesome', emoji: 'ğŸ¥°', slug: 'wholesome' },
];
FILE: src/app/core/firebase/firebase.ts
import { initializeApp } from 'firebase/app';
import { getAuth } from 'firebase/auth';
import type { Auth } from 'firebase/auth';
import { environment } from '../config/environment';
let authInstance: Auth | null = null;
let initialised = false;
export function getFirebaseAuth(): Auth | null {
  if (authInstance) return authInstance;
  if (!environment.firebase.apiKey) {
    console.warn('[Firebase] Missing configuration. Update environment.firebase.*');
    return null;
  }
  if (!initialised) {
    const app = initializeApp(environment.firebase);
    initialised = true;
    if (typeof window !== 'undefined' && environment.firebase.measurementId) {
      import('firebase/analytics')
        .then(({ getAnalytics }) => getAnalytics(app))
        .catch((error) => console.warn('Analytics init failed', error));
    }
  }
  authInstance = getAuth();
  return authInstance;
}
FILE: src/app/core/guards/admin-guard.ts
import { CanActivateFn, Router } from '@angular/router';
import { inject } from '@angular/core';
import { Auth } from '../services/auth';
export const adminGuard: CanActivateFn = () => {
  const auth = inject(Auth);
  const router = inject(Router);
  if (!auth.isAuthenticated()) {
    router.navigate(['/login']);
    return false;
  }
  const user = auth.user();
  if (user?.role !== 'admin') {
    router.navigate(['/feed']);
    return false;
  }
  return true;
};
FILE: src/app/core/guards/auth-guard.ts
import { CanActivateFn, Router } from '@angular/router';
import { inject } from '@angular/core';
import { Auth } from '../services/auth';
export const authGuard: CanActivateFn = (_route, state) => {
  const auth = inject(Auth);
  const router = inject(Router);
  if (auth.isAuthenticated()) return true;
  auth.setRedirect(state.url);
  router.navigate(['/login']);
  return false;
};
FILE: src/app/core/guards/guest-guard.ts
import { CanActivateFn, Router } from '@angular/router';
import { inject } from '@angular/core';
import { Auth } from '../services/auth';
export const guestGuard: CanActivateFn = () => {
  const auth = inject(Auth);
  const router = inject(Router);
  if (auth.isAuthenticated()) {
    router.navigate(['/feed']);
    return false;
  }
  return true;
};
FILE: src/app/core/guards/role-guard.ts
import { CanActivateFn, Router, ActivatedRouteSnapshot } from '@angular/router';
import { inject } from '@angular/core';
import { Auth } from '../services/auth';
export const roleGuard: CanActivateFn = (route: ActivatedRouteSnapshot) => {
  const auth = inject(Auth);
  const router = inject(Router);
  if (!auth.isAuthenticated()) {
    router.navigate(['/login']);
    return false;
  }
  const user = auth.user();
  const requiredRoles = route.data['roles'] as string[] | undefined;
  if (!requiredRoles || requiredRoles.length === 0) {
    return true;
  }
  if (!user || !requiredRoles.includes(user.role)) {
    router.navigate(['/feed']);
    return false;
  }
  return true;
};
export const moderatorGuard: CanActivateFn = () => {
  const auth = inject(Auth);
  const router = inject(Router);
  if (!auth.isAuthenticated()) {
    router.navigate(['/login']);
    return false;
  }
  const user = auth.user();
  if (!user || !['admin', 'moderator'].includes(user.role)) {
    router.navigate(['/feed']);
    return false;
  }
  return true;
};
FILE: src/app/core/interceptors/error-interceptor.ts
import { HttpErrorResponse, HttpInterceptorFn } from '@angular/common/http';
import { inject } from '@angular/core';
import { catchError, throwError } from 'rxjs';
import { Auth } from '../services/auth';
export const errorInterceptor: HttpInterceptorFn = (req, next) => {
  const auth = inject(Auth);
  return next(req).pipe(
    catchError((error: HttpErrorResponse) => {
      if (error.status === 401) auth.handleUnauthorized();
      return throwError(() => error);
    }),
  );
};
FILE: src/app/core/interceptors/jwt-interceptor.ts
import { HttpInterceptorFn } from '@angular/common/http';
import { inject } from '@angular/core';
import { Auth } from '../services/auth';
export const jwtInterceptor: HttpInterceptorFn = (req, next) => {
  const auth = inject(Auth);
  const token = auth.token();
  if (!token) return next(req);
  return next(
    req.clone({
      setHeaders: { Authorization: `Bearer ${token}` },
    }),
  );
};
FILE: src/app/core/models/admin.model.ts
export type RoleType = 'admin' | 'moderator' | 'user';
export interface UserListItem {
  id: number;
  username: string;
  email: string;
  avatarUrl: string | null;
  role: RoleType;
  isActive: boolean;
  isBanned: boolean;
  createdAt: string;
  postCount: number;
  commentCount: number;
}
export interface UserListResponse {
  users: UserListItem[];
  total: number;
  page: number;
  pageSize: number;
  hasMore: boolean;
}
export interface UserDetail {
  id: number;
  username: string;
  email: string;
  avatarUrl: string | null;
  bio: string | null;
  role: RoleType;
  isActive: boolean;
  isBanned: boolean;
  banReason: string | null;
  createdAt: string;
  updatedAt: string | null;
  postCount: number;
  commentCount: number;
}
export interface PostAdminListItem {
  id: number;
  title: string;
  authorUsername: string;
  authorId: number;
  isLocked: boolean;
  isDeleted: boolean;
  upvotes: number;
  downvotes: number;
  commentCount: number;
  createdAt: string;
  reportsCount: number;
}
export interface PostAdminListResponse {
  posts: PostAdminListItem[];
  total: number;
  page: number;
  pageSize: number;
  hasMore: boolean;
}
export interface CommentAdminListItem {
  id: number;
  content: string;
  authorUsername: string;
  authorId: number;
  postId: number;
  postTitle: string;
  isDeleted: boolean;
  upvotes: number;
  downvotes: number;
  createdAt: string;
  reportsCount: number;
}
export interface CommentAdminListResponse {
  comments: CommentAdminListItem[];
  total: number;
  page: number;
  pageSize: number;
  hasMore: boolean;
}
export interface DashboardStats {
  totalUsers: number;
  activeUsers: number;
  bannedUsers: number;
  totalPosts: number;
  totalComments: number;
  postsToday: number;
  commentsToday: number;
  newUsersToday: number;
}
export interface RecentActivity {
  type: string;
  message: string;
  timestamp: string;
  userId?: number;
  postId?: number;
}
export interface DashboardResponse {
  stats: DashboardStats;
  recentActivity: RecentActivity[];
}
export interface RoleInfo {
  id: number;
  name: RoleType;
  permissions: string[];
  userCount: number;
}
export interface ActionResponse {
  success: boolean;
  message: string;
}
export interface UserPermissions {
  userId: number;
  username: string;
  role: RoleType;
  permissions: string[];
  isAdmin: boolean;
  isModerator: boolean;
}
FILE: src/app/core/models/auth.model.ts
export interface TokenResponseUser {
  id: number;
  username: string;
  email: string;
  avatar_url: string | null;
  role: string;
}
export interface TokenResponse {
  access_token: string;
  token_type: string;
  user: TokenResponseUser;
}
FILE: src/app/core/models/comment.model.ts
export interface Comment {
  id: number;
  postId: number;
  userId: number;
  parentId?: number | null;
  content: string;
  upvotes: number;
  downvotes: number;
  isDeleted: boolean;
  createdAt: string;
  updatedAt?: string | null;
  authorUsername: string;
  authorAvatar: string | null;
  userVote: 'up' | 'down' | null;
  replies: Comment[];
  isOp?: boolean;
}
FILE: src/app/core/models/notification.model.ts
export interface Notification {
  id: number;
  userId: number;
  type: string;
  message: string;
  link?: string | null;
  isRead: boolean;
  createdAt: string;
}
FILE: src/app/core/models/post.model.ts
export interface Post {
  id: number;
  userId: number;
  title: string;
  description: string | null;
  tag: string | null;
  imageUrl: string | null;
  upvotes: number;
  downvotes: number;
  commentCount: number;
  createdAt: string;
  updatedAt?: string | null;
  authorUsername: string;
  authorAvatar: string | null;
  userVote: 'up' | 'down' | null;
  isFavorited: boolean;
}
export interface PostList {
  posts: Post[];
  total: number;
  page: number;
  pageSize: number;
  hasMore: boolean;
}
FILE: src/app/core/models/user.model.ts
export interface User {
  id: number;
  username: string;
  email: string;
  avatarUrl: string | null;
  bio: string | null;
  role: 'admin' | 'moderator' | 'user';
  isActive: boolean;
  isBanned: boolean;
  createdAt: string;
  updatedAt: string | null;
}
export interface UserProfile {
  id: number;
  username: string;
  avatarUrl: string | null;
  bio: string | null;
  role: string;
  postCount: number;
  commentCount: number;
  joinedAt: string;
}
FILE: src/app/core/services/admin.ts
import { Injectable, inject } from '@angular/core';
import { HttpClient, HttpParams } from '@angular/common/http';
import { Observable, map } from 'rxjs';
import { environment } from '../config/environment';
import {
  UserListResponse,
  UserListItem,
  UserDetail,
  PostAdminListResponse,
  PostAdminListItem,
  CommentAdminListResponse,
  CommentAdminListItem,
  DashboardResponse,
  DashboardStats,
  RecentActivity,
  RoleInfo,
  ActionResponse,
  RoleType,
} from '../models/admin.model';
interface UserListDto {
  users: {
    id: number;
    username: string;
    email: string;
    avatar_url: string | null;
    role: string;
    is_active: boolean;
    is_banned: boolean;
    created_at: string;
    post_count: number;
    comment_count: number;
  }[];
  total: number;
  page: number;
  page_size: number;
  has_more: boolean;
}
interface UserDetailDto {
  id: number;
  username: string;
  email: string;
  avatar_url: string | null;
  bio: string | null;
  role: string;
  is_active: boolean;
  is_banned: boolean;
  ban_reason: string | null;
  created_at: string;
  updated_at: string | null;
  post_count: number;
  comment_count: number;
}
interface PostListDto {
  posts: {
    id: number;
    title: string;
    author_username: string;
    author_id: number;
    is_locked: boolean;
    is_deleted: boolean;
    upvotes: number;
    downvotes: number;
    comment_count: number;
    created_at: string;
    reports_count: number;
  }[];
  total: number;
  page: number;
  page_size: number;
  has_more: boolean;
}
interface CommentListDto {
  comments: {
    id: number;
    content: string;
    author_username: string;
    author_id: number;
    post_id: number;
    post_title: string;
    is_deleted: boolean;
    upvotes: number;
    downvotes: number;
    created_at: string;
    reports_count: number;
  }[];
  total: number;
  page: number;
  page_size: number;
  has_more: boolean;
}
interface DashboardDto {
  stats: {
    total_users: number;
    active_users: number;
    banned_users: number;
    total_posts: number;
    total_comments: number;
    posts_today: number;
    comments_today: number;
    new_users_today: number;
  };
  recent_activity: {
    type: string;
    message: string;
    timestamp: string;
    user_id?: number;
    post_id?: number;
  }[];
}
interface RoleListDto {
  roles: {
    id: number;
    name: string;
    permissions: string[];
    user_count: number;
  }[];
}
@Injectable({ providedIn: 'root' })
export class AdminService {
  private readonly http = inject(HttpClient);
  private readonly apiUrl = `${environment.apiUrl}/admin`;
  getDashboard(): Observable<DashboardResponse> {
    return this.http.get<DashboardDto>(`${this.apiUrl}/dashboard`).pipe(
      map((dto) => ({
        stats: {
          totalUsers: dto.stats.total_users,
          activeUsers: dto.stats.active_users,
          bannedUsers: dto.stats.banned_users,
          totalPosts: dto.stats.total_posts,
          totalComments: dto.stats.total_comments,
          postsToday: dto.stats.posts_today,
          commentsToday: dto.stats.comments_today,
          newUsersToday: dto.stats.new_users_today,
        },
        recentActivity: dto.recent_activity.map((a) => ({
          type: a.type,
          message: a.message,
          timestamp: a.timestamp,
          userId: a.user_id,
          postId: a.post_id,
        })),
      }))
    );
  }
  getUsers(options: {
    page?: number;
    pageSize?: number;
    search?: string;
    role?: string;
    status?: string;
    sortBy?: string;
    sortOrder?: string;
  } = {}): Observable<UserListResponse> {
    let params = new HttpParams();
    if (options.page) params = params.set('page', options.page.toString());
    if (options.pageSize) params = params.set('page_size', options.pageSize.toString());
    if (options.search) params = params.set('search', options.search);
    if (options.role) params = params.set('role', options.role);
    if (options.status) params = params.set('status', options.status);
    if (options.sortBy) params = params.set('sort_by', options.sortBy);
    if (options.sortOrder) params = params.set('sort_order', options.sortOrder);
    return this.http.get<UserListDto>(`${this.apiUrl}/users`, { params }).pipe(
      map((dto) => ({
        users: dto.users.map((u) => this.mapUserListItem(u)),
        total: dto.total,
        page: dto.page,
        pageSize: dto.page_size,
        hasMore: dto.has_more,
      }))
    );
  }
  getUserDetail(userId: number): Observable<UserDetail> {
    return this.http.get<UserDetailDto>(`${this.apiUrl}/users/${userId}`).pipe(
      map((dto) => this.mapUserDetail(dto))
    );
  }
  banUser(userId: number, reason?: string): Observable<ActionResponse> {
    return this.http.post<ActionResponse>(`${this.apiUrl}/users/${userId}/ban`, {
      reason,
    });
  }
  unbanUser(userId: number): Observable<ActionResponse> {
    return this.http.post<ActionResponse>(`${this.apiUrl}/users/${userId}/unban`, {});
  }
  changeUserRole(userId: number, role: RoleType): Observable<ActionResponse> {
    return this.http.post<ActionResponse>(`${this.apiUrl}/users/${userId}/role`, {
      role,
    });
  }
  deleteUser(userId: number): Observable<ActionResponse> {
    return this.http.delete<ActionResponse>(`${this.apiUrl}/users/${userId}`);
  }
  getPosts(options: {
    page?: number;
    pageSize?: number;
    search?: string;
    status?: string;
    sortBy?: string;
    sortOrder?: string;
  } = {}): Observable<PostAdminListResponse> {
    let params = new HttpParams();
    if (options.page) params = params.set('page', options.page.toString());
    if (options.pageSize) params = params.set('page_size', options.pageSize.toString());
    if (options.search) params = params.set('search', options.search);
    if (options.status) params = params.set('status', options.status);
    if (options.sortBy) params = params.set('sort_by', options.sortBy);
    if (options.sortOrder) params = params.set('sort_order', options.sortOrder);
    return this.http.get<PostListDto>(`${this.apiUrl}/posts`, { params }).pipe(
      map((dto) => ({
        posts: dto.posts.map((p) => this.mapPostListItem(p)),
        total: dto.total,
        page: dto.page,
        pageSize: dto.page_size,
        hasMore: dto.has_more,
      }))
    );
  }
  lockPost(postId: number, reason?: string): Observable<ActionResponse> {
    return this.http.post<ActionResponse>(`${this.apiUrl}/posts/${postId}/lock`, {
      reason,
    });
  }
  unlockPost(postId: number): Observable<ActionResponse> {
    return this.http.post<ActionResponse>(`${this.apiUrl}/posts/${postId}/unlock`, {});
  }
  deletePost(postId: number): Observable<ActionResponse> {
    return this.http.delete<ActionResponse>(`${this.apiUrl}/posts/${postId}`);
  }
  restorePost(postId: number): Observable<ActionResponse> {
    return this.http.post<ActionResponse>(`${this.apiUrl}/posts/${postId}/restore`, {});
  }
  getComments(options: {
    page?: number;
    pageSize?: number;
    search?: string;
    postId?: number;
    status?: string;
  } = {}): Observable<CommentAdminListResponse> {
    let params = new HttpParams();
    if (options.page) params = params.set('page', options.page.toString());
    if (options.pageSize) params = params.set('page_size', options.pageSize.toString());
    if (options.search) params = params.set('search', options.search);
    if (options.postId) params = params.set('post_id', options.postId.toString());
    if (options.status) params = params.set('status', options.status);
    return this.http.get<CommentListDto>(`${this.apiUrl}/comments`, { params }).pipe(
      map((dto) => ({
        comments: dto.comments.map((c) => this.mapCommentListItem(c)),
        total: dto.total,
        page: dto.page,
        pageSize: dto.page_size,
        hasMore: dto.has_more,
      }))
    );
  }
  deleteComment(commentId: number): Observable<ActionResponse> {
    return this.http.delete<ActionResponse>(`${this.apiUrl}/comments/${commentId}`);
  }
  getRoles(): Observable<RoleInfo[]> {
    return this.http.get<RoleListDto>(`${this.apiUrl}/roles`).pipe(
      map((dto) =>
        dto.roles.map((r) => ({
          id: r.id,
          name: r.name as RoleType,
          permissions: r.permissions,
          userCount: r.user_count,
        }))
      )
    );
  }
  private mapUserListItem(dto: UserListDto['users'][0]): UserListItem {
    return {
      id: dto.id,
      username: dto.username,
      email: dto.email,
      avatarUrl: dto.avatar_url,
      role: dto.role as RoleType,
      isActive: dto.is_active,
      isBanned: dto.is_banned,
      createdAt: dto.created_at,
      postCount: dto.post_count,
      commentCount: dto.comment_count,
    };
  }
  private mapUserDetail(dto: UserDetailDto): UserDetail {
    return {
      id: dto.id,
      username: dto.username,
      email: dto.email,
      avatarUrl: dto.avatar_url,
      bio: dto.bio,
      role: dto.role as RoleType,
      isActive: dto.is_active,
      isBanned: dto.is_banned,
      banReason: dto.ban_reason,
      createdAt: dto.created_at,
      updatedAt: dto.updated_at,
      postCount: dto.post_count,
      commentCount: dto.comment_count,
    };
  }
  private mapPostListItem(dto: PostListDto['posts'][0]): PostAdminListItem {
    return {
      id: dto.id,
      title: dto.title,
      authorUsername: dto.author_username,
      authorId: dto.author_id,
      isLocked: dto.is_locked,
      isDeleted: dto.is_deleted,
      upvotes: dto.upvotes,
      downvotes: dto.downvotes,
      commentCount: dto.comment_count,
      createdAt: dto.created_at,
      reportsCount: dto.reports_count,
    };
  }
  private mapCommentListItem(dto: CommentListDto['comments'][0]): CommentAdminListItem {
    return {
      id: dto.id,
      content: dto.content,
      authorUsername: dto.author_username,
      authorId: dto.author_id,
      postId: dto.post_id,
      postTitle: dto.post_title,
      isDeleted: dto.is_deleted,
      upvotes: dto.upvotes,
      downvotes: dto.downvotes,
      createdAt: dto.created_at,
      reportsCount: dto.reports_count,
    };
  }
}
FILE: src/app/core/services/auth.ts
import { Injectable, computed, inject, signal } from '@angular/core';
import { HttpClient, HttpErrorResponse } from '@angular/common/http';
import { Router } from '@angular/router';
import { environment } from '../config/environment';
import { getFirebaseAuth } from '../firebase/firebase';
import {
  GithubAuthProvider,
  GoogleAuthProvider,
  UserCredential,
  createUserWithEmailAndPassword,
  signInWithEmailAndPassword,
  signInWithPopup,
  signOut,
} from 'firebase/auth';
import { lastValueFrom } from 'rxjs';
import { TokenResponse } from '../models/auth.model';
import { User } from '../models/user.model';
@Injectable({ providedIn: 'root' })
export class Auth {
  private readonly http = inject(HttpClient);
  private readonly router = inject(Router);
  private readonly storageKey = environment.storageKeys.auth;
  private _permissionService: PermissionService | null = null;
  private get permissionService(): PermissionService {
    if (!this._permissionService) {
      this._permissionService = inject(PermissionService);
    }
    return this._permissionService;
  }
  private readonly userSignal = signal<User | null>(null);
  private readonly tokenSignal = signal<string | null>(null);
  private readonly readySignal = signal(false);
  private redirectUrl: string | null = null;
  readonly user = computed(() => this.userSignal());
  readonly isAuthenticated = computed(() => !!this.tokenSignal());
  readonly isReady = computed(() => this.readySignal());
  constructor() {
    this.restoreSession();
  }
  token(): string | null {
    return this.tokenSignal();
  }
  setRedirect(url: string) {
    this.redirectUrl = url;
  }
  async loginWithEmail(email: string, password: string) {
    const auth = this.ensureFirebase();
    const credentials = await signInWithEmailAndPassword(auth, email, password);
    await this.exchangeFirebaseToken(credentials);
  }
  async signupWithEmail(username: string, email: string, password: string) {
    const auth = this.ensureFirebase();
    const credentials = await createUserWithEmailAndPassword(auth, email, password);
    await this.registerWithBackend(credentials, username);
  }
  async loginWithGoogle() {
    const auth = this.ensureFirebase();
    const credentials = await signInWithPopup(auth, new GoogleAuthProvider());
    await this.exchangeFirebaseToken(credentials);
  }
  async loginWithGithub() {
    const auth = this.ensureFirebase();
    const credentials = await signInWithPopup(auth, new GithubAuthProvider());
    await this.exchangeFirebaseToken(credentials);
  }
  async logout() {
    const auth = getFirebaseAuth();
    if (auth) await signOut(auth);
    this.clearSession();
    try {
      this.permissionService.clearPermissions();
    } catch (e) {
    }
    await this.router.navigate(['/login']);
  }
  handleUnauthorized() {
    this.clearSession();
    try {
      this.permissionService.clearPermissions();
    } catch (e) {
    }
    this.router.navigate(['/login']);
  }
  private async registerWithBackend(credentials: UserCredential, username: string) {
    const idToken = await credentials.user.getIdToken();
    const email = credentials.user.email ?? this.buildFallbackEmail(credentials.user.uid);
    await lastValueFrom(
      this.http.post(`${environment.apiUrl}/auth/register`, {
        id_token: idToken,
        firebase_uid: credentials.user.uid,
        email,
        username,
        avatar_url: credentials.user.photoURL ?? null,
      }),
    );
    await this.exchangeFirebaseToken(credentials, false);
  }
  private async exchangeFirebaseToken(
    credentials: UserCredential,
    allowAutoRegister = true,
  ) {
    const idToken = await credentials.user.getIdToken();
    try {
      const response = await lastValueFrom(
        this.http.post<TokenResponse>(`${environment.apiUrl}/auth/login`, { id_token: idToken }),
      );
      const user = this.mapUser(response.user);
      this.persistSession(response.access_token, user);
      await this.loadUserPermissions();
      await this.router.navigateByUrl(this.redirectUrl ?? '/feed');
      this.redirectUrl = null;
    } catch (error) {
      if (
        allowAutoRegister &&
        error instanceof HttpErrorResponse &&
        error.status === 404
      ) {
        const username = this.generateUsername(
          credentials.user.displayName,
          credentials.user.email,
        );
        await this.registerWithBackend(credentials, username);
        return;
      }
      throw error;
    }
  }
  private async loadUserPermissions() {
    try {
      await this.permissionService.loadPermissions();
    } catch (error) {
      console.warn('Failed to load user permissions', error);
    }
  }
  private mapUser(user: TokenResponse['user']): User {
    const validRoles = ['admin', 'moderator', 'user'] as const;
    const role = validRoles.includes(user.role as any) ? (user.role as 'admin' | 'moderator' | 'user') : 'user';
    return {
      id: user.id,
      username: user.username,
      email: user.email,
      avatarUrl: user.avatar_url,
      bio: null,
      role,
      isActive: true,
      isBanned: false,
      createdAt: new Date().toISOString(),
      updatedAt: null,
    };
  }
  private persistSession(token: string, user: User) {
    this.tokenSignal.set(token);
    this.userSignal.set(user);
    localStorage.setItem(this.storageKey, JSON.stringify({ token, user }));
  }
  private restoreSession() {
    const cache = localStorage.getItem(this.storageKey);
    if (cache) {
      try {
        const parsed = JSON.parse(cache) as { token: string; user: User };
        this.tokenSignal.set(parsed.token);
        this.userSignal.set(parsed.user);
        setTimeout(() => {
          this.loadUserPermissions();
        }, 0);
      } catch (error) {
        console.warn('Failed to restore session', error);
        this.clearSession();
      }
    }
    this.readySignal.set(true);
  }
  private clearSession() {
    this.tokenSignal.set(null);
    this.userSignal.set(null);
    localStorage.removeItem(this.storageKey);
  }
  private ensureFirebase() {
    const auth = getFirebaseAuth();
    if (!auth) throw new Error('Firebase is not configured. Update environment.firebase.*');
    return auth;
  }
  private generateUsername(displayName?: string | null, email?: string | null): string {
    const sanitise = (value: string | null | undefined) =>
      value?.replace(/[^a-zA-Z0-9]/g, '').toLowerCase() ?? '';
    let base = sanitise(displayName);
    if (base.length < 3) {
      base = sanitise(email?.split('@')[0]);
    }
    if (base.length < 3) {
      base = 'user';
    }
    const suffix = Math.floor(Math.random() * 10_000)
      .toString()
      .padStart(4, '0');
    return `${base}${suffix}`.slice(0, 20);
  }
  private buildFallbackEmail(uid: string): string {
    return `${uid}@placeholder.local`;
  }
}
import { PermissionService } from './permission';
FILE: src/app/core/services/favorite.ts
import { Injectable, signal } from '@angular/core';
@Injectable({ providedIn: 'root' })
export class FavoriteState {
  private readonly favoritesChanged = signal<number>(0);
  readonly changed = this.favoritesChanged.asReadonly();
  notifyChange() {
    this.favoritesChanged.update(v => v + 1);
  }
}
FILE: src/app/core/services/notification.ts
import { HttpClient } from '@angular/common/http';
import {
  Injectable,
  computed,
  effect,
  inject,
  signal,
} from '@angular/core';
import { environment } from '../config/environment';
import { Auth } from './auth';
import { Notification } from '../models/notification.model';
import { Websocket } from './websocket';
interface RawNotification {
  id: number;
  user_id?: number;
  userId?: number;
  type?: string;
  message?: string;
  link?: string | null;
  is_read?: boolean;
  isRead?: boolean;
  created_at?: string;
  createdAt?: string;
}
interface NotificationListResponse {
  notifications: RawNotification[];
  unread_count: number;
}
@Injectable({ providedIn: 'root' })
export class NotificationService {
  private readonly http = inject(HttpClient);
  private readonly auth = inject(Auth);
  private readonly websocket = inject(Websocket);
  private readonly notificationsSignal = signal<Notification[]>([]);
  private readonly unreadCountSignal = signal(0);
  private readonly loadingSignal = signal(false);
  readonly notifications = this.notificationsSignal.asReadonly();
  readonly unreadCount = this.unreadCountSignal.asReadonly();
  readonly loading = this.loadingSignal.asReadonly();
  constructor() {
    effect(
      () => {
        if (this.auth.isAuthenticated()) {
          this.bootstrap();
          const handler = (payload: unknown) => this.handleIncoming(payload);
          this.websocket.registerHandler('notification', handler);
          return () => this.websocket.unregisterHandler('notification', handler);
        } else {
          this.notificationsSignal.set([]);
          this.unreadCountSignal.set(0);
        }
        return;
      },
      { allowSignalWrites: true },
    );
  }
  async bootstrap() {
    this.loadingSignal.set(true);
    try {
      const data = await this.http
        .get<NotificationListResponse>(`${environment.apiUrl}/users/me/notifications`)
        .toPromise();
      if (!data) return;
      const mapped = data.notifications.map((notification) => ({
        id: Number(notification.id),
        userId: Number(notification.userId ?? notification.user_id ?? 0),
        type: notification.type ?? 'notification',
        message: notification.message ?? '',
        link: notification.link ?? null,
        isRead: notification.isRead ?? notification.is_read ?? false,
        createdAt: notification.createdAt ?? notification.created_at ?? new Date().toISOString(),
      }));
      this.notificationsSignal.set(mapped);
      this.unreadCountSignal.set(data.unread_count);
    } finally {
      this.loadingSignal.set(false);
    }
  }
  async markAsRead(id: number) {
    await this.http
      .post(`${environment.apiUrl}/users/me/notifications/${id}/read`, {})
      .toPromise();
    this.notificationsSignal.update((list) =>
      list.map((notification) =>
        notification.id === id ? { ...notification, isRead: true } : notification,
      ),
    );
    this.unreadCountSignal.update((count) => Math.max(0, count - 1));
  }
  async markAllAsRead() {
    await this.http
      .post<{ message: string }>(`${environment.apiUrl}/users/me/notifications/read-all`, {})
      .toPromise();
    this.notificationsSignal.update((list) =>
      list.map((notification) => ({ ...notification, isRead: true })),
    );
    this.unreadCountSignal.set(0);
  }
  private handleIncoming(payload: unknown) {
    const data = (payload as { notification?: Partial<RawNotification> })?.notification;
    if (!data || !data.id) return;
    const normalised: Notification = {
      id: Number(data.id),
      userId: Number(data.userId ?? data.user_id ?? 0),
      type: data.type ?? 'notification',
      message: data.message ?? '',
      link: data.link ?? null,
      isRead: false,
      createdAt: String(data.createdAt ?? data.created_at ?? new Date().toISOString()),
    };
    this.notificationsSignal.update((list) => [
      normalised,
      ...list.filter((notification) => notification.id !== normalised.id),
    ]);
    this.unreadCountSignal.update((count) => count + 1);
  }
}
FILE: src/app/core/services/permission.ts
import { Injectable, computed, inject, signal } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { environment } from '../config/environment';
import { UserPermissions, RoleType } from '../models/admin.model';
export const Permissions = {
  CREATE_POST: 'create_post',
  EDIT_OWN_POST: 'edit_own_post',
  DELETE_OWN_POST: 'delete_own_post',
  CREATE_COMMENT: 'create_comment',
  EDIT_OWN_COMMENT: 'edit_own_comment',
  DELETE_OWN_COMMENT: 'delete_own_comment',
  VOTE: 'vote',
  FAVORITE: 'favorite',
  DELETE_ANY_POST: 'delete_any_post',
  DELETE_ANY_COMMENT: 'delete_any_comment',
  LOCK_POST: 'lock_post',
  UNLOCK_POST: 'unlock_post',
  BAN_USER_FROM_THREAD: 'ban_user_from_thread',
  VIEW_REPORTS: 'view_reports',
  BAN_USER: 'ban_user',
  UNBAN_USER: 'unban_user',
  PROMOTE_USER: 'promote_user',
  DEMOTE_USER: 'demote_user',
  DELETE_USER: 'delete_user',
  VIEW_ALL_USERS: 'view_all_users',
  MANAGE_ROLES: 'manage_roles',
  VIEW_ADMIN_DASHBOARD: 'view_admin_dashboard',
  MANAGE_CATEGORIES: 'manage_categories',
} as const;
const AUTH_STORAGE_KEY = environment.storageKeys?.auth ?? 'meme_forum_auth';
interface StoredAuthData {
  token: string;
  user: {
    id: number;
    username: string;
    email: string;
    role: string;
    avatarUrl: string | null;
    bio: string | null;
    isActive: boolean;
    isBanned: boolean;
    createdAt: string;
    updatedAt: string | null;
  };
}
@Injectable({ providedIn: 'root' })
export class PermissionService {
  private readonly http = inject(HttpClient);
  private readonly permissionsSignal = signal<UserPermissions | null>(null);
  private readonly loadingSignal = signal(false);
  readonly permissions = this.permissionsSignal.asReadonly();
  readonly loading = this.loadingSignal.asReadonly();
  readonly isAdmin = computed(() => {
    const perms = this.permissionsSignal();
    return perms?.isAdmin ?? false;
  });
  readonly isModerator = computed(() => {
    const perms = this.permissionsSignal();
    return perms?.isModerator ?? false;
  });
  readonly userRole = computed(() => {
    const perms = this.permissionsSignal();
    return perms?.role ?? 'user';
  });
  constructor() {
    if (this.isUserAuthenticated()) {
      this.loadPermissions();
    }
  }
  private isUserAuthenticated(): boolean {
    try {
      const authData = localStorage.getItem(AUTH_STORAGE_KEY);
      if (!authData) return false;
      const parsed = JSON.parse(authData) as StoredAuthData;
      return !!parsed.token;
    } catch {
      return false;
    }
  }
  private getStoredUser(): StoredAuthData['user'] | null {
    try {
      const authData = localStorage.getItem(AUTH_STORAGE_KEY);
      if (!authData) return null;
      const parsed = JSON.parse(authData) as StoredAuthData;
      return parsed.user ?? null;
    } catch {
      return null;
    }
  }
  getCurrentUserId(): number | null {
    const user = this.getStoredUser();
    return user?.id ?? null;
  }
  async loadPermissions(): Promise<void> {
    if (!this.isUserAuthenticated()) {
      this.permissionsSignal.set(null);
      return;
    }
    this.loadingSignal.set(true);
    try {
      const response = await this.http
        .get<{
          user_id: number;
          username: string;
          role: RoleType;
          permissions: string[];
          is_admin: boolean;
          is_moderator: boolean;
        }>(`${environment.apiUrl}/admin/me/permissions`)
        .toPromise();
      if (response) {
        this.permissionsSignal.set({
          userId: response.user_id,
          username: response.username,
          role: response.role,
          permissions: response.permissions,
          isAdmin: response.is_admin,
          isModerator: response.is_moderator,
        });
      }
    } catch (error) {
      console.warn('Failed to load permissions from server, using local data', error);
      const user = this.getStoredUser();
      if (user) {
        this.permissionsSignal.set({
          userId: user.id,
          username: user.username,
          role: (user.role as RoleType) || 'user',
          permissions: this.getDefaultPermissionsForRole(user.role),
          isAdmin: user.role === 'admin',
          isModerator: user.role === 'admin' || user.role === 'moderator',
        });
      } else {
        this.permissionsSignal.set(null);
      }
    } finally {
      this.loadingSignal.set(false);
    }
  }
  private getDefaultPermissionsForRole(role: string): string[] {
    const userPermissions = [
      Permissions.CREATE_POST,
      Permissions.EDIT_OWN_POST,
      Permissions.DELETE_OWN_POST,
      Permissions.CREATE_COMMENT,
      Permissions.EDIT_OWN_COMMENT,
      Permissions.DELETE_OWN_COMMENT,
      Permissions.VOTE,
      Permissions.FAVORITE,
    ];
    const moderatorPermissions = [
      ...userPermissions,
      Permissions.DELETE_ANY_POST,
      Permissions.DELETE_ANY_COMMENT,
      Permissions.LOCK_POST,
      Permissions.UNLOCK_POST,
      Permissions.BAN_USER_FROM_THREAD,
      Permissions.VIEW_REPORTS,
    ];
    const adminPermissions = [
      ...moderatorPermissions,
      Permissions.BAN_USER,
      Permissions.UNBAN_USER,
      Permissions.PROMOTE_USER,
      Permissions.DEMOTE_USER,
      Permissions.DELETE_USER,
      Permissions.VIEW_ALL_USERS,
      Permissions.MANAGE_ROLES,
      Permissions.VIEW_ADMIN_DASHBOARD,
      Permissions.MANAGE_CATEGORIES,
    ];
    switch (role) {
      case 'admin':
        return adminPermissions;
      case 'moderator':
        return moderatorPermissions;
      default:
        return userPermissions;
    }
  }
  hasPermission(permission: string): boolean {
    const perms = this.permissionsSignal();
    if (!perms) return false;
    return perms.permissions.includes(permission);
  }
  hasAnyPermission(permissions: string[]): boolean {
    return permissions.some((p) => this.hasPermission(p));
  }
  hasAllPermissions(permissions: string[]): boolean {
    return permissions.every((p) => this.hasPermission(p));
  }
  canModerateContent(contentUserId: number): boolean {
    const currentUserId = this.getCurrentUserId();
    if (!currentUserId) return false;
    if (currentUserId === contentUserId) return true;
    return this.isModerator();
  }
  isOwner(resourceUserId: number): boolean {
    const currentUserId = this.getCurrentUserId();
    return currentUserId !== null && currentUserId === resourceUserId;
  }
  clearPermissions(): void {
    this.permissionsSignal.set(null);
  }
  async refreshPermissions(): Promise<void> {
    await this.loadPermissions();
  }
}
FILE: src/app/core/services/theme.ts
import { Injectable } from '@angular/core';
@Injectable({
  providedIn: 'root',
})
export class Theme {
}
FILE: src/app/core/services/vote-state.ts
import { Injectable, inject, signal, computed, effect } from '@angular/core';
import { Websocket, VoteUpdate } from './websocket';
import { Auth } from './auth';
interface VoteCache {
  upvotes: number;
  downvotes: number;
  userVote: 'up' | 'down' | null;
  timestamp: number;
}
@Injectable({ providedIn: 'root' })
export class VoteState {
  private readonly websocket = inject(Websocket);
  private readonly auth = inject(Auth);
  private readonly postVotes = signal<Map<number, VoteCache>>(new Map());
  private readonly commentVotes = signal<Map<number, VoteCache>>(new Map());
  private readonly pendingVotes = signal<Set<string>>(new Set());
  constructor() {
    effect(() => {
      if (this.auth.isAuthenticated()) {
        this.initializeWebSocket();
      }
    }, { allowSignalWrites: true });
  }
  private initializeWebSocket() {
    this.websocket.registerHandler('vote_update', (payload: unknown) => {
      this.handleVoteUpdate(payload as VoteUpdate);
    });
  }
  private handleVoteUpdate(update: VoteUpdate) {
    const userId = this.auth.user()?.id;
    if (!userId) return;
    const userVote = update.userVotes[userId] ?? null;
    const cache: VoteCache = {
      upvotes: update.upvotes,
      downvotes: update.downvotes,
      userVote,
      timestamp: Date.now()
    };
    if (update.commentId) {
      this.commentVotes.update(map => {
        const newMap = new Map(map);
        newMap.set(update.commentId!, cache);
        return newMap;
      });
    } else {
      this.postVotes.update(map => {
        const newMap = new Map(map);
        newMap.set(update.postId, cache);
        return newMap;
      });
    }
    const voteKey = update.commentId
      ? `comment-${update.commentId}`
      : `post-${update.postId}`;
    this.pendingVotes.update(set => {
      const newSet = new Set(set);
      newSet.delete(voteKey);
      return newSet;
    });
  }
  getPostVote(postId: number): VoteCache | null {
    return this.postVotes().get(postId) ?? null;
  }
  getCommentVote(commentId: number): VoteCache | null {
    return this.commentVotes().get(commentId) ?? null;
  }
  isPending(type: 'post' | 'comment', id: number): boolean {
    const key = `${type}-${id}`;
    return this.pendingVotes().has(key);
  }
  setPending(type: 'post' | 'comment', id: number, pending: boolean) {
    const key = `${type}-${id}`;
    this.pendingVotes.update(set => {
      const newSet = new Set(set);
      if (pending) {
        newSet.add(key);
      } else {
        newSet.delete(key);
      }
      return newSet;
    });
  }
  optimisticVote(type: 'post' | 'comment', id: number, vote: 'up' | 'down' | null, currentVote: 'up' | 'down' | null) {
    const map = type === 'post' ? this.postVotes : this.commentVotes;
    const current = (type === 'post' ? this.getPostVote(id) : this.getCommentVote(id)) ?? {
      upvotes: 0,
      downvotes: 0,
      userVote: currentVote,
      timestamp: Date.now()
    };
    let newUpvotes = current.upvotes;
    let newDownvotes = current.downvotes;
    if (currentVote === 'up') newUpvotes--;
    else if (currentVote === 'down') newDownvotes--;
    if (vote === 'up') newUpvotes++;
    else if (vote === 'down') newDownvotes++;
    const optimisticCache: VoteCache = {
      upvotes: newUpvotes,
      downvotes: newDownvotes,
      userVote: vote,
      timestamp: Date.now()
    };
    map.update(m => {
      const newMap = new Map(m);
      newMap.set(id, optimisticCache);
      return newMap;
    });
  }
}
FILE: src/app/core/services/websocket.ts
import { inject, Injectable, signal, effect } from '@angular/core';
import { environment } from '../config/environment';
import { Auth } from './auth';
type Handler = (payload: unknown) => void;
export interface VoteUpdate {
  postId: number;
  commentId?: number;
  upvotes: number;
  downvotes: number;
  userVotes: { [userId: number]: 'up' | 'down' | null };
}
@Injectable({ providedIn: 'root' })
export class Websocket {
  private readonly auth = inject(Auth);
  private socket: WebSocket | null = null;
  private readonly handlers = new Map<string, Set<Handler>>();
  private reconnectAttempts = 0;
  private readonly connecting = signal(false);
  private readonly connected = signal(false);
  readonly isConnected = this.connected.asReadonly();
  constructor() {
    effect(() => {
      if (this.auth.isAuthenticated()) {
        this.connect();
      } else {
        this.disconnect();
      }
    });
  }
  registerHandler(type: string, handler: Handler) {
    if (!this.handlers.has(type)) {
      this.handlers.set(type, new Set());
    }
    this.handlers.get(type)!.add(handler);
    if (this.connected() && type === 'vote') {
      this.send({ type: 'subscribe_votes' });
    }
  }
  unregisterHandler(type: string, handler: Handler) {
    this.handlers.get(type)?.delete(handler);
  }
  send(message: unknown) {
    if (this.socket?.readyState === WebSocket.OPEN) {
      this.socket.send(JSON.stringify(message));
    } else {
      console.warn('WebSocket not connected, queuing message');
    }
  }
  private connect() {
    if (this.connecting() || this.socket?.readyState === WebSocket.OPEN) {
      return;
    }
    const token = this.auth.token();
    if (!token) return;
    this.connecting.set(true);
    const url = new URL(environment.websocketUrl);
    url.searchParams.set('token', token);
    this.socket = new WebSocket(url.toString());
    this.socket.onopen = () => {
      console.log('WebSocket connected');
      this.reconnectAttempts = 0;
      this.connecting.set(false);
      this.connected.set(true);
      this.send({ type: 'subscribe_votes' });
    };
    this.socket.onmessage = (event) => {
      try {
        const data = JSON.parse(event.data);
        const type = data?.type ?? 'message';
        this.handlers.get(type)?.forEach((handler) => handler(data));
        if (type === 'vote_update') {
          this.handlers.get('vote')?.forEach((handler) => handler(data));
        }
      } catch (error) {
        console.error('Failed to parse WebSocket message', error);
      }
    };
    this.socket.onclose = () => {
      console.log('WebSocket disconnected');
      this.socket = null;
      this.connecting.set(false);
      this.connected.set(false);
      this.scheduleReconnect();
    };
    this.socket.onerror = (error) => {
      console.error('WebSocket error', error);
      this.socket?.close();
    };
  }
  private scheduleReconnect() {
    if (!this.auth.isAuthenticated()) return;
    const delay = Math.min(30000, 1000 * 2 ** this.reconnectAttempts);
    this.reconnectAttempts += 1;
    console.log(`Reconnecting WebSocket in ${delay}ms (attempt ${this.reconnectAttempts})`);
    setTimeout(() => {
      if (this.auth.isAuthenticated()) {
        this.connect();
      }
    }, delay);
  }
  private disconnect() {
    this.handlers.clear();
    this.socket?.close();
    this.socket = null;
    this.reconnectAttempts = 0;
    this.connecting.set(false);
    this.connected.set(false);
  }
}
FILE: src/app/features/admin/admin-comments/admin-comments.html
<div class="admin-comments">
  <div class="page-header">
    <h1>Comment Management</h1>
    <a routerLink="/admin" class="back-link">
      <span class="material-icons">arrow_back</span>
      Back to Dashboard
    </a>
  </div>

  <div class="filters-section">
    <div class="search-box">
      <span class="material-icons">search</span>
      <input
        type="text"
        [(ngModel)]="searchQuery"
        placeholder="Search comments..."
        (keyup.enter)="applyFilters()"
      />
    </div>

    <select [(ngModel)]="statusFilter" (change)="applyFilters()">
      <option value="">All Status</option>
      <option value="active">Active</option>
      <option value="deleted">Deleted</option>
    </select>
  </div>

  @if (isLoading()) {
    <app-loading-spinner></app-loading-spinner>
  } @else {
    <div class="comments-table-container">
      <table class="comments-table">
        <thead>
          <tr>
            <th>Content</th>
            <th>Author</th>
            <th>Post</th>
            <th>Status</th>
            <th>Votes</th>
            <th>Created</th>
            <th>Actions</th>
          </tr>
        </thead>
        <tbody>
          @for (comment of comments(); track comment.id) {
            <tr [class.deleted]="comment.isDeleted">
              <td class="content-cell">
                <span [title]="comment.content">{{ truncateContent(comment.content) }}</span>
              </td>
              <td>{{ comment.authorUsername }}</td>
              <td class="post-cell">
                <a [routerLink]="['/post', comment.postId]" [title]="comment.postTitle">
                  {{ truncateContent(comment.postTitle, 30) }}
                </a>
              </td>
              <td>
                @if (comment.isDeleted) {
                  <span class="status-badge deleted">Deleted</span>
                } @else {
                  <span class="status-badge active">Active</span>
                }
              </td>
              <td>
                <span class="votes">
                  <span class="up">â†‘{{ comment.upvotes }}</span>
                  <span class="down">â†“{{ comment.downvotes }}</span>
                </span>
              </td>
              <td>{{ formatDate(comment.createdAt) }}</td>
              <td class="actions-cell">
                @if (!comment.isDeleted) {
                  <button
                    class="action-btn delete"
                    title="Delete"
                    (click)="deleteComment(comment)"
                  >
                    <span class="material-icons">delete</span>
                  </button>
                }
              </td>
            </tr>
          } @empty {
            <tr>
              <td colspan="7" class="empty-message">No comments found</td>
            </tr>
          }
        </tbody>
      </table>
    </div>

    <div class="pagination">
      <button (click)="prevPage()" [disabled]="currentPage() === 1">
        <span class="material-icons">chevron_left</span>
      </button>
      <span>Page {{ currentPage() }} of {{ Math.ceil(total() / pageSize) || 1 }}</span>
      <button (click)="nextPage()" [disabled]="currentPage() * pageSize >= total()">
        <span class="material-icons">chevron_right</span>
      </button>
    </div>
  }
</div>
FILE: src/app/features/admin/admin-comments/admin-comments.ts
import { ChangeDetectionStrategy, Component, OnInit, inject, signal } from '@angular/core';
import { CommonModule } from '@angular/common';
import { FormsModule } from '@angular/forms';
import { RouterLink } from '@angular/router';
import { AdminService } from '../../../core/services/admin';
import { CommentAdminListItem } from '../../../core/models/admin.model';
import { LoadingSpinner } from '../../../shared/components/loading-spinner/loading-spinner';
@Component({
  selector: 'app-admin-comments',
  standalone: true,
  imports: [CommonModule, FormsModule, RouterLink, LoadingSpinner],
  templateUrl: './admin-comments.html',
  styleUrl: './admin-comments.css',
  changeDetection: ChangeDetectionStrategy.OnPush,
})
export class AdminComments implements OnInit {
  private readonly adminService = inject(AdminService);
  readonly comments = signal<CommentAdminListItem[]>([]);
  readonly isLoading = signal(true);
  readonly total = signal(0);
  readonly currentPage = signal(1);
  readonly pageSize = 20;
  searchQuery = '';
  statusFilter = '';
  readonly Math = Math;
  ngOnInit() {
    this.loadComments();
  }
  loadComments() {
    this.isLoading.set(true);
    this.adminService.getComments({
      page: this.currentPage(),
      pageSize: this.pageSize,
      search: this.searchQuery || undefined,
      status: this.statusFilter || undefined,
    }).subscribe({
      next: (response) => {
        this.comments.set(response.comments);
        this.total.set(response.total);
        this.isLoading.set(false);
      },
      error: (err) => {
        console.error('Failed to load comments', err);
        this.isLoading.set(false);
      },
    });
  }
  applyFilters() {
    this.currentPage.set(1);
    this.loadComments();
  }
  deleteComment(comment: CommentAdminListItem) {
    if (!confirm('Delete this comment?')) return;
    this.adminService.deleteComment(comment.id).subscribe({
      next: () => this.loadComments(),
      error: (err) => alert('Failed to delete comment'),
    });
  }
  nextPage() {
    if (this.currentPage() * this.pageSize < this.total()) {
      this.currentPage.update(p => p + 1);
      this.loadComments();
    }
  }
  prevPage() {
    if (this.currentPage() > 1) {
      this.currentPage.update(p => p - 1);
      this.loadComments();
    }
  }
  formatDate(date: string): string {
    return new Date(date).toLocaleDateString();
  }
  truncateContent(content: string, maxLength: number = 100): string {
    if (content.length <= maxLength) return content;
    return content.substring(0, maxLength) + '...';
  }
}
FILE: src/app/features/admin/admin-dashboard/admin-dashboard.html
<div class="admin-dashboard">
  <div class="dashboard-header">
    <h1>Admin Dashboard</h1>
    <button class="refresh-btn" (click)="loadDashboard()" [disabled]="isLoading()">
      <span class="material-icons">refresh</span>
    </button>
  </div>

  @if (isLoading()) {
    <app-loading-spinner></app-loading-spinner>
  } @else if (error()) {
    <div class="error-message">
      <span class="material-icons">error</span>
      <p>{{ error() }}</p>
      <button (click)="loadDashboard()">Retry</button>
    </div>
  } @else if (stats(); as stats) {
    <div class="stats-grid">
      <div class="stat-card">
        <div class="stat-icon users">
          <span class="material-icons">people</span>
        </div>
        <div class="stat-content">
          <span class="stat-value">{{ stats.totalUsers }}</span>
          <span class="stat-label">Total Users</span>
        </div>
      </div>

      <div class="stat-card">
        <div class="stat-icon active">
          <span class="material-icons">check_circle</span>
        </div>
        <div class="stat-content">
          <span class="stat-value">{{ stats.activeUsers }}</span>
          <span class="stat-label">Active Users</span>
        </div>
      </div>

      <div class="stat-card">
        <div class="stat-icon banned">
          <span class="material-icons">block</span>
        </div>
        <div class="stat-content">
          <span class="stat-value">{{ stats.bannedUsers }}</span>
          <span class="stat-label">Banned Users</span>
        </div>
      </div>

      <div class="stat-card">
        <div class="stat-icon posts">
          <span class="material-icons">article</span>
        </div>
        <div class="stat-content">
          <span class="stat-value">{{ stats.totalPosts }}</span>
          <span class="stat-label">Total Posts</span>
        </div>
      </div>

      <div class="stat-card">
        <div class="stat-icon comments">
          <span class="material-icons">comment</span>
        </div>
        <div class="stat-content">
          <span class="stat-value">{{ stats.totalComments }}</span>
          <span class="stat-label">Total Comments</span>
        </div>
      </div>

      <div class="stat-card">
        <div class="stat-icon today">
          <span class="material-icons">today</span>
        </div>
        <div class="stat-content">
          <span class="stat-value">{{ stats.postsToday }}</span>
          <span class="stat-label">Posts Today</span>
        </div>
      </div>
    </div>

    <div class="dashboard-sections">
      <div class="quick-actions">
        <h2>Quick Actions</h2>
        <div class="action-buttons">
          <a routerLink="/admin/users" class="action-btn">
            <span class="material-icons">manage_accounts</span>
            <span>Manage Users</span>
          </a>
          <a routerLink="/admin/posts" class="action-btn">
            <span class="material-icons">article</span>
            <span>Manage Posts</span>
          </a>
          <a routerLink="/admin/comments" class="action-btn">
            <span class="material-icons">comment</span>
            <span>Manage Comments</span>
          </a>
        </div>
      </div>

      <div class="recent-activity">
        <h2>Recent Activity</h2>
        <div class="activity-list">
          @for (activity of recentActivity(); track activity.timestamp) {
            <div class="activity-item">
              <span class="material-icons activity-icon">{{ getActivityIcon(activity.type) }}</span>
              <div class="activity-content">
                <p>{{ activity.message }}</p>
                <span class="activity-time">{{ formatTime(activity.timestamp) }}</span>
              </div>
            </div>
          } @empty {
            <p class="no-activity">No recent activity</p>
          }
        </div>
      </div>
    </div>
  }
</div>
FILE: src/app/features/admin/admin-dashboard/admin-dashboard.ts
import { ChangeDetectionStrategy, Component, OnInit, inject, signal } from '@angular/core';
import { CommonModule } from '@angular/common';
import { RouterLink } from '@angular/router';
import { AdminService } from '../../../core/services/admin';
import { DashboardStats, RecentActivity } from '../../../core/models/admin.model';
import { LoadingSpinner } from '../../../shared/components/loading-spinner/loading-spinner';
@Component({
  selector: 'app-admin-dashboard',
  standalone: true,
  imports: [CommonModule, RouterLink, LoadingSpinner],
  templateUrl: './admin-dashboard.html',
  styleUrl: './admin-dashboard.css',
  changeDetection: ChangeDetectionStrategy.OnPush,
})
export class AdminDashboard implements OnInit {
  private readonly adminService = inject(AdminService);
  readonly stats = signal<DashboardStats | null>(null);
  readonly recentActivity = signal<RecentActivity[]>([]);
  readonly isLoading = signal(true);
  readonly error = signal<string | null>(null);
  ngOnInit() {
    this.loadDashboard();
  }
  loadDashboard() {
    this.isLoading.set(true);
    this.error.set(null);
    this.adminService.getDashboard().subscribe({
      next: (response) => {
        this.stats.set(response.stats);
        this.recentActivity.set(response.recentActivity);
        this.isLoading.set(false);
      },
      error: (err) => {
        console.error('Failed to load dashboard', err);
        this.error.set('Failed to load dashboard data');
        this.isLoading.set(false);
      },
    });
  }
  formatTime(timestamp: string): string {
    const date = new Date(timestamp);
    const now = new Date();
    const diff = (now.getTime() - date.getTime()) / 1000;
    if (diff < 60) return 'Just now';
    if (diff < 3600) return `${Math.floor(diff / 60)}m ago`;
    if (diff < 86400) return `${Math.floor(diff / 3600)}h ago`;
    return `${Math.floor(diff / 86400)}d ago`;
  }
  getActivityIcon(type: string): string {
    switch (type) {
      case 'user_joined':
        return 'person_add';
      case 'post_created':
        return 'article';
      case 'comment_created':
        return 'comment';
      case 'user_banned':
        return 'block';
      default:
        return 'info';
    }
  }
}
FILE: src/app/features/admin/admin-posts/admin-posts.html
<div class="admin-posts">
  <div class="page-header">
    <h1>Manage Posts</h1>
    <p class="subtitle">View and moderate all posts</p>
  </div>


  <div class="filters-section">
    <div class="search-box">
      <input
        type="text"
        placeholder="Search posts..."
        [value]="searchQuery()"
        (input)="searchQuery.set($any($event.target).value)"
        (keyup.enter)="onSearch()"
      />
      <button class="btn-search" (click)="onSearch()">
        <span>ğŸ”</span>
      </button>
    </div>

    <div class="filter-group">
      <label>Status:</label>
      <select
        [value]="statusFilter()"
        (change)="statusFilter.set($any($event.target).value); onFilterChange()"
      >
        <option value="all">All</option>
        <option value="active">Active</option>
        <option value="locked">Locked</option>
        <option value="deleted">Deleted</option>
      </select>
    </div>

    <div class="filter-group">
      <label>Sort:</label>
      <select
        [value]="sortBy()"
        (change)="sortBy.set($any($event.target).value); onFilterChange()"
      >
        <option value="created_at">Date Created</option>
        <option value="upvotes">Upvotes</option>
        <option value="comment_count">Comments</option>
        <option value="reports_count">Reports</option>
      </select>
      <button
        class="btn-sort-order"
        (click)="sortOrder.set(sortOrder() === 'asc' ? 'desc' : 'asc'); onFilterChange()"
      >
        {{ sortOrder() === 'asc' ? 'â†‘' : 'â†“' }}
      </button>
    </div>
  </div>


  @if (error()) {
    <div class="error-message">
      {{ error() }}
      <button (click)="error.set(null)">âœ•</button>
    </div>
  }


  @if (loading()) {
    <div class="loading-spinner">
      <div class="spinner"></div>
      <p>Loading posts...</p>
    </div>
  }


  @if (!loading() && posts().length > 0) {
    <div class="table-container">
      <table class="data-table">
        <thead>
          <tr>
            <th>ID</th>
            <th>Title</th>
            <th>Author</th>
            <th>Status</th>
            <th>Votes</th>
            <th>Comments</th>
            <th>Created</th>
            <th>Actions</th>
          </tr>
        </thead>
        <tbody>
          @for (post of posts(); track post.id) {
            <tr [class]="getStatusClass(post)">
              <td>{{ post.id }}</td>
              <td class="title-cell">
                <a [routerLink]="['/posts', post.id]" target="_blank">
                  {{ post.title | slice:0:50 }}{{ post.title.length > 50 ? '...' : '' }}
                </a>
              </td>
              <td>
                <a [routerLink]="['/admin/users']" [queryParams]="{search: post.author_username}">
                  {{ post.author_username }}
                </a>
              </td>
              <td>
                <span class="status-badge" [class]="getStatusClass(post)">
                  {{ getStatusText(post) }}
                </span>
              </td>
              <td>
                <span class="votes">
                  <span class="upvotes">+{{ post.upvotes }}</span>
                  /
                  <span class="downvotes">-{{ post.downvotes }}</span>
                </span>
              </td>
              <td>{{ post.comment_count }}</td>
              <td>{{ formatDate(post.created_at) }}</td>
              <td class="actions-cell">
                @if (!post.is_deleted) {
                  @if (post.is_locked) {
                    <button class="btn-action btn-unlock" (click)="unlockPost(post)" title="Unlock">
                      ğŸ”“
                    </button>
                  } @else {
                    <button class="btn-action btn-lock" (click)="openLockModal(post)" title="Lock">
                      ğŸ”’
                    </button>
                  }
                  <button class="btn-action btn-delete" (click)="deletePost(post)" title="Delete">
                    ğŸ—‘ï¸
                  </button>
                } @else {
                  <button class="btn-action btn-restore" (click)="restorePost(post)" title="Restore">
                    â™»ï¸
                  </button>
                }
                <a class="btn-action btn-view" [routerLink]="['/posts', post.id]" target="_blank" title="View">
                  ğŸ‘ï¸
                </a>
              </td>
            </tr>
          }
        </tbody>
      </table>
    </div>


    <div class="pagination">
      <button
        class="btn-page"
        [disabled]="!hasPrevious()"
        (click)="previousPage()"
      >
        â† Previous
      </button>

      <span class="page-info">
        Page {{ currentPage() }} of {{ totalPages() }}
        <span class="total-count">({{ total() }} posts)</span>
      </span>

      <button
        class="btn-page"
        [disabled]="!hasMore()"
        (click)="nextPage()"
      >
        Next â†’
      </button>
    </div>
  }


  @if (!loading() && posts().length === 0) {
    <div class="empty-state">
      <span class="empty-icon">ğŸ“­</span>
      <h3>No posts found</h3>
      <p>Try adjusting your search or filters</p>
    </div>
  }


  @if (showLockModal()) {
    <div class="modal-overlay" (click)="closeLockModal()">
      <div class="modal-content" (click)="$event.stopPropagation()">
        <div class="modal-header">
          <h2>Lock Post</h2>
          <button class="btn-close" (click)="closeLockModal()">âœ•</button>
        </div>
        <div class="modal-body">
          <p>You are about to lock: <strong>{{ selectedPost()?.title }}</strong></p>
          <div class="form-group">
            <label for="lockReason">Reason (optional):</label>
            <textarea
              id="lockReason"
              [value]="lockReason()"
              (input)="lockReason.set($any($event.target).value)"
              placeholder="Enter reason for locking this post..."
              rows="3"
            ></textarea>
          </div>
        </div>
        <div class="modal-footer">
          <button class="btn-cancel" (click)="closeLockModal()">Cancel</button>
          <button class="btn-confirm" (click)="lockPost()">Lock Post</button>
        </div>
      </div>
    </div>
  }
</div>
FILE: src/app/features/admin/admin-posts/admin-posts.ts
import { Component, OnInit, inject, signal, computed } from '@angular/core';
import { CommonModule } from '@angular/common';
import { FormsModule } from '@angular/forms';
import { RouterLink } from '@angular/router';
import { AdminService } from '../../../core/services/admin';
interface AdminPost {
  id: number;
  title: string;
  author_username: string;
  author_id: number;
  is_locked: boolean;
  is_deleted: boolean;
  upvotes: number;
  downvotes: number;
  comment_count: number;
  created_at: string;
  reports_count: number;
}
@Component({
  selector: 'app-admin-posts',
  standalone: true,
  imports: [CommonModule, FormsModule, RouterLink],
  templateUrl: './admin-posts.html',
  styleUrls: ['./admin-posts.css']
})
export class AdminPosts implements OnInit {
  private adminService = inject(AdminService);
  posts = signal<AdminPost[]>([]);
  total = signal(0);
  currentPage = signal(1);
  pageSize = 20;
  loading = signal(false);
  error = signal<string | null>(null);
  searchQuery = signal('');
  statusFilter = signal<string>('all');
  sortBy = signal('created_at');
  sortOrder = signal<'asc' | 'desc'>('desc');
  totalPages = computed(() => Math.ceil(this.total() / this.pageSize) || 1);
  hasMore = computed(() => this.currentPage() * this.pageSize < this.total());
  hasPrevious = computed(() => this.currentPage() > 1);
  showLockModal = signal(false);
  selectedPost = signal<AdminPost | null>(null);
  lockReason = signal('');
  ngOnInit(): void {
    this.loadPosts();
  }
   loadPosts(): void {
    this.loading.set(true);
    this.error.set(null);
    const params = {
      page: this.currentPage(),
      page_size: this.pageSize,
      search: this.searchQuery() || undefined,
      status: this.statusFilter() !== 'all' ? this.statusFilter() : undefined,
      sort_by: this.sortBy(),
      sort_order: this.sortOrder()
    };
    this.adminService.getPosts(params).subscribe({
      next: (response: any) => {
        const posts = response.items || response.posts || [];
        this.posts.set(posts);
        this.total.set(response.total || 0);
        this.loading.set(false);
      },
      error: (err) => {
        this.error.set(err.error?.detail || 'Failed to load posts');
        this.loading.set(false);
      }
    });
  }
  onSearch(): void {
    this.currentPage.set(1);
    this.loadPosts();
  }
  onFilterChange(): void {
    this.currentPage.set(1);
    this.loadPosts();
  }
  onSortChange(field: string): void {
    if (this.sortBy() === field) {
      this.sortOrder.set(this.sortOrder() === 'asc' ? 'desc' : 'asc');
    } else {
      this.sortBy.set(field);
      this.sortOrder.set('desc');
    }
    this.loadPosts();
  }
  nextPage(): void {
    if (this.hasMore()) {
      this.currentPage.update(p => p + 1);
      this.loadPosts();
    }
  }
  previousPage(): void {
    if (this.hasPrevious()) {
      this.currentPage.update(p => p - 1);
      this.loadPosts();
    }
  }
  goToPage(page: number): void {
    if (page >= 1 && page <= this.totalPages()) {
      this.currentPage.set(page);
      this.loadPosts();
    }
  }
  openLockModal(post: AdminPost): void {
    this.selectedPost.set(post);
    this.lockReason.set('');
    this.showLockModal.set(true);
  }
  closeLockModal(): void {
    this.showLockModal.set(false);
    this.selectedPost.set(null);
    this.lockReason.set('');
  }
  lockPost(): void {
    const post = this.selectedPost();
    if (!post) return;
    this.adminService.lockPost(post.id, this.lockReason()).subscribe({
      next: () => {
        this.closeLockModal();
        this.loadPosts();
      },
      error: (err) => {
        this.error.set(err.error?.detail || 'Failed to lock post');
      }
    });
  }
  unlockPost(post: AdminPost): void {
    if (!confirm(`Unlock post "${post.title}"?`)) return;
    this.adminService.unlockPost(post.id).subscribe({
      next: () => {
        this.loadPosts();
      },
      error: (err) => {
        this.error.set(err.error?.detail || 'Failed to unlock post');
      }
    });
  }
  deletePost(post: AdminPost): void {
    if (!confirm(`Delete post "${post.title}"? This action cannot be undone.`)) return;
    this.adminService.deletePost(post.id).subscribe({
      next: () => {
        this.loadPosts();
      },
      error: (err) => {
        this.error.set(err.error?.detail || 'Failed to delete post');
      }
    });
  }
  restorePost(post: AdminPost): void {
    if (!confirm(`Restore post "${post.title}"?`)) return;
    this.adminService.restorePost(post.id).subscribe({
      next: () => {
        this.loadPosts();
      },
      error: (err) => {
        this.error.set(err.error?.detail || 'Failed to restore post');
      }
    });
  }
  getStatusClass(post: AdminPost): string {
    if (post.is_deleted) return 'status-deleted';
    if (post.is_locked) return 'status-locked';
    return 'status-active';
  }
  getStatusText(post: AdminPost): string {
    if (post.is_deleted) return 'Deleted';
    if (post.is_locked) return 'Locked';
    return 'Active';
  }
  formatDate(dateString: string): string {
    return new Date(dateString).toLocaleDateString('en-US', {
      year: 'numeric',
      month: 'short',
      day: 'numeric',
      hour: '2-digit',
      minute: '2-digit'
    });
  }
}
FILE: src/app/features/admin/admin-users/admin-users.html
<div class="admin-users">
  <div class="admin-header">
    <h1>User Management</h1>
    <p>Manage user accounts, roles, and permissions</p>
  </div>

  <div class="filters-section">
    <input
      type="text"
      placeholder="Search by username or email..."
      [(ngModel)]="searchQuery"
      (keyup.enter)="applyFilters()"
      class="search-input"
    />
    <select [(ngModel)]="roleFilter" (change)="applyFilters()">
      <option value="">All Roles</option>
      <option value="user">User</option>
      <option value="moderator">Moderator</option>
      <option value="admin">Admin</option>
    </select>
    <select [(ngModel)]="statusFilter" (change)="applyFilters()">
      <option value="">All Status</option>
      <option value="active">Active</option>
      <option value="banned">Banned</option>
      <option value="inactive">Inactive</option>
    </select>
    <button class="apply-btn" (click)="applyFilters()">Apply</button>
    <button class="clear-btn" (click)="clearFilters()">Clear</button>
  </div>

  @if (isLoading()) {
    <app-loading-spinner></app-loading-spinner>
  } @else {
    <div class="users-table-container">
      <table class="users-table">
        <thead>
          <tr>
            <th>User</th>
            <th>Email</th>
            <th>Role</th>
            <th>Status</th>
            <th>Joined</th>
            <th>Posts</th>
            <th>Actions</th>
          </tr>
        </thead>
        <tbody>
          @for (user of users(); track user.id) {
            <tr [class.banned]="user.isBanned">
              <td class="user-cell">
                <app-user-avatar
                  [size]="32"
                  [username]="user.username"
                  [imageUrl]="user.avatarUrl ?? ''"
                ></app-user-avatar>
                <span class="username">{{ user.username }}</span>
              </td>
              <td>{{ user.email }}</td>
              <td>
                <span class="role-badge" [class]="getRoleBadgeClass(user.role)">
                  {{ user.role }}
                </span>
              </td>
              <td>
                @if (user.isBanned) {
                  <span class="status-badge banned">Banned</span>
                } @else if (user.isActive) {
                  <span class="status-badge active">Active</span>
                } @else {
                  <span class="status-badge inactive">Inactive</span>
                }
              </td>
              <td>{{ formatDate(user.createdAt) }}</td>
              <td>{{ user.postCount }}</td>
              <td class="actions-cell">
                <button
                  class="action-btn"
                  title="Change Role"
                  (click)="openRoleModal(user)"
                >
                  <span class="material-icons">admin_panel_settings</span>
                </button>
                @if (user.isBanned) {
                  <button
                    class="action-btn success"
                    title="Unban User"
                    (click)="unbanUser(user)"
                  >
                    <span class="material-icons">lock_open</span>
                  </button>
                } @else {
                  <button
                    class="action-btn warning"
                    title="Ban User"
                    (click)="openBanModal(user)"
                  >
                    <span class="material-icons">block</span>
                  </button>
                }
                <button
                  class="action-btn danger"
                  title="Delete User"
                  (click)="deleteUser(user)"
                >
                  <span class="material-icons">delete</span>
                </button>
              </td>
            </tr>
          } @empty {
            <tr>
              <td colspan="7" class="empty-state">
                <span class="material-icons">person_search</span>
                <p>No users found</p>
              </td>
            </tr>
          }
        </tbody>
      </table>
    </div>

    <div class="pagination">
      <button (click)="prevPage()" [disabled]="currentPage() === 1">
        <span class="material-icons">chevron_left</span>
      </button>
      <span class="page-info">Page {{ currentPage() }} of {{ getTotalPages() }}</span>
      <button (click)="nextPage()" [disabled]="currentPage() >= getTotalPages()">
        <span class="material-icons">chevron_right</span>
      </button>
    </div>
  }


  @if (showBanModal()) {
    <div class="modal-overlay" (click)="closeBanModal()">
      <div class="modal-content" (click)="$event.stopPropagation()">
        <div class="modal-header">
          <h2>Ban User</h2>
          <button class="close-btn" (click)="closeBanModal()">
            <span class="material-icons">close</span>
          </button>
        </div>
        <div class="modal-body">
          <p>Are you sure you want to ban <strong>{{ selectedUser()?.username }}</strong>?</p>
          <label for="banReason">Reason (optional):</label>
          <textarea
            id="banReason"
            [(ngModel)]="banReason"
            placeholder="Enter reason for ban..."
            rows="3"
          ></textarea>
        </div>
        <div class="modal-footer">
          <button class="btn-secondary" (click)="closeBanModal()">Cancel</button>
          <button class="btn-danger" (click)="confirmBan()">Ban User</button>
        </div>
      </div>
    </div>
  }


  @if (showRoleModal()) {
    <div class="modal-overlay" (click)="closeRoleModal()">
      <div class="modal-content" (click)="$event.stopPropagation()">
        <div class="modal-header">
          <h2>Change User Role</h2>
          <button class="close-btn" (click)="closeRoleModal()">
            <span class="material-icons">close</span>
          </button>
        </div>
        <div class="modal-body">
          <p>Change role for <strong>{{ selectedUser()?.username }}</strong></p>
          <label for="newRole">New Role:</label>
          <select id="newRole" [(ngModel)]="newRole">
            <option value="user">User</option>
            <option value="moderator">Moderator</option>
            <option value="admin">Admin</option>
          </select>
        </div>
        <div class="modal-footer">
          <button class="btn-secondary" (click)="closeRoleModal()">Cancel</button>
          <button class="btn-primary" (click)="confirmRoleChange()">Save Changes</button>
        </div>
      </div>
    </div>
  }
</div>
FILE: src/app/features/admin/admin-users/admin-users.ts
import { ChangeDetectionStrategy, Component, inject, OnInit, signal } from '@angular/core';
import { CommonModule } from '@angular/common';
import { FormsModule } from '@angular/forms';
import { AdminService } from '../../../core/services/admin';
import { UserListItem, RoleType } from '../../../core/models/admin.model';
import { LoadingSpinner } from '../../../shared/components/loading-spinner/loading-spinner';
import { UserAvatar } from '../../../shared/components/user-avatar/user-avatar';
@Component({
  selector: 'app-admin-users',
  standalone: true,
  imports: [CommonModule, FormsModule, LoadingSpinner, UserAvatar],
  templateUrl: './admin-users.html',
  styleUrls: ['./admin-users.css'],
  changeDetection: ChangeDetectionStrategy.OnPush,
})
export class AdminUsers implements OnInit {
  private readonly adminService = inject(AdminService);
  readonly users = signal<UserListItem[]>([]);
  readonly loading = signal(false);
  readonly total = signal(0);
  readonly currentPage = signal(1);
  readonly pageSize = 20;
  searchQuery = '';
  roleFilter = '';
  statusFilter = '';
  readonly showBanModal = signal(false);
  readonly showRoleModal = signal(false);
  readonly selectedUser = signal<UserListItem | null>(null);
  banReason = '';
  newRole: RoleType = 'user';
  readonly isLoading = this.loading;
  ngOnInit() {
    this.loadUsers();
  }
  loadUsers() {
    this.loading.set(true);
    this.adminService.getUsers({
      page: this.currentPage(),
      pageSize: this.pageSize,
      search: this.searchQuery || undefined,
      role: this.roleFilter || undefined,
      status: this.statusFilter || undefined,
    }).subscribe({
      next: (response) => {
        this.users.set(response.users);
        this.total.set(response.total);
        this.loading.set(false);
      },
      error: (err) => {
        console.error('Failed to load users', err);
        this.loading.set(false);
      },
    });
  }
  applyFilters() {
    this.currentPage.set(1);
    this.loadUsers();
  }
  clearFilters() {
    this.searchQuery = '';
    this.roleFilter = '';
    this.statusFilter = '';
    this.currentPage.set(1);
    this.loadUsers();
  }
  nextPage() {
    const totalPages = Math.ceil(this.total() / this.pageSize);
    if (this.currentPage() < totalPages) {
      this.currentPage.update(p => p + 1);
      this.loadUsers();
    }
  }
  prevPage() {
    if (this.currentPage() > 1) {
      this.currentPage.update(p => p - 1);
      this.loadUsers();
    }
  }
  getTotalPages(): number {
    return Math.ceil(this.total() / this.pageSize) || 1;
  }
  getRoleClass(role: string): string {
    return `role-${role}`;
  }
  getRoleBadgeClass(role: string): string {
    return `role-${role}`;
  }
  formatDate(dateStr: string): string {
    if (!dateStr) return 'N/A';
    return new Date(dateStr).toLocaleDateString();
  }
  openBanModal(user: UserListItem) {
    this.selectedUser.set(user);
    this.banReason = '';
    this.showBanModal.set(true);
  }
  closeBanModal() {
    this.showBanModal.set(false);
    this.selectedUser.set(null);
    this.banReason = '';
  }
  confirmBan() {
    const user = this.selectedUser();
    if (!user) return;
    this.adminService.banUser(user.id, this.banReason).subscribe({
      next: () => {
        this.closeBanModal();
        this.loadUsers();
      },
      error: (err) => {
        console.error('Failed to ban user', err);
        alert('Failed to ban user');
      },
    });
  }
  unbanUser(user: UserListItem) {
    if (!confirm(`Are you sure you want to unban ${user.username}?`)) return;
    this.adminService.unbanUser(user.id).subscribe({
      next: () => this.loadUsers(),
      error: (err) => {
        console.error('Failed to unban user', err);
        alert('Failed to unban user');
      },
    });
  }
  openRoleModal(user: UserListItem) {
    this.selectedUser.set(user);
    this.newRole = user.role;
    this.showRoleModal.set(true);
  }
  closeRoleModal() {
    this.showRoleModal.set(false);
    this.selectedUser.set(null);
  }
  confirmRoleChange() {
    const user = this.selectedUser();
    if (!user) return;
    this.adminService.changeUserRole(user.id, this.newRole).subscribe({
      next: () => {
        this.closeRoleModal();
        this.loadUsers();
      },
      error: (err) => {
        console.error('Failed to change role', err);
        alert('Failed to change user role');
      },
    });
  }
  deleteUser(user: UserListItem) {
    if (!confirm(`Are you sure you want to delete user ${user.username}? This action cannot be undone.`)) return;
    this.adminService.deleteUser(user.id).subscribe({
      next: () => this.loadUsers(),
      error: (err) => {
        console.error('Failed to delete user', err);
        alert('Failed to delete user');
      },
    });
  }
}
FILE: src/app/features/auth/login/login.html
<div class="auth-container">
  <div class="auth-card">
    <div class="auth-header">
      <div class="logo">
        <span class="logo-icon">ğŸ”¥</span>
        <h1>MemeForum</h1>
      </div>
      <p class="auth-subtitle">Welcome back, meme lord!</p>
    </div>

    <form [formGroup]="loginForm" (ngSubmit)="onSubmit()" class="auth-form">
      <div class="form-group">
        <label for="email">Email</label>
        <input
          id="email"
          type="email"
          formControlName="email"
          class="form-input"
          placeholder="your@email.com"
          [class.error]="isFieldInvalid('email')"
        >
        @if (isFieldInvalid('email')) {
          <span class="error-message">Please enter a valid email</span>
        }
      </div>

      <div class="form-group">
        <label for="password">Password</label>
        <div class="password-input-wrapper">
          <input
            id="password"
            [type]="showPassword() ? 'text' : 'password'"
            formControlName="password"
            class="form-input"
            placeholder="â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢"
            [class.error]="isFieldInvalid('password')"
          >
          <button
            type="button"
            class="password-toggle"
            (click)="togglePassword()"
          >
            <span class="material-icons">
              {{ showPassword() ? 'visibility_off' : 'visibility' }}
            </span>
          </button>
        </div>
        @if (isFieldInvalid('password')) {
          <span class="error-message">Password is required</span>
        }
      </div>

      <div class="form-options">
        <label class="checkbox-label">
          <input type="checkbox" formControlName="rememberMe">
          <span>Remember me</span>
        </label>
        <a routerLink="/forgot-password" class="forgot-link">Forgot password?</a>
      </div>

      @if (errorMessage()) {
        <div class="alert alert-error">
          {{ errorMessage() }}
        </div>
      }

      <button
        type="submit"
        class="submit-btn"
        [disabled]="loginForm.invalid || isLoading()"
      >
        @if (isLoading()) {
          <span class="spinner-small"></span>
          <span>Logging in...</span>
        } @else {
          <span>Login</span>
        }
      </button>

      <div class="divider">
        <span>OR</span>
      </div>

      <button type="button" class="oauth-btn google" (click)="loginWithGoogle()">
        <img src="https://www.gstatic.com/firebasejs/ui/2.0.0/images/auth/google.svg" alt="Google">
        <span>Continue with Google</span>
      </button>

      <button type="button" class="oauth-btn github" (click)="loginWithGithub()">
        <span class="material-icons">code</span>
        <span>Continue with GitHub</span>
      </button>
    </form>

    <div class="auth-footer">
      <p>New to MemeForum? <a routerLink="/signup">Create an account</a></p>
    </div>
  </div>
</div>
FILE: src/app/features/auth/login/login.ts
import { ChangeDetectionStrategy, Component, inject, signal } from '@angular/core';
import { FormBuilder, FormGroup, ReactiveFormsModule, Validators } from '@angular/forms';
import { RouterLink } from '@angular/router';
import { Auth } from '../../../core/services/auth';
@Component({
  selector: 'app-login',
  standalone: true,
  imports: [ReactiveFormsModule, RouterLink],
  templateUrl: './login.html',
  styleUrls: ['./login.css'],
  changeDetection: ChangeDetectionStrategy.OnPush,
})
export class Login {
  private readonly fb = inject(FormBuilder);
  private readonly auth = inject(Auth);
  readonly loginForm: FormGroup = this.fb.group({
    email: ['', [Validators.required, Validators.email]],
    password: ['', [Validators.required, Validators.minLength(6)]],
    rememberMe: [false],
  });
  readonly showPassword = signal(false);
  readonly isLoading = signal(false);
  readonly errorMessage = signal('');
  togglePassword() {
    this.showPassword.update((value) => !value);
  }
  isFieldInvalid(field: string) {
    const control = this.loginForm.get(field);
    return !!(control && control.invalid && (control.dirty || control.touched));
  }
  async onSubmit() {
    if (this.loginForm.invalid) {
      Object.keys(this.loginForm.controls).forEach((key) => this.loginForm.get(key)?.markAsTouched());
      return;
    }
    this.isLoading.set(true);
    this.errorMessage.set('');
    try {
      await this.auth.loginWithEmail(
        this.loginForm.get('email')?.value,
        this.loginForm.get('password')?.value,
      );
    } catch (error) {
      console.error('Login failed', error);
      this.errorMessage.set('Invalid credentials or Firebase not configured.');
    } finally {
      this.isLoading.set(false);
    }
  }
  async loginWithGoogle() {
    this.isLoading.set(true);
    this.errorMessage.set('');
    try {
      await this.auth.loginWithGoogle();
    } catch (error) {
      console.error('Google login failed', error);
      this.errorMessage.set('Google login failed.');
    } finally {
      this.isLoading.set(false);
    }
  }
  async loginWithGithub() {
    this.isLoading.set(true);
    this.errorMessage.set('');
    try {
      await this.auth.loginWithGithub();
    } catch (error) {
      console.error('GitHub login failed', error);
      this.errorMessage.set('GitHub login failed.');
    } finally {
      this.isLoading.set(false);
    }
  }
}
FILE: src/app/features/auth/signup/signup.html
<div class="auth-container">
  <div class="auth-card">
    <div class="auth-header">
      <div class="logo">
        <span class="logo-icon">ğŸ”¥</span>
        <h1>MemeForum</h1>
      </div>
      <p class="auth-subtitle">Join the meme revolution!</p>
    </div>

    <form [formGroup]="signupForm" (ngSubmit)="onSubmit()" class="auth-form">
      <div class="form-group">
        <label for="username">Username</label>
        <input
          id="username"
          type="text"
          formControlName="username"
          class="form-input"
          placeholder="memeLord420"
          [class.error]="isFieldInvalid('username')"
        >
        @if (isFieldInvalid('username')) {
          <span class="error-message">Username must be 3-20 characters</span>
        }
      </div>

      <div class="form-group">
        <label for="email">Email</label>
        <input
          id="email"
          type="email"
          formControlName="email"
          class="form-input"
          placeholder="your@email.com"
          [class.error]="isFieldInvalid('email')"
        >
        @if (isFieldInvalid('email')) {
          <span class="error-message">Please enter a valid email</span>
        }
      </div>

      <div class="form-group">
        <label for="password">Password</label>
        <div class="password-input-wrapper">
          <input
            id="password"
            [type]="showPassword() ? 'text' : 'password'"
            formControlName="password"
            class="form-input"
            placeholder="â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢"
            [class.error]="isFieldInvalid('password')"
          >
          <button
            type="button"
            class="password-toggle"
            (click)="togglePassword()"
          >
            <span class="material-icons">
              {{ showPassword() ? 'visibility_off' : 'visibility' }}
            </span>
          </button>
        </div>
        @if (isFieldInvalid('password')) {
          <span class="error-message">Password must be at least 6 characters</span>
        }

        <div class="password-strength">
          <div class="strength-bar">
            <div
              class="strength-fill"
              [style.width.%]="passwordStrength()"
              [class.weak]="passwordStrength() <= 10"
              [class.medium]="passwordStrength() > 10 && passwordStrength() <= 15"
              [class.strong]="passwordStrength() > 18"
            ></div>
          </div>
          <span class="strength-text">{{ getPasswordStrengthText() }}</span>
        </div>
      </div>

      <div class="form-group">
        <label for="confirmPassword">Confirm Password</label>
        <input
          id="confirmPassword"
          [type]="showPassword() ? 'text' : 'password'"
          formControlName="confirmPassword"
          class="form-input"
          placeholder="â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢"
          [class.error]="isFieldInvalid('confirmPassword')"
        >
        @if (isFieldInvalid('confirmPassword')) {
          <span class="error-message">Passwords do not match</span>
        }
      </div>

      <div class="form-options">
        <label class="checkbox-label">
          <input type="checkbox" formControlName="agreeToTerms">
          <span>I agree to the <a href="/terms" target="https://github.com/sunilkumarpradhan">Terms of Service</a></span>
        </label>
      </div>

      @if (errorMessage()) {
        <div class="alert alert-error">
          {{ errorMessage() }}
        </div>
      }

      <button
        type="submit"
        class="submit-btn"
        [disabled]="signupForm.invalid || isLoading()"
      >
        @if (isLoading()) {
          <span class="spinner-small"></span>
          <span>Creating account...</span>
        } @else {
          <span>Sign Up</span>
        }
      </button>

      <div class="divider">
        <span>OR</span>
      </div>

      <button type="button" class="oauth-btn google" (click)="signupWithGoogle()">
        <img src="https://www.gstatic.com/firebasejs/ui/2.0.0/images/auth/google.svg" alt="Google">
        <span>Sign up with Google</span>
      </button>

      <button type="button" class="oauth-btn github" (click)="signupWithGithub()">
        <span class="material-icons">code</span>
        <span>Sign up with GitHub</span>
      </button>
    </form>

    <div class="auth-footer">
      <p>Already have an account? <a routerLink="/login">Login</a></p>
    </div>
  </div>
</div>
FILE: src/app/features/auth/signup/signup.ts
import { ChangeDetectionStrategy, Component, computed, inject, signal } from '@angular/core';
import {
  AbstractControl,
  FormBuilder,
  FormGroup,
  ReactiveFormsModule,
  Validators,
} from '@angular/forms';
import { RouterLink } from '@angular/router';
import { Auth } from '../../../core/services/auth';
@Component({
  selector: 'app-signup',
  standalone: true,
  imports: [ReactiveFormsModule, RouterLink],
  templateUrl: './signup.html',
  styleUrls: ['./signup.css'],
  changeDetection: ChangeDetectionStrategy.OnPush,
})
export class Signup {
  private readonly fb = inject(FormBuilder);
  private readonly auth = inject(Auth);
  readonly showPassword = signal(false);
  readonly isLoading = signal(false);
  readonly errorMessage = signal('');
  readonly signupForm: FormGroup = this.fb.group(
    {
      username: ['', [Validators.required, Validators.minLength(3), Validators.maxLength(20)]],
      email: ['', [Validators.required, Validators.email]],
      password: ['', [Validators.required, Validators.minLength(6)]],
      confirmPassword: ['', [Validators.required]],
      agreeToTerms: [false, [Validators.requiredTrue]],
    },
    { validators: this.passwordMatchValidator },
  );
  readonly passwordStrength = computed(() => {
    const password = this.signupForm.get('password')?.value || '';
    if (!password) return 0;
    let strength = 0;
    if (password.length >= 6) strength += 25;
    if (password.length >= 10) strength += 25;
    if (/[a-z]/.test(password) && /[A-Z]/.test(password)) strength += 25;
    if (/[0-9]/.test(password)) strength += 12.5;
    if (/[^a-zA-Z0-9]/.test(password)) strength += 12.5;
    return Math.min(100, strength);
  });
  passwordMatchValidator(control: AbstractControl) {
    const password = control.get('password');
    const confirmPassword = control.get('confirmPassword');
    if (password?.value !== confirmPassword?.value) {
      confirmPassword?.setErrors({ mismatch: true });
      return { mismatch: true };
    }
    return null;
  }
  togglePassword() {
    this.showPassword.update((value) => !value);
  }
  isFieldInvalid(field: string) {
    const control = this.signupForm.get(field);
    return !!(control && control.invalid && (control.dirty || control.touched));
  }
  getPasswordStrengthText() {
    const strength = this.passwordStrength();
    if (strength <= 33) return 'Weak';
    if (strength <= 66) return 'Medium';
    return 'Strong';
  }
  async onSubmit() {
    if (this.signupForm.invalid) {
      Object.keys(this.signupForm.controls).forEach((key) => this.signupForm.get(key)?.markAsTouched());
      return;
    }
    this.isLoading.set(true);
    this.errorMessage.set('');
    try {
      await this.auth.signupWithEmail(
        this.signupForm.get('username')?.value,
        this.signupForm.get('email')?.value,
        this.signupForm.get('password')?.value,
      );
    } catch (error) {
      console.error('Signup failed', error);
      this.errorMessage.set('Failed to create account. Check Firebase configuration.');
    } finally {
      this.isLoading.set(false);
    }
  }
  async signupWithGoogle() {
    this.isLoading.set(true);
    this.errorMessage.set('');
    try {
      await this.auth.loginWithGoogle();
    } catch (error) {
      console.error('Google signup failed', error);
      this.errorMessage.set('Google signup failed.');
    } finally {
      this.isLoading.set(false);
    }
  }
  async signupWithGithub() {
    this.isLoading.set(true);
    this.errorMessage.set('');
    try {
      await this.auth.loginWithGithub();
    } catch (error) {
      console.error('GitHub signup failed', error);
      this.errorMessage.set('GitHub signup failed.');
    } finally {
      this.isLoading.set(false);
    }
  }
}
FILE: src/app/features/comments/comment-form/comment-form.html
<div class="comment-form-container">
  <div class="comment-form-header">
    <app-user-avatar
      [size]="32"
      [username]="currentUser()"
      [imageUrl]="currentUserAvatar()"
    ></app-user-avatar>
    <span class="comment-as">Comment as <strong>{{ currentUser() }}</strong></span>
  </div>

  <form [formGroup]="commentForm" (ngSubmit)="onSubmit()">
    <div class="comment-editor">
      <textarea
        formControlName="content"
        class="comment-textarea"
        placeholder="What are your thoughts?"
        rows="4"
        [class.focused]="isFocused()"
        (focus)="isFocused.set(true)"
        (blur)="handleBlur()"
      ></textarea>

      @if (isFocused() || commentForm.get('content')?.value) {
        <div class="comment-toolbar">


          <div class="comment-actions" style="margin-left: auto;">
            @if (isReplying()) {
              <button type="button" class="cancel-btn" (click)="cancel()">
                Cancel
              </button>
            }
            <button
              type="submit"
              class="submit-comment-btn"
              [disabled]="commentForm.invalid || isSubmitting()"
            >
              @if (isSubmitting()) {
                <span class="spinner-small"></span>
              }
              {{ isReplying() ? 'Reply' : 'Comment' }}
            </button>
          </div>
        </div>
      }
    </div>
  </form>
</div>
FILE: src/app/features/comments/comment-form/comment-form.ts
import { ChangeDetectionStrategy, Component, inject, input, output, signal, computed } from '@angular/core';
import { FormBuilder, FormGroup, Validators, ReactiveFormsModule } from '@angular/forms';
import { UserAvatar } from '../../../shared/components/user-avatar/user-avatar';
import { Auth } from '../../../core/services/auth';
@Component({
  selector: 'app-comment-form',
  standalone: true,
  imports: [ReactiveFormsModule, UserAvatar],
  templateUrl: './comment-form.html',
  styleUrl: './comment-form.css',
  changeDetection: ChangeDetectionStrategy.OnPush,
})
export class CommentForm {
  private readonly fb = inject(FormBuilder);
  private readonly auth = inject(Auth);
  parentCommentId = input<number | null>(null);
  isReplying = input<boolean>(false);
  readonly submit = output<string>();
  readonly cancelReply = output<void>();
  readonly commentForm: FormGroup = this.fb.group({
    content: ['', [Validators.required, Validators.minLength(1)]],
  });
  readonly isFocused = signal(false);
  readonly isSubmitting = signal(false);
  readonly currentUser = computed(() => this.auth.user()?.username ?? 'You');
  readonly currentUserAvatar = computed(() => this.auth.user()?.avatarUrl ?? '');
  async onSubmit() {
    if (this.commentForm.invalid) return;
    this.isSubmitting.set(true);
    try {
      this.submit.emit(this.commentForm.get('content')?.value);
      this.commentForm.reset();
      this.isFocused.set(false);
    } finally {
      this.isSubmitting.set(false);
    }
  }
  cancel() {
    this.commentForm.reset();
    this.isFocused.set(false);
    this.cancelReply.emit();
  }
  handleBlur() {
    if (!this.commentForm.get('content')?.value) {
      this.isFocused.set(false);
    }
  }
}
FILE: src/app/features/comments/comment-item/comment-item.html
<div class="comment-item" [style.margin-left.px]="depth() * 24">
  @if (depth() > 0) {
    <div class="comment-thread-line"></div>
  }

  <div class="comment-content">
    <div class="comment-header">
      <app-user-avatar
        [username]="comment().authorUsername"
        [imageUrl]="comment().authorAvatar ?? ''"
        [size]="24"
      ></app-user-avatar>
      <a [routerLink]="['/profile', comment().authorUsername]" class="comment-author">
        {{ comment().authorUsername }}
      </a>
      @if (comment().isOp) {
        <span class="op-badge">OP</span>
      }
      <span class="comment-time">{{ formatTime(comment().createdAt) }}</span>
    </div>

    <div class="comment-body">
      {{ comment().content }}
    </div>

    <div class="comment-footer">
      <app-vote-buttons
        [upvotes]="comment().upvotes"
        [downvotes]="comment().downvotes"
        [userVote]="comment().userVote"
        [orientation]="'horizontal'"
        (vote)="onVoteClick($event)"
      ></app-vote-buttons>

      <button class="comment-action" (click)="toggleReply()">
        <span class="material-icons">reply</span>
        <span>Reply</span>
      </button>

      @if (canModerate()) {
        <button class="comment-action" (click)="deleteComment()">
          <span class="material-icons">delete</span>
          <span>Delete</span>
        </button>
      }


    </div>

    @if (showReplyForm()) {
      <div class="reply-form-container">
        <app-comment-form
          [isReplying]="true"
          (submit)="submitReply($event)"
          (cancelReply)="toggleReply()"
        ></app-comment-form>
      </div>
    }

    @if (comment().replies.length > 0) {
      <div class="comment-replies">
        @for (reply of comment().replies; track reply.id) {
          <app-comment-item
            [comment]="reply"
            [depth]="depth() + 1"
            (reply)="onNestedReply($event)"
            (vote)="onNestedVote($event)"
            (delete)="onNestedDelete($event)"
          ></app-comment-item>
        }
      </div>
    }
  </div>
</div>
FILE: src/app/features/comments/comment-item/comment-item.ts
import { ChangeDetectionStrategy, Component, input, output, signal } from '@angular/core';
import { RouterLink } from '@angular/router';
import { Comment } from '../../../core/models/comment.model';
import { UserAvatar } from '../../../shared/components/user-avatar/user-avatar';
import { VoteButtons } from '../../../shared/components/vote-buttons/vote-buttons';
import { CommentForm } from '../comment-form/comment-form';
@Component({
  selector: 'app-comment-item',
  standalone: true,
  imports: [RouterLink, UserAvatar, VoteButtons, CommentForm],
  templateUrl: './comment-item.html',
  styleUrls: ['./comment-item.css'],
  changeDetection: ChangeDetectionStrategy.OnPush,
})
export class CommentItem {
  comment = input.required<Comment>();
  depth = input<number>(0);
  readonly reply = output<{ commentId: number; content: string }>();
  readonly vote = output<{ commentId: number; voteType: 'up' | 'down' }>();
  readonly delete = output<number>();
  readonly showReplyForm = signal(false);
  toggleReply() {
    this.showReplyForm.update((value) => !value);
  }
  submitReply(content: string) {
    this.reply.emit({ commentId: this.comment().id, content });
    this.showReplyForm.set(false);
  }
  onVoteClick(voteType: 'up' | 'down') {
    this.vote.emit({ commentId: this.comment().id, voteType });
  }
  onNestedReply(event: { commentId: number; content: string }) {
    this.reply.emit(event);
  }
  onNestedVote(event: { commentId: number; voteType: 'up' | 'down' }) {
    this.vote.emit(event);
  }
  onNestedDelete(commentId: number) {
    this.delete.emit(commentId);
  }
  deleteComment() {
    this.delete.emit(this.comment().id);
  }
  canModerate(): boolean {
    return false;
  }
  reportComment() {
    console.log('Report comment', this.comment().id);
  }
  formatTime(isoDate: string): string {
    const date = new Date(isoDate);
    const diffSeconds = (Date.now() - date.getTime()) / 1000;
    if (diffSeconds < 60) return 'Just now';
    if (diffSeconds < 3600) return `${Math.floor(diffSeconds / 60)}m ago`;
    if (diffSeconds < 86400) return `${Math.floor(diffSeconds / 3600)}h ago`;
    return `${Math.floor(diffSeconds / 86400)}d ago`;
  }
}
FILE: src/app/features/comments/comment-thread/comment-thread.html
<div class="comment-thread">
  @for (comment of comments(); track comment.id) {
    <app-comment-item
      [comment]="comment"
      [depth]="0"
      (reply)="handleReply($event)"
      (vote)="handleVote($event)"
      (delete)="handleDelete($event)"
    ></app-comment-item>
  } @empty {
    <div class="no-comments">
      <span class="material-icons">chat_bubble_outline</span>
      <p>No comments yet. Be the first to share your thoughts!</p>
    </div>
  }
</div>
FILE: src/app/features/comments/comment-thread/comment-thread.ts
import { ChangeDetectionStrategy, Component, input, output } from '@angular/core';
import { CommentItem } from '../comment-item/comment-item';
import { Comment } from '../../../core/models/comment.model';
@Component({
  selector: 'app-comment-thread',
  standalone: true,
  imports: [CommentItem],
  templateUrl: './comment-thread.html',
  styleUrl: './comment-thread.css',
  changeDetection: ChangeDetectionStrategy.OnPush,
})
export class CommentThread {
  comments = input.required<Comment[]>();
  readonly reply = output<{ commentId: number; content: string }>();
  readonly vote = output<{ commentId: number; voteType: 'up' | 'down' }>();
  readonly delete = output<number>();
  handleReply(event: { commentId: number; content: string }) {
    this.reply.emit(event);
  }
  handleVote(event: { commentId: number; voteType: 'up' | 'down' }) {
    this.vote.emit(event);
  }
  handleDelete(commentId: number) {
    this.delete.emit(commentId);
  }
}
FILE: src/app/features/comments/services/comment.ts
import { inject, Injectable } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { environment } from '../../../core/config/environment';
import { map } from 'rxjs';
import { Comment } from '../../../core/models/comment.model';
import { Observable } from 'rxjs';
interface CommentDto {
  id: number;
  post_id: number;
  user_id: number;
  parent_id: number | null;
  content: string;
  upvotes: number;
  downvotes: number;
  is_deleted: boolean;
  created_at: string;
  updated_at: string | null;
  author_username: string;
  author_avatar: string | null;
  user_vote: 'up' | 'down' | null;
  replies: CommentDto[];
}
interface CommentTreeDto {
  comments: CommentDto[];
  total: number;
}
@Injectable({ providedIn: 'root' })
export class CommentService {
  private readonly http = inject(HttpClient);
  vote(commentId: number, voteType: 'up' | 'down'): Observable<any> {
    return this.http.post(`${environment.apiUrl}/comments/${commentId}/vote`, {
      vote_type: voteType,
    });
  }
  removeVote(commentId: number): Observable<any> {
    return this.http.delete(`${environment.apiUrl}/comments/${commentId}/vote`);
  }
  delete(commentId: number): Observable<any> {
    return this.http.delete(`${environment.apiUrl}/comments/${commentId}`);
  }
  getTree(postId: number | string) {
    return this.http
      .get<CommentTreeDto>(`${environment.apiUrl}/comments/post/${postId}`)
      .pipe(map((dto) => dto.comments.map((comment) => this.mapComment(comment))));
  }
  create(postId: number | string, content: string, parentId?: number) {
    return this.http
      .post<CommentDto>(`${environment.apiUrl}/comments`, {
        post_id: Number(postId),
        content,
        parent_id: parentId ?? null,
      })
      .pipe(map((dto) => this.mapComment(dto)));
  }
  private mapComment(dto: CommentDto): Comment {
    return {
      id: dto.id,
      postId: dto.post_id,
      userId: dto.user_id,
      parentId: dto.parent_id,
      content: dto.content,
      upvotes: dto.upvotes,
      downvotes: dto.downvotes,
      isDeleted: dto.is_deleted,
      createdAt: dto.created_at,
      updatedAt: dto.updated_at,
      authorUsername: dto.author_username,
      authorAvatar: dto.author_avatar,
      userVote: dto.user_vote,
      replies: dto.replies?.map((reply) => this.mapComment(reply)) ?? [],
    };
  }
}
FILE: src/app/features/notifications/notification-bell/notification-bell.html
<div class="notification-bell-container">
  <button
    class="notification-bell"
    (click)="toggleNotifications()"
    [attr.aria-label]="'Notifications'"
  >
    <span class="material-icons">{{ unreadCount() > 0 ? 'notifications_active' : 'notifications' }}</span>
    @if (unreadCount() > 0) {
      <span class="notification-badge">{{ formatCount(unreadCount()) }}</span>
    }
  </button>

  @if (isOpen()) {
    <div class="notification-dropdown">
      <div class="notification-header">
        <h3>Notifications</h3>
        @if (unreadCount() > 0) {
          <button class="mark-all-read" (click)="markAllAsRead()">
            Mark all as read
          </button>
        }
      </div>

      <div class="notification-list">
        @if (notifications().length > 0) {
          @for (notification of notifications(); track notification.id) {
            <app-notification-item
              [notification]="notification"
              (click)="handleNotificationClick(notification)"
            ></app-notification-item>
          }
        } @else {
          <div class="empty-notifications">
            <span class="material-icons">notifications_none</span>
            <p>No notifications yet</p>
          </div>
        }
      </div>

      <div class="notification-footer">
        <a routerLink="/notifications" class="view-all" (click)="close()">View all notifications</a>
      </div>
    </div>
  }
</div>
FILE: src/app/features/notifications/notification-bell/notification-bell.ts
import { ChangeDetectionStrategy, Component, computed, inject, signal } from '@angular/core';
import { CommonModule } from '@angular/common';
import { RouterLink } from '@angular/router';
import { NotificationItem } from '../notification-item/notification-item';
import { NotificationService } from '../../../core/services/notification';
@Component({
  selector: 'app-notification-bell',
  standalone: true,
  imports: [CommonModule, RouterLink, NotificationItem],
  templateUrl: './notification-bell.html',
  styleUrl: './notification-bell.css',
  changeDetection: ChangeDetectionStrategy.OnPush,
})
export class NotificationBell {
  private readonly notificationService = inject(NotificationService);
  readonly isOpen = signal(false);
  readonly notifications = computed(() => this.notificationService.notifications());
  readonly unreadCount = computed(() => this.notificationService.unreadCount());
  toggleNotifications() {
    this.isOpen.update((open) => !open);
  }
  close() {
    this.isOpen.set(false);
  }
  async markAllAsRead() {
    await this.notificationService.markAllAsRead();
  }
  async handleNotificationClick(notification: { id: number; isRead: boolean; link?: string | null }) {
    if (!notification.isRead) {
      await this.notificationService.markAsRead(notification.id);
    }
    if (notification.link) {
      this.close();
    }
  }
  formatCount(count: number): string {
    return count > 99 ? '99+' : count.toString();
  }
}
FILE: src/app/features/notifications/notification-item/notification-item.html
<div class="notification-item" [class.unread]="!notification().read" (click)="handleClick()">
  <div class="notification-icon">
    @switch (notification().type) {
      @case ('comment') {
        <span class="material-icons">comment</span>
      }
      @case ('upvote') {
        <span class="material-icons">thumb_up</span>
      }
      @case ('mention') {
        <span class="material-icons">alternate_email</span>
      }
      @case ('post') {
        <span class="material-icons">article</span>
      }
      @default {
        <span class="material-icons">notifications</span>
      }
    }
  </div>

  <div class="notification-content">
    <p class="notification-message">{{ notification().message }}</p>
    <span class="notification-time">{{ formatTime(notification().createdAt) }}</span>
  </div>

  @if (!notification().read) {
    <span class="unread-indicator"></span>
  }
</div>
FILE: src/app/features/notifications/notification-item/notification-item.ts
import { Component, input, output } from '@angular/core';
import { CommonModule } from '@angular/common';
@Component({
  selector: 'app-notification-item',
  standalone: true,
  imports: [CommonModule],
  templateUrl: './notification-item.html',
  styleUrl: './notification-item.css'
})
export class NotificationItem {
  notification = input.required<any>();
  click = output<any>();
  handleClick() {
    this.click.emit(this.notification());
  }
  formatTime(date: Date): string {
    const now = new Date();
    const diff = now.getTime() - new Date(date).getTime();
    const seconds = Math.floor(diff / 1000);
    const minutes = Math.floor(seconds / 60);
    const hours = Math.floor(minutes / 60);
    const days = Math.floor(hours / 24);
    if (days > 0) return `${days}d ago`;
    if (hours > 0) return `${hours}h ago`;
    if (minutes > 0) return `${minutes}m ago`;
    return 'Just now';
  }
}
FILE: src/app/features/notifications/notification-list/notification-list.html
<section>
  <header>
    <h2>Notifications</h2>
    <p>{{ unreadCount() }} unread</p>
  </header>

  <div>
    @if (notifications().length === 0) {
      <p>No notifications yet.</p>
    } @else {
      @for (notification of notifications(); track notification.id) {
        <app-notification-item
          [notification]="notification"
        ></app-notification-item>
      }
    }
  </div>
</section>
FILE: src/app/features/notifications/notification-list/notification-list.ts
import { ChangeDetectionStrategy, Component, computed, inject } from '@angular/core';
import { CommonModule } from '@angular/common';
import { NotificationService } from '../../../core/services/notification';
import { NotificationItem } from '../notification-item/notification-item';
@Component({
  selector: 'app-notification-list',
  standalone: true,
  imports: [CommonModule, NotificationItem],
  templateUrl: './notification-list.html',
  styleUrl: './notification-list.css',
  changeDetection: ChangeDetectionStrategy.OnPush,
})
export class NotificationList {
  private readonly notificationService = inject(NotificationService);
  readonly notifications = computed(() => this.notificationService.notifications());
  readonly unreadCount = computed(() => this.notificationService.unreadCount());
}
FILE: src/app/features/posts/post-card/post-card.html
<article class="post-card" (click)="navigateToPost()">
  <div class="post-votes">
    <app-vote-buttons
      [upvotes]="currentUpvotes()"
      [downvotes]="currentDownvotes()"
      [userVote]="currentUserVote()"
      [disabled]="isVotePending()"
      (vote)="handleVote($event)"
    ></app-vote-buttons>
  </div>

  <div class="post-content">
    <div class="post-header">
      <app-user-avatar
        [size]="20"
        [username]="post().authorUsername"
        [imageUrl]="post().authorAvatar ?? ''"
      ></app-user-avatar>
      <span class="post-author">{{ post().authorUsername }}</span>
      <span class="post-separator">â€¢</span>
      <span class="post-time">{{ formatTime(post().createdAt) }}</span>
      @if (post().tag) {
        <span class="post-tag">#{{ post().tag }}</span>
      }
    </div>

    <h2 class="post-title">{{ post().title }}</h2>

    @if (post().imageUrl) {
      <div class="post-image-container">
        <img [src]="post().imageUrl" [alt]="post().title" class="post-image" />
      </div>
    }

    @if (post().description) {
      <p class="post-description">{{ post().description }}</p>
    }

    <div class="post-footer">
      <button class="post-action" (click)="openComments($event)">
        <span class="material-icons">comment</span>
        <span>{{ post().commentCount }} Comments</span>
      </button>

      <button class="post-action" (click)="share($event)">
        <span class="material-icons">share</span>
        <span>Share</span>
      </button>

      <button class="post-action" (click)="toggleFavorite($event)">
        <span class="material-icons">{{ isFavorite() ? 'bookmark' : 'bookmark_border' }}</span>
        <span>Save</span>
      </button>


    </div>
  </div>
</article>
FILE: src/app/features/posts/post-card/post-card.ts
import { ChangeDetectionStrategy, Component, inject, input, signal, effect, computed } from '@angular/core';
import { CommonModule } from '@angular/common';
import { Router } from '@angular/router';
import { VoteButtons } from '../../../shared/components/vote-buttons/vote-buttons';
import { UserAvatar } from '../../../shared/components/user-avatar/user-avatar';
import { Post } from '../../../core/models/post.model';
import { PostService } from '../services/post';
import { FavoriteState } from '../../../core/services/favorite';
import { VoteState } from '../../../core/services/vote-state';
@Component({
  selector: 'app-post-card',
  standalone: true,
  imports: [CommonModule, VoteButtons, UserAvatar],
  templateUrl: './post-card.html',
  styleUrls: ['./post-card.css'],
  changeDetection: ChangeDetectionStrategy.OnPush,
})
export class PostCard {
  private readonly router = inject(Router);
  private readonly postService = inject(PostService);
  private readonly favoriteState = inject(FavoriteState);
  private readonly voteState = inject(VoteState);
  post = input.required<Post>();
  isFavorite = signal(false);
  readonly currentUpvotes = computed(() => {
    const voteCache = this.voteState.getPostVote(this.post().id);
    return voteCache?.upvotes ?? this.post().upvotes;
  });
  readonly currentDownvotes = computed(() => {
    const voteCache = this.voteState.getPostVote(this.post().id);
    return voteCache?.downvotes ?? this.post().downvotes;
  });
  readonly currentUserVote = computed(() => {
    const voteCache = this.voteState.getPostVote(this.post().id);
    return voteCache?.userVote ?? this.post().userVote;
  });
  readonly isVotePending = computed(() => {
    return this.voteState.isPending('post', this.post().id);
  });
  constructor() {
    effect(() => {
      this.isFavorite.set(this.post().isFavorited);
    }, { allowSignalWrites: true });
  }
  navigateToPost() {
    this.router.navigate(['/post', this.post().id]);
  }
  handleVote(vote: 'up' | 'down') {
    if (this.isVotePending()) return;
    const currentVote = this.currentUserVote();
    if (currentVote === vote) {
      this.postService.removeVote(this.post().id, currentVote).subscribe({
        error: (err) => {
          console.error('Failed to remove vote', err);
          this.voteState.optimisticVote('post', this.post().id, currentVote, null);
        },
      });
    } else {
      this.postService.vote(this.post().id, vote, currentVote).subscribe({
        error: (err) => {
          console.error('Failed to vote', err);
          this.voteState.optimisticVote('post', this.post().id, currentVote, vote);
        },
      });
    }
  }
  openComments(event: Event) {
    event.stopPropagation();
    this.navigateToPost();
  }
  share(event: Event) {
    event.stopPropagation();
    if (navigator.share) {
      navigator.share({
        title: this.post().title,
        text: this.post().description ?? '',
        url: `${window.location.origin}/post/${this.post().id}`,
      }).catch(() => {});
    } else {
      navigator.clipboard.writeText(`${window.location.origin}/post/${this.post().id}`);
      alert('Link copied to clipboard!');
    }
  }
  toggleFavorite(event: Event) {
    event.stopPropagation();
    const currentPost = this.post();
    const currentFavoriteState = this.isFavorite();
    if (currentFavoriteState) {
      this.postService.unfavorite(currentPost.id).subscribe({
        next: () => {
          this.isFavorite.set(false);
          currentPost.isFavorited = false;
          this.favoriteState.notifyChange();
          console.log('Post unfavorited successfully');
        },
        error: (err) => {
          console.error('Failed to unfavorite', err);
          alert('Failed to remove bookmark. Please try again.');
        },
      });
    } else {
      this.postService.favorite(currentPost.id).subscribe({
        next: () => {
          this.isFavorite.set(true);
          currentPost.isFavorited = true;
          this.favoriteState.notifyChange();
          console.log('Post favorited successfully');
        },
        error: (err) => {
          console.error('Failed to favorite', err);
          alert('Failed to bookmark. Please try again.');
        },
      });
    }
  }
  formatTime(isoDate: string) {
    const date = new Date(isoDate);
    const diff = (Date.now() - date.getTime()) / 1000;
    if (diff < 60) return 'Just now';
    if (diff < 3600) return `${Math.floor(diff / 60)}m ago`;
    if (diff < 86400) return `${Math.floor(diff / 3600)}h ago`;
    return `${Math.floor(diff / 86400)}d ago`;
  }
}
FILE: src/app/features/posts/post-create/post-create.html
<div class="create-post-container">
  <div class="create-post-header">
    <h1>Create a Post</h1>
    <button class="close-btn" routerLink="/feed">
      <span class="material-icons">close</span>
    </button>
  </div>

  <form [formGroup]="postForm" (ngSubmit)="onSubmit()" class="post-form">
    <div class="form-group">
      <label for="title">Title *</label>
      <input
        id="title"
        type="text"
        formControlName="title"
        class="form-input"
        placeholder="An interesting title..."
        [class.error]="isFieldInvalid('title')"
      >
      <span class="char-count">{{ titleLength() }}/300</span>
      @if (isFieldInvalid('title')) {
        <span class="error-message">Title is required (min 3 characters)</span>
      }
    </div>

    <div class="form-group">
      <label for="tag">Tag</label>
      <select id="tag" formControlName="tag" class="form-select">
        <option value="">Select a tag (optional)</option>
        @for (category of tags(); track category.id) {
          <option [value]="category.slug">
            {{ category.emoji }} {{ category.name }}
          </option>
        }
      </select>
    </div>

    <div class="form-group">
      <label for="image">Image</label>
      <div class="image-upload-area"
           [class.has-image]="imagePreview()"
           (click)="fileInput.click()"
           (drop)="onDrop($event)"
           (dragover)="onDragOver($event)"
           (dragleave)="onDragLeave($event)"
           [class.drag-over]="isDragging()">

        @if (imagePreview()) {
          <img [src]="imagePreview()" alt="Preview" class="image-preview">
          <button type="button" class="remove-image" (click)="removeImage($event)">
            <span class="material-icons">close</span>
          </button>
        } @else {
          <div class="upload-placeholder">
            <span class="material-icons">image</span>
            <p>Click or drag image here</p>
            <span class="upload-hint">PNG, JPG, GIF up to 10MB</span>
          </div>
        }

        <input
          #fileInput
          type="file"
          accept="image/*"
          (change)="onFileSelected($event)"
          style="display: none"
        >
      </div>
    </div>

    <div class="form-group">
      <label for="description">Description</label>
      <textarea
        id="description"
        formControlName="description"
        class="form-textarea"
        placeholder="Add some context... (optional)"
        rows="4"
      ></textarea>
      <span class="char-count">{{ descriptionLength() }}/1000</span>
    </div>

    <div class="form-actions">
      <button type="button" class="cancel-btn" routerLink="/feed">
        Cancel
      </button>
      <button
        type="submit"
        class="submit-btn"
        [disabled]="postForm.invalid || isSubmitting()"
      >
        @if (isSubmitting()) {
          <span class="spinner-small"></span>
          <span>Posting...</span>
        } @else {
          <span>Post</span>
        }
      </button>
    </div>
  </form>
</div>
FILE: src/app/features/posts/post-create/post-create.ts
import { ChangeDetectionStrategy, Component, computed, inject, signal } from '@angular/core';
import { FormBuilder, FormGroup, ReactiveFormsModule, Validators } from '@angular/forms';
import { Router, RouterLink } from '@angular/router';
import { PostService } from '../services/post';
import { CATEGORIES } from '../../../core/constants/categories';
@Component({
  selector: 'app-post-create',
  standalone: true,
  imports: [ReactiveFormsModule, RouterLink],
  templateUrl: './post-create.html',
  styleUrls: ['./post-create.css'],
  changeDetection: ChangeDetectionStrategy.OnPush,
})
export class PostCreate {
  private readonly fb = inject(FormBuilder);
  private readonly router = inject(Router);
  private readonly postService = inject(PostService);
  readonly tags = signal(CATEGORIES);
  readonly imagePreview = signal<string | null>(null);
  readonly isDragging = signal(false);
  readonly isSubmitting = signal(false);
  readonly postForm: FormGroup = this.fb.group({
    title: ['', [Validators.required, Validators.minLength(3), Validators.maxLength(300)]],
    tag: [''],
    description: ['', [Validators.maxLength(1000)]],
  });
  readonly titleLength = computed(() => this.postForm.get('title')?.value?.length ?? 0);
  readonly descriptionLength = computed(() => this.postForm.get('description')?.value?.length ?? 0);
  isFieldInvalid(field: string) {
    const control = this.postForm.get(field);
    return !!(control && control.invalid && (control.dirty || control.touched));
  }
  onFileSelected(event: Event) {
    const input = event.target as HTMLInputElement;
    if (!input.files?.length) return;
    this.readFile(input.files[0]);
  }
  onDrop(event: DragEvent) {
    event.preventDefault();
    this.isDragging.set(false);
    if (!event.dataTransfer?.files?.length) return;
    this.readFile(event.dataTransfer.files[0]);
  }
  onDragOver(event: DragEvent) {
    event.preventDefault();
    this.isDragging.set(true);
  }
  onDragLeave(event: DragEvent) {
    event.preventDefault();
    this.isDragging.set(false);
  }
  removeImage(event: Event) {
    event.stopPropagation();
    this.imagePreview.set(null);
  }
  private readFile(file: File) {
    if (!file.type.startsWith('image/')) {
      alert('Please select an image file');
      return;
    }
    if (file.size > 10 * 1024 * 1024) {
      alert('Images must be â‰¤10MB');
      return;
    }
    const reader = new FileReader();
    reader.onload = (e) => this.imagePreview.set(e.target?.result as string);
    reader.readAsDataURL(file);
  }
  async onSubmit() {
    if (this.postForm.invalid) {
      Object.keys(this.postForm.controls).forEach((key) => this.postForm.get(key)?.markAsTouched());
      return;
    }
    this.isSubmitting.set(true);
    try {
      const post = await this.postService
        .create({
          title: this.postForm.get('title')?.value,
          description: this.postForm.get('description')?.value || null,
          tag: this.postForm.get('tag')?.value || null,
          imageUrl: this.imagePreview(),
        })
        .toPromise();
      await this.router.navigate(['/post', post?.id ?? '']);
    } catch (error) {
      console.error('Failed to create post', error);
      alert('Failed to create post. Try again.');
    } finally {
      this.isSubmitting.set(false);
    }
  }
}
FILE: src/app/features/posts/post-detail/post-detail.html
<div class="post-detail-container">
  @if (isLoading()) {
    <app-loading-spinner></app-loading-spinner>
  } @else if (post(); as post) {
    <article class="post-detail">
      <div class="post-detail-header">
        <div class="post-meta">
          <app-user-avatar
            [username]="post.authorUsername"
            [imageUrl]="post.authorAvatar ?? ''"
            [size]="40"
          ></app-user-avatar>

          <div class="post-meta-info">
            <a
              [routerLink]="['/profile', post.authorUsername]"
              class="post-author"
            >
              {{ post.authorUsername }}
            </a>
            <span class="post-time">{{ formatTime(post.createdAt) }}</span>
          </div>
        </div>


        @if (canModerate()) {
          <div class="post-actions">
            <button class="action-btn danger" (click)="deletePost()">
              <span class="material-icons">delete</span>
            </button>
          </div>
        }
      </div>

      <h1 class="post-detail-title">{{ post.title }}</h1>

      @if (post.tag) {
        <span class="post-detail-tag">{{ post.tag }}</span>
      }

      @if (post.imageUrl) {
        <div class="post-detail-image">
          <img [src]="post.imageUrl" [alt]="post.title" />
        </div>
      }

      @if (post.description) {
        <div class="post-detail-description">{{ post.description }}</div>
      }

      <div class="post-detail-footer">
        <app-vote-buttons
          [upvotes]="post.upvotes"
          [downvotes]="post.downvotes"
          [userVote]="post.userVote"
          orientation="horizontal"
          (vote)="handlePostVote($event)"
        ></app-vote-buttons>

        <button class="post-detail-action" (click)="share()">
          <span class="material-icons">share</span>
          <span>Share</span>
        </button>

        <button class="post-detail-action" (click)="toggleFavorite()">
          <span class="material-icons">
            {{ isFavorite() ? 'bookmark' : 'bookmark_border' }}
          </span>
          <span>Save</span>
        </button>
      </div>
    </article>

    <section class="comments-section">
      <div class="comments-header">
        <h2>Comments ({{ post.commentCount }})</h2>
        <select
          class="comment-sort"
          [ngModel]="commentSort()"
          (ngModelChange)="changeCommentSort($event)"
        >
          <option value="best">Best</option>
          <option value="new">New</option>
          <option value="top">Top</option>
        </select>
      </div>

      @if (isAuthenticated()) {
        <app-comment-form (submit)="addComment($event)"></app-comment-form>
      } @else {
        <div class="login-prompt">
          <p>
            Please <a routerLink="/login">login</a> to comment
          </p>
        </div>
      }

      <div class="comments-list">
        <app-comment-thread
          [comments]="comments()"
          (reply)="handleCommentReply($event)"
          (vote)="handleCommentVote($event)"
          (delete)="handleCommentDelete($event)"
        ></app-comment-thread>
      </div>
    </section>
  } @else {
    <div class="error-state">
      <span class="material-icons">error_outline</span>
      <h2>Post not found</h2>
      <p>
        This post may have been deleted or you don't have permission to view it.
      </p>
      <button routerLink="/feed" class="back-btn">Back to Feed</button>
    </div>
  }
</div>
FILE: src/app/features/posts/post-detail/post-detail.ts
import { ChangeDetectionStrategy, Component, DestroyRef, OnInit, inject, signal, computed } from '@angular/core';
import { ActivatedRoute, Router, RouterLink } from '@angular/router';
import { takeUntilDestroyed } from '@angular/core/rxjs-interop';
import { CommonModule } from '@angular/common';
import { FormsModule } from '@angular/forms';
import { VoteButtons } from '../../../shared/components/vote-buttons/vote-buttons';
import { UserAvatar } from '../../../shared/components/user-avatar/user-avatar';
import { CommentForm } from '../../comments/comment-form/comment-form';
import { CommentThread } from '../../comments/comment-thread/comment-thread';
import { LoadingSpinner } from '../../../shared/components/loading-spinner/loading-spinner';
import { PostService } from '../services/post';
import { CommentService } from '../../comments/services/comment';
import { Post } from '../../../core/models/post.model';
import { Comment } from '../../../core/models/comment.model';
import { Auth } from '../../../core/services/auth';
import { FavoriteState } from '../../../core/services/favorite';
@Component({
  selector: 'app-post-detail',
  standalone: true,
  imports: [
    CommonModule,
    FormsModule,
    RouterLink,
    VoteButtons,
    UserAvatar,
    CommentForm,
    CommentThread,
    LoadingSpinner,
  ],
  templateUrl: './post-detail.html',
  styleUrl: './post-detail.css',
  changeDetection: ChangeDetectionStrategy.OnPush,
})
export class PostDetail implements OnInit {
  private readonly route = inject(ActivatedRoute);
  private readonly router = inject(Router);
  private readonly postService = inject(PostService);
  private readonly commentService = inject(CommentService);
  private readonly destroyRef = inject(DestroyRef);
  private readonly auth = inject(Auth);
  private readonly favoriteState = inject(FavoriteState);
  readonly post = signal<Post | null>(null);
  readonly comments = signal<Comment[]>([]);
  readonly isLoading = signal(true);
  readonly isFavorite = signal(false);
  readonly commentSort = signal<'best' | 'new' | 'top'>('best');
  readonly isAuthenticated = this.auth.isAuthenticated;
  readonly canModerate = computed(() => {
    const currentUser = this.auth.user();
    const postData = this.post();
    if (!currentUser || !postData) return false;
    return currentUser.id === postData.userId || currentUser.role === 'admin';
  });
  ngOnInit() {
    const postId = Number(this.route.snapshot.paramMap.get('id'));
    this.loadPost(postId);
    this.loadComments(postId);
  }
  private loadPost(id: number) {
    this.postService
      .getOne(id)
      .pipe(takeUntilDestroyed(this.destroyRef))
      .subscribe({
        next: (post) => {
          this.post.set(post);
          this.isFavorite.set(post.isFavorited);
          this.isLoading.set(false);
        },
        error: (error) => {
          console.error('Failed to load post', error);
          this.post.set(null);
          this.isLoading.set(false);
        },
      });
  }
  private loadComments(postId: number) {
    this.commentService
      .getTree(postId)
      .pipe(takeUntilDestroyed(this.destroyRef))
      .subscribe({
        next: (comments) => {
          const commentsWithOp = comments.map(comment =>
            this.markOp(comment, this.post()?.userId ?? 0)
          );
          this.comments.set(commentsWithOp);
        },
        error: (error) => {
          console.error('Failed to load comments', error);
          this.comments.set([]);
        },
      });
  }
  private markOp(comment: Comment, opUserId: number): Comment {
    return {
      ...comment,
      isOp: comment.userId === opUserId,
      replies: comment.replies.map(reply => this.markOp(reply, opUserId)),
    };
  }
  handlePostVote(vote: 'up' | 'down') {
  const currentPost = this.post();
  if (!currentPost) return;
  const currentVote = currentPost.userVote;
  if (currentVote === vote) {
    this.postService.removeVote(currentPost.id, currentVote).subscribe({
      next: () => this.loadPost(currentPost.id),
      error: (err) => console.error('Failed to remove vote', err),
    });
  } else {
    this.postService.vote(currentPost.id, vote, currentVote).subscribe({
      next: () => this.loadPost(currentPost.id),
      error: (err) => console.error('Failed to vote', err),
    });
  }
}
  toggleFavorite() {
    const currentPost = this.post();
    if (!currentPost) return;
    const currentFavoriteState = this.isFavorite();
    if (currentFavoriteState) {
      this.postService.unfavorite(currentPost.id).subscribe({
        next: () => {
          this.isFavorite.set(false);
          if (currentPost) currentPost.isFavorited = false;
          this.favoriteState.notifyChange();
        },
        error: (err) => {
          console.error('Failed to unfavorite', err);
          alert('Failed to remove bookmark. Please try again.');
        },
      });
    } else {
      this.postService.favorite(currentPost.id).subscribe({
        next: () => {
          this.isFavorite.set(true);
          if (currentPost) currentPost.isFavorited = true;
          this.favoriteState.notifyChange();
        },
        error: (err) => {
          console.error('Failed to favorite', err);
          alert('Failed to bookmark. Please try again.');
        },
      });
    }
  }
  share() {
    const currentPost = this.post();
    if (!currentPost) return;
    if (navigator.share) {
      navigator.share({
        title: currentPost.title,
        text: currentPost.description ?? '',
        url: window.location.href,
      }).catch(() => {});
    } else {
      navigator.clipboard.writeText(window.location.href);
      alert('Link copied to clipboard!');
    }
  }
  addComment(content: string) {
    const currentPost = this.post();
    if (!currentPost) return;
    this.commentService.create(currentPost.id, content).subscribe({
      next: () => {
        this.loadComments(currentPost.id);
        currentPost.commentCount++;
      },
      error: (err) => console.error('Failed to add comment', err),
    });
  }
  handleCommentReply(event: { commentId: number; content: string }) {
    const currentPost = this.post();
    if (!currentPost) return;
    this.commentService
      .create(currentPost.id, event.content, event.commentId)
      .subscribe({
        next: () => {
          this.loadComments(currentPost.id);
          currentPost.commentCount++;
        },
        error: (err) => console.error('Failed to reply to comment', err),
      });
  }
  handleCommentVote(event: { commentId: number; voteType: 'up' | 'down' }) {
    this.commentService.vote(event.commentId, event.voteType).subscribe({
      next: () => {
        const currentPost = this.post();
        if (currentPost) {
          this.loadComments(currentPost.id);
        }
      },
      error: (err) => console.error('Failed to vote on comment', err),
    });
  }
  handleCommentDelete(commentId: number) {
    if (!confirm('Are you sure you want to delete this comment?')) return;
    this.commentService.delete(commentId).subscribe({
      next: () => {
        const currentPost = this.post();
        if (currentPost) {
          this.loadComments(currentPost.id);
          currentPost.commentCount--;
        }
      },
      error: (err) => console.error('Failed to delete comment', err),
    });
  }
  changeCommentSort(sortBy: 'best' | 'new' | 'top') {
    this.commentSort.set(sortBy);
    const currentPost = this.post();
    if (currentPost) {
      this.loadComments(currentPost.id);
    }
  }
  deletePost() {
    const currentPost = this.post();
    if (!currentPost) return;
    if (!confirm('Are you sure you want to delete this post? This action cannot be undone.')) {
      return;
    }
    this.postService.delete(currentPost.id).subscribe({
      next: () => {
        alert('Post deleted successfully');
        this.router.navigate(['/feed']);
      },
      error: (err) => {
        console.error('Failed to delete post', err);
        alert('Failed to delete post. Please try again.');
      },
    });
  }
  formatTime(isoDate: string): string {
    const date = new Date(isoDate);
    const diff = (Date.now() - date.getTime()) / 1000;
    if (diff < 60) return 'Just now';
    if (diff < 3600) return `${Math.floor(diff / 60)}m ago`;
    if (diff < 86400) return `${Math.floor(diff / 3600)}h ago`;
    if (diff < 604800) return `${Math.floor(diff / 86400)}d ago`;
    return date.toLocaleDateString();
  }
}
FILE: src/app/features/posts/post-list/post-list.html
<p>post-list works!</p>
FILE: src/app/features/posts/post-list/post-list.ts
import { Component } from '@angular/core';
@Component({
  selector: 'app-post-list',
  imports: [],
  templateUrl: './post-list.html',
  styleUrl: './post-list.css',
})
export class PostList {
}
FILE: src/app/features/posts/services/post.ts
import { inject, Injectable } from '@angular/core';
import { HttpClient, HttpParams } from '@angular/common/http';
import { environment } from '../../../core/config/environment';
import { map, tap } from 'rxjs';
import { Post, PostList } from '../../../core/models/post.model';
import { VoteState } from '../../../core/services/vote-state';
import { Websocket } from '../../../core/services/websocket';
interface PostDto {
  id: number;
  user_id: number;
  title: string;
  description: string | null;
  tag: string | null;
  image_url: string | null;
  upvotes: number;
  downvotes: number;
  comment_count: number;
  created_at: string;
  updated_at: string | null;
  author_username: string;
  author_avatar: string | null;
  user_vote: 'up' | 'down' | null;
  is_favorited: boolean;
}
interface PostListDto {
  posts: PostDto[];
  total: number;
  page: number;
  page_size: number;
  has_more: boolean;
}
interface CreatePostDto {
  title: string;
  description?: string | null;
  tag?: string | null;
  imageUrl?: string | null;
}
@Injectable({ providedIn: 'root' })
export class PostService {
  private readonly http = inject(HttpClient);
  private readonly voteState = inject(VoteState);
  private readonly websocket = inject(Websocket);
  list(options: { page?: number; sortBy?: 'new' | 'hot' | 'top'; tag?: string | null } = {}) {
    const params = new HttpParams({
      fromObject: {
        page: (options.page ?? 1).toString(),
        page_size: '20',
        sort_by: options.sortBy ?? 'new',
        ...(options.tag ? { tag: options.tag } : {}),
      },
    });
    return this.http
      .get<PostListDto>(`${environment.apiUrl}/posts`, { params })
      .pipe(map((dto) => this.mapList(dto)));
  }
  getOne(id: number | string) {
    return this.http
      .get<PostDto>(`${environment.apiUrl}/posts/${id}`)
      .pipe(map((dto) => this.mapPost(dto)));
  }
  create(payload: CreatePostDto) {
    const body = {
      title: payload.title,
      description: payload.description ?? null,
      tag: payload.tag ?? null,
      image_url: payload.imageUrl ?? null,
    };
    return this.http
      .post<PostDto>(`${environment.apiUrl}/posts`, body)
      .pipe(map((dto) => this.mapPost(dto)));
  }
  delete(postId: number) {
    return this.http.delete(`${environment.apiUrl}/posts/${postId}`);
  }
  vote(postId: number, voteType: 'up' | 'down', currentVote: 'up' | 'down' | null) {
    this.voteState.optimisticVote('post', postId, voteType, currentVote);
    this.voteState.setPending('post', postId, true);
    return this.http.post<{
      upvotes: number;
      downvotes: number;
      user_vote: 'up' | 'down' | null;
    }>(`${environment.apiUrl}/posts/${postId}/vote`, {
      vote_type: voteType,
    }).pipe(
      tap(response => {
        this.voteState.setPending('post', postId, false);
      })
    );
  }
  removeVote(postId: number, currentVote: 'up' | 'down' | null) {
    this.voteState.optimisticVote('post', postId, null, currentVote);
    this.voteState.setPending('post', postId, true);
    return this.http.delete<{
      upvotes: number;
      downvotes: number;
      user_vote: null;
    }>(`${environment.apiUrl}/posts/${postId}/vote`).pipe(
      tap(response => {
        this.voteState.setPending('post', postId, false);
      })
    );
  }
  favorite(postId: number) {
    return this.http.post(`${environment.apiUrl}/posts/${postId}/favorite`, {});
  }
  unfavorite(postId: number) {
    return this.http.delete(`${environment.apiUrl}/posts/${postId}/favorite`);
  }
  getFavorites(options: { page?: number } = {}) {
    const params = new HttpParams({
      fromObject: {
        page: (options.page ?? 1).toString(),
        page_size: '20',
      },
    });
    return this.http
      .get<PostListDto>(`${environment.apiUrl}/posts/favorites`, { params })
      .pipe(map((dto) => this.mapList(dto)));
  }
  private mapList(dto: PostListDto): PostList {
    return {
      posts: dto.posts.map((post) => this.mapPost(post)),
      total: dto.total,
      page: dto.page,
      pageSize: dto.page_size,
      hasMore: dto.has_more,
    };
  }
  private mapPost(dto: PostDto): Post {
    return {
      id: dto.id,
      userId: dto.user_id,
      title: dto.title,
      description: dto.description,
      tag: dto.tag,
      imageUrl: dto.image_url,
      upvotes: dto.upvotes,
      downvotes: dto.downvotes,
      commentCount: dto.comment_count,
      createdAt: dto.created_at,
      updatedAt: dto.updated_at,
      authorUsername: dto.author_username,
      authorAvatar: dto.author_avatar,
      userVote: dto.user_vote,
      isFavorited: dto.is_favorited,
    };
  }
}
FILE: src/app/features/user/profile/profile.html
<p>profile works!</p>
FILE: src/app/features/user/profile/profile.ts
import { Component } from '@angular/core';
@Component({
  selector: 'app-profile',
  imports: [],
  templateUrl: './profile.html',
  styleUrl: './profile.css',
})
export class Profile {
}
FILE: src/app/features/user/services/user.ts
import { Injectable } from '@angular/core';
@Injectable({
  providedIn: 'root',
})
export class User {
}
FILE: src/app/features/user/settings/settings.html
<p>settings works!</p>
FILE: src/app/features/user/settings/settings.ts
import { Component } from '@angular/core';
@Component({
  selector: 'app-settings',
  imports: [],
  templateUrl: './settings.html',
  styleUrl: './settings.css',
})
export class Settings {
}
FILE: src/app/pages/category/category.ts
import { ChangeDetectionStrategy, Component, DestroyRef, OnInit, inject, signal } from '@angular/core';
import { ActivatedRoute } from '@angular/router';
import { takeUntilDestroyed } from '@angular/core/rxjs-interop';
import { PostCard } from '../../features/posts/post-card/post-card';
import { LoadingSpinner } from '../../shared/components/loading-spinner/loading-spinner';
import { PostService } from '../../features/posts/services/post';
import { Post } from '../../core/models/post.model';
@Component({
  selector: 'app-category',
  standalone: true,
  imports: [PostCard, LoadingSpinner],
  template: `
    <div class="feed-container">
      <div class="feed-header">
        <h1 class="feed-title">{{ getCategoryTitle() }}</h1>
      </div>
      <div class="posts-list">
        @for (post of posts(); track post.id) {
          <app-post-card [post]="post"></app-post-card>
        } @empty {
          @if (!isLoading()) {
            <div class="empty-state">
              <span class="material-icons">inbox</span>
              <p>No posts in this category yet. Be the first to post!</p>
            </div>
          }
        }
      </div>
      @if (isLoading()) {
        <app-loading-spinner></app-loading-spinner>
      }
    </div>
  `,
  styles: [`
    .feed-container {
      max-width: 800px;
      margin: 0 auto;
    }
    .feed-header {
      margin-bottom: 24px;
    }
    .feed-title {
      font-size: 24px;
      font-weight: 700;
      color: var(--text-primary);
      text-transform: capitalize;
    }
    .posts-list {
      display: flex;
      flex-direction: column;
      gap: 16px;
    }
    .empty-state {
      text-align: center;
      padding: 60px 20px;
      color: var(--text-secondary);
    }
    .empty-state .material-icons {
      font-size: 64px;
      color: var(--text-muted);
      margin-bottom: 16px;
    }
  `],
  changeDetection: ChangeDetectionStrategy.OnPush,
})
export class Category implements OnInit {
  private readonly route = inject(ActivatedRoute);
  private readonly postService = inject(PostService);
  private readonly destroyRef = inject(DestroyRef);
  readonly posts = signal<Post[]>([]);
  readonly isLoading = signal(false);
  readonly category = signal<string>('');
  ngOnInit() {
    this.route.paramMap.pipe(takeUntilDestroyed(this.destroyRef)).subscribe(params => {
      const categorySlug = params.get('slug');
      if (categorySlug) {
        this.category.set(categorySlug);
        this.loadPosts(categorySlug);
      }
    });
  }
  loadPosts(tag: string) {
    this.isLoading.set(true);
    this.postService
      .list({ tag, sortBy: 'new' })
      .pipe(takeUntilDestroyed(this.destroyRef))
      .subscribe({
        next: (list) => {
          this.posts.set(list.posts);
          this.isLoading.set(false);
        },
        error: (error) => {
          console.error('Failed to load posts', error);
          this.posts.set([]);
          this.isLoading.set(false);
        },
      });
  }
  getCategoryTitle(): string {
    const cat = this.category();
    return cat ? `#${cat}` : 'Category';
  }
}
FILE: src/app/pages/feed/feed.html
<div class="feed-container">
  <div class="feed-header">
    <h1 class="feed-title">{{ feedTitle() }}</h1>
  </div>

  <div class="posts-list">
    @for (post of posts(); track post.id) {
      <app-post-card [post]="post"></app-post-card>
    } @empty {
      <div class="empty-state">
        <span class="material-icons">article</span>
        <p>No posts yet. Be the first to share a meme!</p>
      </div>
    }
  </div>

  @if (isLoading()) {
    <app-loading-spinner></app-loading-spinner>
  }
</div>
FILE: src/app/pages/feed/feed.ts
import { ChangeDetectionStrategy, Component, DestroyRef, OnInit, computed, inject, signal } from '@angular/core';
import { ActivatedRoute, Router } from '@angular/router';
import { takeUntilDestroyed } from '@angular/core/rxjs-interop';
import { PostCard } from '../../features/posts/post-card/post-card';
import { LoadingSpinner } from '../../shared/components/loading-spinner/loading-spinner';
import { PostService } from '../../features/posts/services/post';
import { Post } from '../../core/models/post.model';
type FeedFilter = 'home' | 'hot' | 'new' | 'top';
@Component({
  selector: 'app-feed',
  standalone: true,
  imports: [PostCard, LoadingSpinner],
  templateUrl: './feed.html',
  styleUrls: ['./feed.css'],
  changeDetection: ChangeDetectionStrategy.OnPush,
})
export class Feed implements OnInit {
  private readonly postService = inject(PostService);
  private readonly destroyRef = inject(DestroyRef);
  private readonly route = inject(ActivatedRoute);
  private readonly router = inject(Router);
  readonly posts = signal<Post[]>([]);
  readonly currentFilter = signal<FeedFilter>('home');
  readonly isLoading = signal(false);
  private readonly validFilters: FeedFilter[] = ['home', 'hot', 'new', 'top'];
  readonly feedTitle = computed(() => this.getFeedTitle(this.currentFilter()));
  ngOnInit() {
    this.route.paramMap
      .pipe(takeUntilDestroyed(this.destroyRef))
      .subscribe((params) => {
        const param = params.get('filter') as FeedFilter | null;
        const filter = param && this.validFilters.includes(param) ? param : 'home';
        this.currentFilter.set(filter);
        this.loadPosts();
      });
    if (!this.route.snapshot.paramMap.get('filter')) {
      this.loadPosts();
    }
  }
  loadPosts() {
    const filter = this.currentFilter();
    this.isLoading.set(true);
    this.postService
      .list({ sortBy: this.getSortParam(filter) })
      .pipe(takeUntilDestroyed(this.destroyRef))
      .subscribe({
        next: (list) => {
          let posts = [...list.posts];
          switch (filter) {
            case 'home':
              posts = this.shufflePosts(posts);
              break;
            case 'hot':
              posts.sort((a, b) => (b.commentCount ?? 0) - (a.commentCount ?? 0));
              break;
            case 'top':
              posts.sort((a, b) => b.upvotes - a.upvotes);
              break;
            case 'new':
              posts.sort(
                (a, b) =>
                  new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime(),
              );
              break;
          }
          this.posts.set(posts);
          this.isLoading.set(false);
        },
        error: (error) => {
          console.error('Failed to load posts', error);
          this.posts.set([]);
          this.isLoading.set(false);
        },
      });
  }
  private getSortParam(filter: FeedFilter): 'new' | 'hot' | 'top' {
    switch (filter) {
      case 'top':
        return 'top';
      case 'hot':
        return 'new';
      default:
        return 'new';
    }
  }
  private shufflePosts(posts: Post[]): Post[] {
    const shuffled = [...posts];
    for (let i = shuffled.length - 1; i > 0; i -= 1) {
      const j = Math.floor(Math.random() * (i + 1));
      [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
    }
    return shuffled;
  }
  getFeedTitle(filter: FeedFilter): string {
    switch (filter) {
      case 'hot':
        return 'ğŸ”¥ Hot posts (most discussed)';
      case 'new':
        return 'ğŸ†• Latest memes';
      case 'top':
        return 'ğŸ“ˆ Top upvoted memes';
      default:
        return 'ğŸ  Home feed';
    }
  }
  setFilter(filter: FeedFilter) {
    if (filter === this.currentFilter()) return;
    if (filter === 'home') {
      void this.router.navigate(['/feed']);
    } else {
      void this.router.navigate(['/feed', filter]);
    }
  }
}
FILE: src/app/pages/home/home.html
<p>home works!</p>
FILE: src/app/pages/home/home.ts
import { Component } from '@angular/core';
@Component({
  selector: 'app-home',
  imports: [],
  templateUrl: './home.html',
  styleUrl: './home.css',
})
export class Home {
}
FILE: src/app/pages/not-found/not-found.html
<p>not-found works!</p>
FILE: src/app/pages/not-found/not-found.ts
import { Component } from '@angular/core';
@Component({
  selector: 'app-not-found',
  imports: [],
  templateUrl: './not-found.html',
  styleUrl: './not-found.css',
})
export class NotFound {
}
FILE: src/app/pages/saved-posts/saved-posts.ts
import { ChangeDetectionStrategy, Component, DestroyRef, OnInit, inject, signal, effect } from '@angular/core';
import { takeUntilDestroyed } from '@angular/core/rxjs-interop';
import { CommonModule } from '@angular/common';
import { PostCard } from '../../features/posts/post-card/post-card';
import { LoadingSpinner } from '../../shared/components/loading-spinner/loading-spinner';
import { PostService } from '../../features/posts/services/post';
import { Post } from '../../core/models/post.model';
import { FavoriteState } from '../../core/services/favorite';
@Component({
  selector: 'app-saved-posts',
  standalone: true,
  imports: [CommonModule, PostCard, LoadingSpinner],
  template: `
    <div class="feed-container">
      <div class="feed-header">
        <h1 class="feed-title">ğŸ”– Saved Posts</h1>
        <button class="refresh-btn" (click)="loadSavedPosts()" [disabled]="isLoading()">
          <span class="material-icons">refresh</span>
        </button>
      </div>
      <div class="posts-list">
        @for (post of posts(); track post.id) {
          <app-post-card [post]="post"></app-post-card>
        } @empty {
          @if (!isLoading()) {
            <div class="empty-state">
              <span class="material-icons">bookmark_border</span>
              <p>No saved posts yet. Save posts to view them here!</p>
            </div>
          }
        }
      </div>
      @if (isLoading()) {
        <app-loading-spinner></app-loading-spinner>
      }
    </div>
  `,
  styles: [`
    .feed-container {
      max-width: 800px;
      margin: 0 auto;
      padding: 20px;
    }
    .feed-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 24px;
    }
    .feed-title {
      font-size: 24px;
      font-weight: 700;
      color: var(--text-primary);
    }
    .refresh-btn {
      display: flex;
      align-items: center;
      justify-content: center;
      width: 40px;
      height: 40px;
      border: none;
      background: var(--bg-secondary);
      border-radius: 50%;
      cursor: pointer;
      color: var(--text-primary);
      transition: all 0.2s;
      border: 1px solid var(--border-primary);
    }
    .refresh-btn:hover:not(:disabled) {
      background: var(--bg-hover);
      transform: rotate(180deg);
    }
    .refresh-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    .posts-list {
      display: flex;
      flex-direction: column;
      gap: 16px;
    }
    .empty-state {
      text-align: center;
      padding: 60px 20px;
      color: var(--text-secondary);
    }
    .empty-state .material-icons {
      font-size: 64px;
      color: var(--text-muted);
      margin-bottom: 16px;
    }
  `],
  changeDetection: ChangeDetectionStrategy.OnPush,
})
export class SavedPosts implements OnInit {
  private readonly postService = inject(PostService);
  private readonly destroyRef = inject(DestroyRef);
  private readonly favoriteState = inject(FavoriteState);
  readonly posts = signal<Post[]>([]);
  readonly isLoading = signal(false);
  constructor() {
    effect(() => {
      this.favoriteState.changed();
      this.loadSavedPosts();
    }, { allowSignalWrites: true });
  }
  ngOnInit() {
    this.loadSavedPosts();
  }
  loadSavedPosts() {
    this.isLoading.set(true);
    this.postService
      .getFavorites()
      .pipe(takeUntilDestroyed(this.destroyRef))
      .subscribe({
        next: (list) => {
          console.log('âœ… Loaded saved posts:', list.posts.length);
          this.posts.set(list.posts);
          this.isLoading.set(false);
        },
        error: (error) => {
          console.error('âŒ Failed to load saved posts', error);
          this.posts.set([]);
          this.isLoading.set(false);
        },
      });
  }
}
FILE: src/app/shared/components/confirm-dialog/confirm-dialog.html
<div class="dialog-overlay" (click)="cancel()">
  <div class="dialog-container" (click)="$event.stopPropagation()">
    <div class="dialog-header">
      <h2>{{ title() }}</h2>
      <button class="dialog-close" (click)="cancel()">
        <span class="material-icons">close</span>
      </button>
    </div>

    <div class="dialog-body">
      <p>{{ message() }}</p>
    </div>

    <div class="dialog-footer">
      <button class="dialog-btn cancel" (click)="cancel()">
        {{ cancelText() }}
      </button>
      <button class="dialog-btn confirm" [class.danger]="isDanger()" (click)="confirm()">
        {{ confirmText() }}
      </button>
    </div>
  </div>
</div>
FILE: src/app/shared/components/confirm-dialog/confirm-dialog.ts
import { Component, input, output } from '@angular/core';
@Component({
  selector: 'app-confirm-dialog',
  templateUrl: './confirm-dialog.html',
  styleUrl: './confirm-dialog.css'
})
export class ConfirmDialog {
  title = input<string>('Confirm Action');
  message = input<string>('Are you sure you want to proceed?');
  confirmText = input<string>('Confirm');
  cancelText = input<string>('Cancel');
  isDanger = input<boolean>(false);
  confirmed = output<void>();
  cancelled = output<void>();
  confirm() {
    this.confirmed.emit();
  }
  cancel() {
    this.cancelled.emit();
  }
}
FILE: src/app/shared/components/error-message/error-message.html
<div class="error-message-container" [class]="'error-' + type()">
  <span class="material-icons">{{ getIcon() }}</span>
  <div class="error-content">
    <h3 class="error-title">{{ title() }}</h3>
    <p class="error-text">{{ message() }}</p>
  </div>
  @if (dismissible()) {
    <button class="dismiss-btn" (click)="dismiss.emit()">
      <span class="material-icons">close</span>
    </button>
  }
</div>
FILE: src/app/shared/components/error-message/error-message.ts
import { Component, input, output } from '@angular/core';
@Component({
  selector: 'app-error-message',
  templateUrl: './error-message.html',
  styleUrl: './error-message.css'
})
export class ErrorMessage {
  type = input<'error' | 'warning' | 'info' | 'success'>('error');
  title = input<string>('');
  message = input.required<string>();
  dismissible = input<boolean>(false);
  dismiss = output<void>();
  getIcon(): string {
    switch (this.type()) {
      case 'error': return 'error';
      case 'warning': return 'warning';
      case 'info': return 'info';
      case 'success': return 'check_circle';
      default: return 'error';
    }
  }
}
FILE: src/app/shared/components/header/header.html
<header class="header">
  <div class="header-left">
    <button class="menu-toggle" (click)="toggleSidebar()">
      <span class="material-icons">menu</span>
    </button>
    <div class="logo" routerLink="/feed">
      <span class="logo-icon">ğŸ”¥</span>
      <span class="logo-text">MemeForum</span>
    </div>
  </div>

  <div class="header-center">
    <div class="search-bar">
      <span class="material-icons search-icon">search</span>
      <input type="text" placeholder="Search memes..." class="search-input" />
    </div>
  </div>

  <div class="header-right">
    <button class="icon-button" routerLink="/create-post" *ngIf="isAuthenticated()">
      <span class="material-icons">add</span>
    </button>

    <app-notification-bell *ngIf="isAuthenticated()"></app-notification-bell>

    @if (isAuthenticated()) {

      <div class="user-menu">
        <app-user-avatar
          [size]="32"
          [username]="user()?.username ?? ''"
          [imageUrl]="user()?.avatarUrl ?? ''"
        ></app-user-avatar>
      </div>
      <button class="login-btn" type="button" (click)="logout()">Logout</button>
    } @else {
      <button class="login-btn" routerLink="/login">Login</button>
    }
  </div>
</header>
FILE: src/app/shared/components/header/header.ts
import { ChangeDetectionStrategy, Component, inject } from '@angular/core';
import { CommonModule } from '@angular/common';
import { RouterLink } from '@angular/router';
import { NotificationBell } from '../../../features/notifications/notification-bell/notification-bell';
import { UserAvatar } from '../user-avatar/user-avatar';
import { Auth } from '../../../core/services/auth';
@Component({
  selector: 'app-header',
  standalone: true,
  imports: [CommonModule, RouterLink, NotificationBell, UserAvatar],
  templateUrl: './header.html',
  styleUrls: ['./header.css'],
  changeDetection: ChangeDetectionStrategy.OnPush,
})
export class Header {
  private readonly auth = inject(Auth);
  readonly isAuthenticated = this.auth.isAuthenticated;
  readonly user = this.auth.user;
  toggleSidebar() {
    console.log('Toggle sidebar');
  }
  logout() {
    this.auth.logout();
  }
}
FILE: src/app/shared/components/loading-spinner/loading-spinner.html
<div class="spinner-container" [class.fullscreen]="fullscreen()">
  <div class="spinner">
    <div class="spinner-ring"></div>
    <div class="spinner-ring"></div>
    <div class="spinner-ring"></div>
    <div class="spinner-ring"></div>
  </div>
  @if (message()) {
    <p class="spinner-message">{{ message() }}</p>
  }
</div>
FILE: src/app/shared/components/loading-spinner/loading-spinner.ts
import { Component, input } from '@angular/core';
import { CommonModule } from '@angular/common';
@Component({
  selector: 'app-loading-spinner',
  standalone: true,
  imports: [CommonModule],
  templateUrl: './loading-spinner.html',
  styleUrl: './loading-spinner.css'
})
export class LoadingSpinner {
  fullscreen = input<boolean>(false);
  message = input<string>('');
}
FILE: src/app/shared/components/sidebar/sidebar.html
<aside class="sidebar" [class.collapsed]="isCollapsed()">
  <nav class="sidebar-nav">
    <div class="nav-section">
      <h3 class="section-title">FEEDS</h3>
      <a routerLink="/feed" routerLinkActive="active" [routerLinkActiveOptions]="{ exact: true }" class="nav-item">
        <span class="material-icons">home</span>
        <span class="nav-text">Home</span>
      </a>
      <a routerLink="/feed/hot" routerLinkActive="active" class="nav-item">
        <span class="material-icons">whatshot</span>
        <span class="nav-text">Hot</span>
      </a>
      <a routerLink="/feed/new" routerLinkActive="active" class="nav-item">
        <span class="material-icons">new_releases</span>
        <span class="nav-text">New</span>
      </a>
      <a routerLink="/feed/top" routerLinkActive="active" class="nav-item">
        <span class="material-icons">trending_up</span>
        <span class="nav-text">Top</span>
      </a>

      @if (isAuthenticated()) {
        <a routerLink="/saved" routerLinkActive="active" class="nav-item">
          <span class="material-icons">bookmark</span>
          <span class="nav-text">Saved</span>
        </a>
      }
    </div>

    @if (isAuthenticated()) {
      @if (isAdmin() || isModerator()) {
        <div class="nav-section">
          <h3 class="section-title">MODERATION</h3>

          @if (isAdmin()) {
            <a routerLink="/admin" routerLinkActive="active" class="nav-item">
              <span class="material-icons">admin_panel_settings</span>
              <span class="nav-text">Admin Dashboard</span>
            </a>
            <a routerLink="/admin/users" routerLinkActive="active" class="nav-item">
              <span class="material-icons">manage_accounts</span>
              <span class="nav-text">Manage Users</span>
            </a>
          }

          <a [routerLink]="isAdmin() ? '/admin/posts' : '/mod/posts'" routerLinkActive="active" class="nav-item">
            <span class="material-icons">article</span>
            <span class="nav-text">Manage Posts</span>
          </a>

          <a [routerLink]="isAdmin() ? '/admin/comments' : '/mod/comments'" routerLinkActive="active" class="nav-item">
            <span class="material-icons">comment</span>
            <span class="nav-text">Manage Comments</span>
          </a>
        </div>
      }
    }

    <div class="nav-section">
      <h3 class="section-title">CATEGORIES</h3>
      @for (category of categories(); track category.id) {
        <a [routerLink]="['/category', category.slug]" routerLinkActive="active" class="nav-item">
          <span class="category-emoji">{{ category.emoji }}</span>
          <span class="nav-text">{{ category.name }}</span>
        </a>
      }
    </div>
  </nav>

  <div class="sidebar-footer">
    <button class="create-post-btn" routerLink="/create-post">
      <span class="material-icons">add</span>
      <span>Create Post</span>
    </button>
  </div>
</aside>
FILE: src/app/shared/components/sidebar/sidebar.ts
import { ChangeDetectionStrategy, Component, computed, inject, signal } from '@angular/core';
import { CommonModule } from '@angular/common';
import { RouterLink, RouterLinkActive } from '@angular/router';
import { Auth } from '../../../core/services/auth';
import { CATEGORIES } from '../../../core/constants/categories';
@Component({
  selector: 'app-sidebar',
  standalone: true,
  imports: [CommonModule, RouterLink, RouterLinkActive],
  templateUrl: './sidebar.html',
  styleUrls: ['./sidebar.css'],
  changeDetection: ChangeDetectionStrategy.OnPush,
})
export class Sidebar {
  readonly auth = inject(Auth);
  readonly categories = signal(CATEGORIES);
  readonly isAuthenticated = this.auth.isAuthenticated;
  readonly isCollapsed = signal(false);
  readonly user = computed(() => this.auth.user());
  isAdmin(): boolean {
    const user = this.auth.user();
    return user?.role === 'admin';
  }
  isModerator(): boolean {
    const user = this.auth.user();
    return user?.role === 'admin' || user?.role === 'moderator';
  }
}
FILE: src/app/shared/components/user-avatar/user-avatar.html
<div
  class="avatar"
  [style.width.px]="size()"
  [style.height.px]="size()"
  [class.clickable]="clickable()"
  (click)="handleClick()"
>
  @if (imageUrl()) {
    <img [src]="imageUrl()" [alt]="username() || 'User avatar'" class="avatar-image">
  } @else {
    <div class="avatar-fallback" [style.background-color]="getAvatarColor()">
      {{ getInitials() }}
    </div>
  }

  @if (showOnlineStatus() && isOnline()) {
    <span class="online-indicator"></span>
  }
</div>
FILE: src/app/shared/components/user-avatar/user-avatar.ts
import { Component, input, output } from '@angular/core';
import { CommonModule } from '@angular/common';
@Component({
  selector: 'app-user-avatar',
  standalone: true,
  imports: [CommonModule],
  templateUrl: './user-avatar.html',
  styleUrl: './user-avatar.css'
})
export class UserAvatar {
  size = input<number>(40);
  username = input<string>('');
  imageUrl = input<string>('');
  showOnlineStatus = input<boolean>(false);
  isOnline = input<boolean>(false);
  clickable = input<boolean>(false);
  click = output<void>();
  handleClick() {
    if (this.clickable()) {
      this.click.emit();
    }
  }
  getInitials(): string {
    const name = this.username();
    if (!name) return '?';
    const parts = name.split(' ');
    if (parts.length >= 2) {
      return parts[0][0] + parts[1][0];
    }
    return name.substring(0, 2);
  }
  getAvatarColor(): string {
    const colors = [
      '#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4',
      '#FFEAA7', '#DDA0DD', '#98D8C8', '#FFB6C1'
    ];
    const name = this.username();
    if (!name) return colors[0];
    let hash = 0;
    for (let i = 0; i < name.length; i++) {
      hash = name.charCodeAt(i) + ((hash << 5) - hash);
    }
    return colors[Math.abs(hash) % colors.length];
  }
}
FILE: src/app/shared/components/vote-buttons/vote-buttons.html
<div class="vote-container" [class.horizontal]="orientation() === 'horizontal'">
  <button
    class="vote-btn upvote"
    [class.active]="userVote() === 'up'"
    [class.disabled]="disabled()"
    [disabled]="disabled()"
    (click)="handleVote($event, 'up')"
    [attr.aria-label]="'Upvote'"
  >
    <span class="material-icons">arrow_upward</span>
  </button>

  <span class="vote-count"
    [class.upvoted]="userVote() === 'up'"
    [class.downvoted]="userVote() === 'down'"
    [class.loading]="disabled()">
    {{ formatVoteCount(voteCount()) }}
  </span>

  <button
    class="vote-btn downvote"
    [class.active]="userVote() === 'down'"
    [class.disabled]="disabled()"
    [disabled]="disabled()"
    (click)="handleVote($event, 'down')"
    [attr.aria-label]="'Downvote'"
  >
    <span class="material-icons">arrow_downward</span>
  </button>
</div>
FILE: src/app/shared/components/vote-buttons/vote-buttons.ts
import { Component, input, output, computed } from '@angular/core';
import { CommonModule } from '@angular/common';
@Component({
  selector: 'app-vote-buttons',
  standalone: true,
  imports: [CommonModule],
  templateUrl: './vote-buttons.html',
  styleUrl: './vote-buttons.css'
})
export class VoteButtons {
  upvotes = input.required<number>();
  downvotes = input.required<number>();
  userVote = input<'up' | 'down' | null>(null);
  orientation = input<'vertical' | 'horizontal'>('vertical');
  disabled = input<boolean>(false);
  vote = output<'up' | 'down'>();
  voteCount = computed(() => {
    return this.upvotes() - this.downvotes();
  });
  handleVote(event: Event, voteType: 'up' | 'down') {
    event.stopPropagation();
    event.preventDefault();
    if (!this.disabled()) {
      this.vote.emit(voteType);
    }
  }
  formatVoteCount(count: number): string {
    if (count >= 1000000) {
      return (count / 1000000).toFixed(1) + 'M';
    } else if (count >= 1000) {
      return (count / 1000).toFixed(1) + 'k';
    }
    return count.toString();
  }
}
FILE: src/index.html
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>MemeForum</title>
  <base href="/">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="icon" type="image/x-icon" href="favicon.ico">
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;500;600;700&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
</head>
<body>
  <app-root></app-root>
</body>
</html>
FILE: src/main.ts
import 'zone.js';
import { bootstrapApplication } from '@angular/platform-browser';
import { appConfig } from './app/app.config';
import { App } from './app/app';
bootstrapApplication(App, appConfig)
  .catch((err) => console.error(err));
FILE: tsconfig.app.json
/* To learn more about Typescript configuration file: https://www.typescriptlang.org/docs/handbook/tsconfig-json.html. */
/* To learn more about Angular compiler options: https://angular.dev/reference/configs/angular-compiler-options. */
{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "outDir": "./out-tsc/app",
    "types": []
  },
  "include": [
    "src/**/*.ts"
  ],
  "exclude": [
    "src/**/*.spec.ts"
  ]
}
FILE: tsconfig.json
/* To learn more about Typescript configuration file: https://www.typescriptlang.org/docs/handbook/tsconfig-json.html. */
/* To learn more about Angular compiler options: https://angular.dev/reference/configs/angular-compiler-options. */
{
  "compileOnSave": false,
  "compilerOptions": {
    "strict": true,
    "noImplicitOverride": true,
    "noPropertyAccessFromIndexSignature": true,
    "noImplicitReturns": true,
    "noFallthroughCasesInSwitch": true,
    "skipLibCheck": true,
    "isolatedModules": true,
    "experimentalDecorators": true,
    "importHelpers": true,
    "target": "ES2022",
    "module": "preserve"
  },
  "angularCompilerOptions": {
    "enableI18nLegacyMessageIdFormat": false,
    "strictInjectionParameters": true,
    "strictInputAccessModifiers": true,
    "strictTemplates": true
  },
  "files": [],
  "references": [
    {
      "path": "./tsconfig.app.json"
    },
    {
      "path": "./tsconfig.spec.json"
    }
  ]
}
FILE: tsconfig.spec.json
/* To learn more about Typescript configuration file: https://www.typescriptlang.org/docs/handbook/tsconfig-json.html. */
/* To learn more about Angular compiler options: https://angular.dev/reference/configs/angular-compiler-options. */
{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "outDir": "./out-tsc/spec",
    "types": [
      "vitest/globals"
    ]
  },
  "include": [
    "src/**/*.d.ts",
    "src/**/*.spec.ts"
  ]
}
SUMMARY
Total files: 95
Original size: 176,904 chars
Processed size: 171,783 chars
Reduction: 2.9%

File types:
 .ts: 61
 .html: 30
 .json: 3
 [no extension]: 1
