DIRECTORY TREE
ğŸ“ Seddit/
â”‚ ğŸ“„ Extractor.py
â”‚ ğŸ“„ docker-compose.yml
â”‚ ğŸ“ backend/
â”‚ â”‚ ğŸ“„ .env.example
â”‚ â”‚ âš™ï¸ firebase-service-account.json
â”‚ â”‚ ğŸ“„ main.py
â”‚ â”‚ ğŸ“„ seed.py
â”‚ â”‚ ğŸ“ alembic/
â”‚ â”‚ â”‚ ğŸ“„ README
â”‚ â”‚ â”‚ ğŸ“„ env.py
â”‚ â”‚ â”‚ ğŸ“ versions/
â”‚ â”‚ â”‚ â”‚ ğŸ“„ 20251130_allow_long_image_url.py
â”‚ â”‚ â”‚ â”‚ ğŸ“„ 382b9ef7d182_initial_schema.py
â”‚ â”‚ ğŸ“ app/
â”‚ â”‚ â”‚ ğŸ“„ config.py
â”‚ â”‚ â”‚ ğŸ“„ database.py
â”‚ â”‚ â”‚ ğŸ“„ dependencies.py
â”‚ â”‚ â”‚ ğŸ“„ main.py
â”‚ â”‚ â”‚ ğŸ“ api/
â”‚ â”‚ â”‚ â”‚ ğŸ“ v1/
â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“„ auth.py
â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“„ comments.py
â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“„ posts.py
â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“„ users.py
â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“„ websocket.py
â”‚ â”‚ â”‚ ğŸ“ core/
â”‚ â”‚ â”‚ â”‚ ğŸ“„ firebase_auth.py
â”‚ â”‚ â”‚ â”‚ ğŸ“„ permissions.py
â”‚ â”‚ â”‚ â”‚ ğŸ“„ redis_client.py
â”‚ â”‚ â”‚ â”‚ ğŸ“„ security.py
â”‚ â”‚ â”‚ ğŸ“ middleware/
â”‚ â”‚ â”‚ â”‚ ğŸ“„ logging.py
â”‚ â”‚ â”‚ â”‚ ğŸ“„ rate_limit.py
â”‚ â”‚ â”‚ ğŸ“ models/
â”‚ â”‚ â”‚ â”‚ ğŸ“„ comment.py
â”‚ â”‚ â”‚ â”‚ ğŸ“„ notification.py
â”‚ â”‚ â”‚ â”‚ ğŸ“„ post.py
â”‚ â”‚ â”‚ â”‚ ğŸ“„ role.py
â”‚ â”‚ â”‚ â”‚ ğŸ“„ user.py
â”‚ â”‚ â”‚ ğŸ“ repositories/
â”‚ â”‚ â”‚ â”‚ ğŸ“„ comment_repository.py
â”‚ â”‚ â”‚ â”‚ ğŸ“„ post_repository.py
â”‚ â”‚ â”‚ â”‚ ğŸ“„ user_repository.py
â”‚ â”‚ â”‚ ğŸ“ schemas/
â”‚ â”‚ â”‚ â”‚ ğŸ“„ __init__.py
â”‚ â”‚ â”‚ â”‚ ğŸ“„ auth.py
â”‚ â”‚ â”‚ â”‚ ğŸ“„ comment.py
â”‚ â”‚ â”‚ â”‚ ğŸ“„ notification.py
â”‚ â”‚ â”‚ â”‚ ğŸ“„ post.py
â”‚ â”‚ â”‚ â”‚ ğŸ“„ user.py
â”‚ â”‚ â”‚ ğŸ“ services/
â”‚ â”‚ â”‚ â”‚ ğŸ“„ auth_service.py
â”‚ â”‚ â”‚ â”‚ ğŸ“„ comment_service.py
â”‚ â”‚ â”‚ â”‚ ğŸ“„ notification_service.py
â”‚ â”‚ â”‚ â”‚ ğŸ“„ notification_stream.py
â”‚ â”‚ â”‚ â”‚ ğŸ“„ post_service.py
â”‚ â”‚ â”‚ â”‚ ğŸ“„ websocket_service.py
â”‚ â”‚ â”‚ ğŸ“ utils/
â”‚ â”‚ â”‚ â”‚ ğŸ“„ logger.py
â”‚ â”‚ ğŸ“ logs/
â”‚ â”‚ ğŸ“ tests/
â”‚ ğŸ“ db/
â”‚ â”‚ ğŸ“„ docker-compose.yml
â”‚ â”‚ ğŸ“ init-scripts/
â”‚ ğŸ“ frontend/
â”‚ â”‚ âš™ï¸ tsconfig.app.json
â”‚ â”‚ âš™ï¸ tsconfig.json
â”‚ â”‚ âš™ï¸ tsconfig.spec.json
â”‚ â”‚ ğŸ“ .claude/
â”‚ â”‚ ğŸ“ public/
â”‚ â”‚ ğŸ“ src/
â”‚ â”‚ â”‚ ğŸ¨ custom-theme.scss
â”‚ â”‚ â”‚ ğŸŒ index.html
â”‚ â”‚ â”‚ ğŸ“˜ main.ts
â”‚ â”‚ â”‚ ğŸ¨ styles.css
â”‚ â”‚ â”‚ ğŸ“ app/
â”‚ â”‚ â”‚ â”‚ ğŸ“˜ app.config.ts
â”‚ â”‚ â”‚ â”‚ ğŸ¨ app.css
â”‚ â”‚ â”‚ â”‚ ğŸŒ app.html
â”‚ â”‚ â”‚ â”‚ ğŸ“˜ app.routes.ts
â”‚ â”‚ â”‚ â”‚ ğŸ“˜ app.spec.ts
â”‚ â”‚ â”‚ â”‚ ğŸ“˜ app.ts
â”‚ â”‚ â”‚ â”‚ ğŸ“ core/
â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“ config/
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“˜ environment.ts
â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“ constants/
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“˜ categories.ts
â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“ firebase/
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“˜ firebase.ts
â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“ guards/
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“˜ admin-guard.ts
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“˜ auth-guard.ts
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“˜ guest-guard.ts
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“˜ role-guard.ts
â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“ interceptors/
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“˜ error-interceptor.ts
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“˜ jwt-interceptor.ts
â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“ models/
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“˜ auth.model.ts
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“˜ comment.model.ts
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“˜ notification.model.ts
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“˜ post.model.ts
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“˜ user.model.ts
â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“ services/
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“˜ auth.ts
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“˜ favorite.ts
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“˜ notification.ts
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“˜ theme.ts
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“˜ vote-state.ts
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“˜ websocket.ts
â”‚ â”‚ â”‚ â”‚ ğŸ“ features/
â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“ auth/
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“ login/
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ¨ login.css
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸŒ login.html
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“˜ login.ts
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“ signup/
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ¨ signup.css
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸŒ signup.html
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“˜ signup.ts
â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“ comments/
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“ comment-form/
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ¨ comment-form.css
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸŒ comment-form.html
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“˜ comment-form.ts
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“ comment-item/
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ¨ comment-item.css
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸŒ comment-item.html
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“˜ comment-item.ts
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“ comment-thread/
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ¨ comment-thread.css
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸŒ comment-thread.html
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“˜ comment-thread.ts
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“ services/
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“˜ comment.ts
â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“ notifications/
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“ notification-bell/
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ¨ notification-bell.css
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸŒ notification-bell.html
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“˜ notification-bell.ts
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“ notification-item/
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ¨ notification-item.css
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸŒ notification-item.html
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“˜ notification-item.ts
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“ notification-list/
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ¨ notification-list.css
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸŒ notification-list.html
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“˜ notification-list.ts
â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“ posts/
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“ post-card/
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ¨ post-card.css
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸŒ post-card.html
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“˜ post-card.ts
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“ post-create/
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ¨ post-create.css
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸŒ post-create.html
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“˜ post-create.ts
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“ post-detail/
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ¨ post-detail.css
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸŒ post-detail.html
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“˜ post-detail.ts
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“ post-list/
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ¨ post-list.css
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸŒ post-list.html
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“˜ post-list.ts
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“ services/
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“˜ post.ts
â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“ user/
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“ profile/
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ¨ profile.css
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸŒ profile.html
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“˜ profile.ts
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“ services/
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“˜ user.ts
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“ settings/
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ¨ settings.css
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸŒ settings.html
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“˜ settings.ts
â”‚ â”‚ â”‚ â”‚ ğŸ“ pages/
â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“ category/
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“˜ category.ts
â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“ feed/
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ¨ feed.css
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸŒ feed.html
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“˜ feed.ts
â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“ home/
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ¨ home.css
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸŒ home.html
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“˜ home.ts
â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“ not-found/
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ¨ not-found.css
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸŒ not-found.html
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“˜ not-found.ts
â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“ saved-posts/
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“˜ saved-posts.ts
â”‚ â”‚ â”‚ â”‚ ğŸ“ shared/
â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“ components/
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“ confirm-dialog/
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ¨ confirm-dialog.css
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸŒ confirm-dialog.html
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“˜ confirm-dialog.ts
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“ error-message/
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ¨ error-message.css
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸŒ error-message.html
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“˜ error-message.ts
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“ header/
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ¨ header.css
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸŒ header.html
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“˜ header.ts
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“ loading-spinner/
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ¨ loading-spinner.css
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸŒ loading-spinner.html
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“˜ loading-spinner.ts
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“ sidebar/
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ¨ sidebar.css
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸŒ sidebar.html
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“˜ sidebar.ts
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“ user-avatar/
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ¨ user-avatar.css
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸŒ user-avatar.html
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“˜ user-avatar.ts
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“ vote-buttons/
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ¨ vote-buttons.css
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸŒ vote-buttons.html
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ ğŸ“˜ vote-buttons.ts
â”‚ ğŸ“ redis-cache/
â”‚ â”‚ ğŸ“„ docker-compose.yml
FILE CONTENTS
FILE: Extractor.py
import os
import re

MAIN_PATH = r"C:\Users\SunilKumarPradhan\Desktop\Seddit"

IGNORE_FOLDERS = {
    ".venv", ".git", ".vscode", "node_modules", "dist", "build",
    ".angular", "coverage", ".idea", ".vs", "__pycache__", ".pytest_cache"
}

IGNORE_FILES = {
    "curr_dir.txt", "package-lock.json", ".DS_Store", "thumbs.db",
    ".editorconfig","package.json","angular.json", ".gitignore" ,"Dockerfile"
}

IGNORE_EXTENSIONS = {
    ".map", ".log", ".lock", ".jpg", ".jpeg", ".png", ".gif", ".ico",
    ".svg", ".woff", ".woff2", ".ttf", ".eot" ,".md",".txt"
}

INCLUDE_EXTENSIONS = {
    ".py", ".ts", ".js", ".html", ".css", ".scss", ".json", ".md"
}

def remove_comments(content, file_ext):
    """
    Remove comments from code based on file extension.
    Also removes excessive blank lines.
    """
    if file_ext in {".py"}:
        lines = content.split('\n')
        result = []
        for i, line in enumerate(lines):
            if i == 0 and line.startswith('
                result.append(line)
                continue
            stripped = line.lstrip()
            if stripped.startswith('
                continue
            if '
                parts = line.split('
                if parts[0].strip():
                    result.append(parts[0].rstrip())
                    continue
            result.append(line)
        content = '\n'.join(result)

    elif file_ext in {".js", ".ts", ".css", ".scss"}:
        content = re.sub(r'/\*[\s\S]*?\*/', '', content)
        lines = content.split('\n')
        result = []
        for line in lines:
            if '//' in line:
                if 'http://' not in line and 'https://' not in line:
                    line = re.sub(r'//.*$', '', line)
            if line.strip():
                result.append(line)
        content = '\n'.join(result)

    elif file_ext == ".html":
        content = re.sub(r'<!--[\s\S]*?-->', '', content)

    elif file_ext == ".json":
        lines = content.split('\n')
        result = [line for line in lines if not line.strip().startswith('//')]
        content = '\n'.join(result)

    content = re.sub(r'\n{3,}', '\n\n', content)

    lines = content.split('\n')
    lines = [line.rstrip() for line in lines]
    content = '\n'.join(lines)

    return content.strip()

def should_include_file(file_name, file_path):
    """Determine if a file should be included"""
    if file_name in IGNORE_FILES:
        return False

    _, ext = os.path.splitext(file_name)
    ext_lower = ext.lower()

    if ext_lower in IGNORE_EXTENSIONS:
        return False

    if ext_lower in INCLUDE_EXTENSIONS:
        return True

    important_files = {
        "Dockerfile", "docker-compose.yml", ".env.example", "README"
    }
    return file_name in important_files

def get_relative_path(file_path, root_dir):
    """Get clean relative path with forward slashes"""
    rel_path = os.path.relpath(file_path, root_dir)
    return rel_path.replace(os.sep, '/')

def write_directory_contents(root_dir):
    """Create a comprehensive text file with directory tree and file contents"""
    if not os.path.exists(root_dir):
        print(f"âŒ Directory not found: {root_dir}")
        return

    output_file = os.path.join(root_dir, "curr_dir.txt")

    all_files = []
    for folder, subdirs, files in os.walk(root_dir):
        subdirs[:] = [d for d in subdirs if d not in IGNORE_FOLDERS]
        for file in files:
            if should_include_file(file, os.path.join(folder, file)):
                all_files.append(os.path.join(folder, file))

    all_files.sort()
    print(f"ğŸ“Š Found {len(all_files)} files to include")

    with open(output_file, "w", encoding="utf-8") as out:

        out.write("DIRECTORY TREE\n")
        for folder, subdirs, files in os.walk(root_dir):
            subdirs[:] = [d for d in subdirs if d not in IGNORE_FOLDERS]
            subdirs.sort()

            level = folder.replace(root_dir, '').count(os.sep)
            indent = 'â”‚ ' * level
            folder_name = os.path.basename(folder) or os.path.basename(root_dir)
            out.write(f"{indent}ğŸ“ {folder_name}/\n")

            sub_indent = 'â”‚ ' * (level + 1)
            included_files = [f for f in files if should_include_file(f, os.path.join(folder, f))]
            included_files.sort()

            for file in included_files:
                icon = "ğŸ“„"
                if file.endswith('.ts'): icon = "ğŸ“˜"
                elif file.endswith('.html'): icon = "ğŸŒ"
                elif file.endswith(('.css', '.scss')): icon = "ğŸ¨"
                elif file.endswith('.json'): icon = "âš™ï¸"
                elif file.endswith('.md'): icon = "ğŸ“"
                out.write(f"{sub_indent}{icon} {file}\n")

        out.write("FILE CONTENTS\n")

        original_size = 0
        processed_size = 0

        for file_path in all_files:
            rel_path = get_relative_path(file_path, root_dir)
            out.write(f"FILE: {rel_path}\n")

            try:
                with open(file_path, "r", encoding="utf-8") as f:
                    content = f.read()
                    original_size += len(content)

                if not content.strip():
                    out.write("[EMPTY FILE]\n")
                    continue

                ext = os.path.splitext(file_path)[1].lower()
                processed_content = remove_comments(content, ext)
                processed_size += len(processed_content)

                if not processed_content.strip():
                    out.write("[FILE CONTAINS ONLY COMMENTS]\n")
                else:
                    out.write(processed_content)
                    if not processed_content.endswith('\n'):
                        out.write('\n')

            except UnicodeDecodeError:
                out.write("[BINARY FILE]\n")
            except Exception as e:
                out.write(f"[ERROR: {e}]\n")

        out.write("SUMMARY\n")

        out.write(f"Total files: {len(all_files)}\n")

        if original_size > 0:
            reduction = ((original_size - processed_size) / original_size) * 100
            out.write(f"Original size: {original_size:,} chars\n")
            out.write(f"Processed size: {processed_size:,} chars\n")
            out.write(f"Reduction: {reduction:.1f}%\n")

        ext_counts = {}
        for fp in all_files:
            ext = os.path.splitext(fp)[1] or "[no extension]"
            ext_counts[ext] = ext_counts.get(ext, 0) + 1

        out.write("\nFile types:\n")
        for ext, count in sorted(ext_counts.items(), key=lambda x: x[1], reverse=True):
            out.write(f" {ext}: {count}\n")

    file_size_kb = os.path.getsize(output_file) / 1024
    print(f"âœ… Saved to: {output_file}")
    print(f"ğŸ“ Size: {file_size_kb:.2f} KB")
    if original_size > 0:
        print(f"ğŸ¯ Comment reduction: {reduction:.1f}%")

def main():
    if not MAIN_PATH:
        print("âŒ Please set MAIN_PATH variable")
        return

    print(f"ğŸ” Scanning: {MAIN_PATH}")
    print(f"ğŸ“ Ignoring: {', '.join(list(IGNORE_FOLDERS)[:5])}...")
    print(f"âœ… Including: {', '.join(INCLUDE_EXTENSIONS)}")

    write_directory_contents(MAIN_PATH)

if __name__ == "__main__":
    main()
FILE: backend/.env.example
# Application
APP_NAME=MemeForum
APP_VERSION=1.0.0
DEBUG=True
ENVIRONMENT=development

# Server
HOST=0.0.0.0
PORT=8000

# Database
DATABASE_URL=postgresql://meme_user:meme_pass@localhost:5432/meme_forum
DB_ECHO=False

# Redis
REDIS_HOST=localhost
REDIS_PORT=6379
REDIS_DB=0
REDIS_PASSWORD=

# Firebase
FIREBASE_CREDENTIALS_PATH=./firebase-credentials.json
FIREBASE_PROJECT_ID=your-project-id

# Security
SECRET_KEY=your-super-secret-key-change-this-in-production
ALGORITHM=HS256
ACCESS_TOKEN_EXPIRE_MINUTES=30

# CORS
CORS_ORIGINS=["http://localhost:4200","http://localhost:80"]

# File Upload
MAX_FILE_SIZE=10485760  # 10MB in bytes
ALLOWED_FILE_TYPES=["image/jpeg","image/png","image/gif","image/webp"]
UPLOAD_DIR=./uploads

# Rate Limiting
RATE_LIMIT_PER_MINUTE=60

# Logging
LOG_LEVEL=INFO
LOG_FILE=logs/app.log
FILE: backend/alembic/README
Generic single-database configuration.
FILE: backend/alembic/env.py
from logging.config import fileConfig
from sqlalchemy import engine_from_config, pool
from alembic import context
import sys
from pathlib import Path

sys.path.insert(0, str(Path(__file__).resolve().parent.parent))

from app.config import settings
from app.database import Base
from app.models import user, role, post, comment, notification

config = context.config

config.set_main_option("sqlalchemy.url", settings.DATABASE_URL)

if config.config_file_name is not None:
    fileConfig(config.config_file_name)

target_metadata = Base.metadata

def run_migrations_offline() -> None:
    """Run migrations in 'offline' mode."""
    url = config.get_main_option("sqlalchemy.url")
    context.configure(
        url=url,
        target_metadata=target_metadata,
        literal_binds=True,
        dialect_opts={"paramstyle": "named"},
    )

    with context.begin_transaction():
        context.run_migrations()

def run_migrations_online() -> None:
    """Run migrations in 'online' mode."""
    connectable = engine_from_config(
        config.get_section(config.config_ini_section, {}),
        prefix="sqlalchemy.",
        poolclass=pool.NullPool,
    )

    with connectable.connect() as connection:
        context.configure(
            connection=connection,
            target_metadata=target_metadata
        )

        with context.begin_transaction():
            context.run_migrations()

if context.is_offline_mode():
    run_migrations_offline()
else:
    run_migrations_online()
FILE: backend/alembic/versions/20251130_allow_long_image_url.py
"""allow long image data for posts

Revision ID: 7d82d4f9f341
Revises: 382b9ef7d182
Create Date: 2025-11-30 15:25:00.000000
"""
from alembic import op
import sqlalchemy as sa

revision = "7d82d4f9f341"
down_revision = "382b9ef7d182"
branch_labels = None
depends_on = None

def upgrade() -> None:
    op.alter_column("posts", "image_url", type_=sa.Text(), existing_nullable=True)

def downgrade() -> None:
    op.alter_column("posts", "image_url", type_=sa.String(length=500), existing_nullable=True)
FILE: backend/alembic/versions/382b9ef7d182_initial_schema.py
"""initial schema

Revision ID: 382b9ef7d182
Revises:
Create Date: 2025-11-28 09:59:03.206082

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa

revision: str = '382b9ef7d182'
down_revision: Union[str, Sequence[str], None] = None
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None

def upgrade() -> None:
    """Upgrade schema."""
    op.create_table('roles',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('name', sa.String(length=50), nullable=False),
    sa.Column('permissions', sa.JSON(), nullable=False),
    sa.PrimaryKeyConstraint('id'),
    sa.UniqueConstraint('name')
    )
    op.create_index(op.f('ix_roles_id'), 'roles', ['id'], unique=False)
    op.create_table('users',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('firebase_uid', sa.String(length=128), nullable=False),
    sa.Column('email', sa.String(length=255), nullable=False),
    sa.Column('username', sa.String(length=50), nullable=False),
    sa.Column('avatar_url', sa.String(length=500), nullable=True),
    sa.Column('bio', sa.String(length=500), nullable=True),
    sa.Column('role_id', sa.Integer(), nullable=False),
    sa.Column('is_active', sa.Boolean(), nullable=False),
    sa.Column('is_banned', sa.Boolean(), nullable=False),
    sa.Column('created_at', sa.DateTime(timezone=True), server_default=sa.text('now()'), nullable=False),
    sa.Column('updated_at', sa.DateTime(timezone=True), nullable=True),
    sa.ForeignKeyConstraint(['role_id'], ['roles.id'], ),
    sa.PrimaryKeyConstraint('id')
    )
    op.create_index(op.f('ix_users_email'), 'users', ['email'], unique=True)
    op.create_index(op.f('ix_users_firebase_uid'), 'users', ['firebase_uid'], unique=True)
    op.create_index(op.f('ix_users_id'), 'users', ['id'], unique=False)
    op.create_index(op.f('ix_users_username'), 'users', ['username'], unique=True)
    op.create_table('notifications',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('user_id', sa.Integer(), nullable=False),
    sa.Column('type', sa.String(length=50), nullable=False),
    sa.Column('message', sa.Text(), nullable=False),
    sa.Column('link', sa.String(length=500), nullable=True),
    sa.Column('is_read', sa.Boolean(), nullable=False),
    sa.Column('created_at', sa.DateTime(timezone=True), server_default=sa.text('now()'), nullable=False),
    sa.ForeignKeyConstraint(['user_id'], ['users.id'], ondelete='CASCADE'),
    sa.PrimaryKeyConstraint('id')
    )
    op.create_index(op.f('ix_notifications_created_at'), 'notifications', ['created_at'], unique=False)
    op.create_index(op.f('ix_notifications_id'), 'notifications', ['id'], unique=False)
    op.create_index(op.f('ix_notifications_is_read'), 'notifications', ['is_read'], unique=False)
    op.create_index(op.f('ix_notifications_user_id'), 'notifications', ['user_id'], unique=False)
    op.create_table('posts',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('user_id', sa.Integer(), nullable=False),
    sa.Column('title', sa.String(length=300), nullable=False),
    sa.Column('image_url', sa.String(length=500), nullable=True),
    sa.Column('tag', sa.String(length=50), nullable=True),
    sa.Column('description', sa.Text(), nullable=True),
    sa.Column('upvotes', sa.Integer(), nullable=False),
    sa.Column('downvotes', sa.Integer(), nullable=False),
    sa.Column('is_locked', sa.Boolean(), nullable=False),
    sa.Column('is_deleted', sa.Boolean(), nullable=False),
    sa.Column('created_at', sa.DateTime(timezone=True), server_default=sa.text('now()'), nullable=False),
    sa.Column('updated_at', sa.DateTime(timezone=True), nullable=True),
    sa.ForeignKeyConstraint(['user_id'], ['users.id'], ondelete='CASCADE'),
    sa.PrimaryKeyConstraint('id')
    )
    op.create_index(op.f('ix_posts_created_at'), 'posts', ['created_at'], unique=False)
    op.create_index(op.f('ix_posts_id'), 'posts', ['id'], unique=False)
    op.create_index(op.f('ix_posts_tag'), 'posts', ['tag'], unique=False)
    op.create_table('comments',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('post_id', sa.Integer(), nullable=False),
    sa.Column('user_id', sa.Integer(), nullable=False),
    sa.Column('parent_id', sa.Integer(), nullable=True),
    sa.Column('content', sa.Text(), nullable=False),
    sa.Column('upvotes', sa.Integer(), nullable=False),
    sa.Column('downvotes', sa.Integer(), nullable=False),
    sa.Column('is_deleted', sa.Boolean(), nullable=False),
    sa.Column('created_at', sa.DateTime(timezone=True), server_default=sa.text('now()'), nullable=False),
    sa.Column('updated_at', sa.DateTime(timezone=True), nullable=True),
    sa.ForeignKeyConstraint(['parent_id'], ['comments.id'], ondelete='CASCADE'),
    sa.ForeignKeyConstraint(['post_id'], ['posts.id'], ondelete='CASCADE'),
    sa.ForeignKeyConstraint(['user_id'], ['users.id'], ondelete='CASCADE'),
    sa.PrimaryKeyConstraint('id')
    )
    op.create_index(op.f('ix_comments_created_at'), 'comments', ['created_at'], unique=False)
    op.create_index(op.f('ix_comments_id'), 'comments', ['id'], unique=False)
    op.create_index(op.f('ix_comments_parent_id'), 'comments', ['parent_id'], unique=False)
    op.create_index(op.f('ix_comments_post_id'), 'comments', ['post_id'], unique=False)
    op.create_table('favorites',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('user_id', sa.Integer(), nullable=False),
    sa.Column('post_id', sa.Integer(), nullable=False),
    sa.Column('created_at', sa.DateTime(timezone=True), server_default=sa.text('now()'), nullable=False),
    sa.ForeignKeyConstraint(['post_id'], ['posts.id'], ondelete='CASCADE'),
    sa.ForeignKeyConstraint(['user_id'], ['users.id'], ondelete='CASCADE'),
    sa.PrimaryKeyConstraint('id')
    )
    op.create_index(op.f('ix_favorites_id'), 'favorites', ['id'], unique=False)
    op.create_table('votes',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('user_id', sa.Integer(), nullable=False),
    sa.Column('post_id', sa.Integer(), nullable=True),
    sa.Column('comment_id', sa.Integer(), nullable=True),
    sa.Column('vote_type', sa.String(length=10), nullable=False),
    sa.Column('created_at', sa.DateTime(timezone=True), server_default=sa.text('now()'), nullable=False),
    sa.ForeignKeyConstraint(['comment_id'], ['comments.id'], ondelete='CASCADE'),
    sa.ForeignKeyConstraint(['post_id'], ['posts.id'], ondelete='CASCADE'),
    sa.ForeignKeyConstraint(['user_id'], ['users.id'], ondelete='CASCADE'),
    sa.PrimaryKeyConstraint('id')
    )
    op.create_index(op.f('ix_votes_id'), 'votes', ['id'], unique=False)

def downgrade() -> None:
    """Downgrade schema."""
    op.drop_index(op.f('ix_votes_id'), table_name='votes')
    op.drop_table('votes')
    op.drop_index(op.f('ix_favorites_id'), table_name='favorites')
    op.drop_table('favorites')
    op.drop_index(op.f('ix_comments_post_id'), table_name='comments')
    op.drop_index(op.f('ix_comments_parent_id'), table_name='comments')
    op.drop_index(op.f('ix_comments_id'), table_name='comments')
    op.drop_index(op.f('ix_comments_created_at'), table_name='comments')
    op.drop_table('comments')
    op.drop_index(op.f('ix_posts_tag'), table_name='posts')
    op.drop_index(op.f('ix_posts_id'), table_name='posts')
    op.drop_index(op.f('ix_posts_created_at'), table_name='posts')
    op.drop_table('posts')
    op.drop_index(op.f('ix_notifications_user_id'), table_name='notifications')
    op.drop_index(op.f('ix_notifications_is_read'), table_name='notifications')
    op.drop_index(op.f('ix_notifications_id'), table_name='notifications')
    op.drop_index(op.f('ix_notifications_created_at'), table_name='notifications')
    op.drop_table('notifications')
    op.drop_index(op.f('ix_users_username'), table_name='users')
    op.drop_index(op.f('ix_users_id'), table_name='users')
    op.drop_index(op.f('ix_users_firebase_uid'), table_name='users')
    op.drop_index(op.f('ix_users_email'), table_name='users')
    op.drop_table('users')
    op.drop_index(op.f('ix_roles_id'), table_name='roles')
    op.drop_table('roles')
FILE: backend/app/api/v1/auth.py
from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session

from app.database import get_db
from app.schemas.auth import RegisterRequest, FirebaseTokenRequest, TokenResponse
from app.services.auth_service import AuthService
from app.dependencies import get_current_user
from app.models.user import User
from app.utils.logger import app_logger

router = APIRouter(prefix="/auth", tags=["Authentication"])

@router.post("/register", response_model=TokenResponse)
async def register(
    register_data: RegisterRequest,
    db: Session = Depends(get_db),
):
    """Register a new user after Firebase authentication."""
    auth_service = AuthService(db)
    return auth_service.register_user(register_data)

@router.post("/login", response_model=TokenResponse)
async def login(
    login_data: FirebaseTokenRequest,
    db: Session = Depends(get_db),
):
    """Login user with Firebase ID token."""
    auth_service = AuthService(db)
    return auth_service.login_user(login_data.id_token)
FILE: backend/app/api/v1/comments.py
from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.orm import Session
from typing import Optional
from app.database import get_db
from app.schemas.comment import CommentCreate, CommentUpdate, CommentResponse, CommentTreeResponse
from app.schemas.post import VoteCreate
from app.services.comment_service import CommentService
from app.dependencies import get_current_user, get_optional_user
from app.models.user import User

router = APIRouter(prefix="/comments", tags=["Comments"])

@router.post("", response_model=CommentResponse, status_code=201)
async def create_comment(
    comment_data: CommentCreate,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Create a new comment or reply."""
    comment_service = CommentService(db)
    return comment_service.create_comment(comment_data, current_user)

@router.get("/post/{post_id}", response_model=CommentTreeResponse)
async def get_post_comments(
    post_id: int,
    current_user: Optional[User] = Depends(get_optional_user),
    db: Session = Depends(get_db)
):
    """Get all comments for a post in tree structure."""
    comment_service = CommentService(db)
    return comment_service.get_post_comments(post_id, current_user)

@router.get("/{comment_id}", response_model=CommentResponse)
async def get_comment(
    comment_id: int,
    current_user: Optional[User] = Depends(get_optional_user),
    db: Session = Depends(get_db)
):
    """Get a specific comment by ID."""
    comment_service = CommentService(db)
    return comment_service.get_comment(comment_id, current_user)

@router.put("/{comment_id}", response_model=CommentResponse)
async def update_comment(
    comment_id: int,
    comment_data: CommentUpdate,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Update a comment."""
    comment_service = CommentService(db)
    return comment_service.update_comment(comment_id, comment_data, current_user)

@router.delete("/{comment_id}")
async def delete_comment(
    comment_id: int,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Delete a comment."""
    comment_service = CommentService(db)
    return comment_service.delete_comment(comment_id, current_user)

@router.post("/{comment_id}/vote", response_model=CommentResponse)
async def vote_comment(
    comment_id: int,
    vote_data: VoteCreate,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Vote on a comment."""
    comment_service = CommentService(db)
    return comment_service.vote_comment(comment_id, vote_data.vote_type, current_user)

@router.delete("/{comment_id}/vote", response_model=CommentResponse)
async def remove_vote(
    comment_id: int,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Remove vote from a comment."""
    comment_service = CommentService(db)
    return comment_service.remove_vote(comment_id, current_user)
FILE: backend/app/api/v1/posts.py
from fastapi import APIRouter, Depends, Query, HTTPException
from sqlalchemy.orm import Session
from typing import Optional
from app.database import get_db
from app.schemas.post import PostCreate, PostUpdate, PostResponse, PostListResponse, VoteCreate
from app.services.post_service import PostService
from app.dependencies import get_current_user, get_optional_user
from app.models.user import User

router = APIRouter(prefix="/posts", tags=["Posts"])

@router.post("", response_model=PostResponse, status_code=201)
async def create_post(
    post_data: PostCreate,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Create a new post."""
    post_service = PostService(db)
    return post_service.create_post(post_data, current_user)

@router.get("", response_model=PostListResponse)
async def get_posts(
    page: int = Query(1, ge=1),
    page_size: int = Query(20, ge=1, le=100),
    tag: Optional[str] = Query(None),
    sort_by: str = Query("new", regex="^(new|hot|top)$"),
    current_user: Optional[User] = Depends(get_optional_user),
    db: Session = Depends(get_db)
):
    """
    Get paginated list of posts.

    - **page**: Page number (starts at 1)
    - **page_size**: Number of posts per page (max 100)
    - **tag**: Filter by tag
    - **sort_by**: Sort by 'new', 'hot', or 'top'
    """
    post_service = PostService(db)
    return post_service.get_posts(page, page_size, tag, sort_by, current_user)

@router.get("/favorites", response_model=PostListResponse)
async def get_favorites(
    page: int = Query(1, ge=1),
    page_size: int = Query(20, ge=1, le=100),
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Get user's favorite posts."""
    post_service = PostService(db)
    return post_service.get_favorites(page, page_size, current_user)

@router.get("/{post_id}", response_model=PostResponse)
async def get_post(
    post_id: int,
    current_user: Optional[User] = Depends(get_optional_user),
    db: Session = Depends(get_db)
):
    """Get a specific post by ID."""
    post_service = PostService(db)
    return post_service.get_post(post_id, current_user)

@router.put("/{post_id}", response_model=PostResponse)
async def update_post(
    post_id: int,
    post_data: PostUpdate,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Update a post."""
    post_service = PostService(db)
    return post_service.update_post(post_id, post_data, current_user)

@router.delete("/{post_id}")
async def delete_post(
    post_id: int,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Delete a post."""
    post_service = PostService(db)
    return post_service.delete_post(post_id, current_user)

@router.post("/{post_id}/vote", response_model=PostResponse)
async def vote_post(
    post_id: int,
    vote_data: VoteCreate,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Vote on a post (upvote or downvote)."""
    post_service = PostService(db)
    return post_service.vote_post(post_id, vote_data, current_user)

@router.delete("/{post_id}/vote", response_model=PostResponse)
async def remove_vote(
    post_id: int,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Remove vote from a post."""
    post_service = PostService(db)
    return post_service.remove_vote(post_id, current_user)

@router.post("/{post_id}/favorite")
async def favorite_post(
    post_id: int,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Add post to favorites."""
    post_service = PostService(db)
    return post_service.add_favorite(post_id, current_user)

@router.delete("/{post_id}/favorite")
async def unfavorite_post(
    post_id: int,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Remove post from favorites."""
    post_service = PostService(db)
    return post_service.remove_favorite(post_id, current_user)

@router.get("/user/{user_id}", response_model=PostListResponse)
async def get_user_posts(
    user_id: int,
    page: int = Query(1, ge=1),
    page_size: int = Query(20, ge=1, le=100),
    current_user: Optional[User] = Depends(get_optional_user),
    db: Session = Depends(get_db)
):
    """Get all posts by a specific user."""
    post_service = PostService(db)
    return post_service.get_user_posts(user_id, page, page_size, current_user)
FILE: backend/app/api/v1/users.py
from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session
from app.database import get_db
from app.schemas.user import UserUpdate, UserResponse, UserProfile
from app.schemas.notification import NotificationListResponse
from app.repositories.user_repository import UserRepository
from app.services.notification_service import NotificationService
from app.dependencies import get_current_user
from app.models.user import User

router = APIRouter(prefix="/users", tags=["Users"])

@router.get("/me", response_model=UserResponse)
async def get_my_profile(current_user: User = Depends(get_current_user)):
    """Get current user's profile."""
    return current_user

@router.put("/me", response_model=UserResponse)
async def update_my_profile(
    user_data: UserUpdate,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Update current user's profile."""
    user_repo = UserRepository(db)
    return user_repo.update(current_user, user_data)

@router.get("/{user_id}", response_model=UserProfile)
async def get_user_profile(
    user_id: int,
    db: Session = Depends(get_db)
):
    """Get public profile of any user."""
    user_repo = UserRepository(db)
    user = user_repo.get_by_id(user_id)

    if not user:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="User not found"
        )

    return user

@router.get("/me/notifications", response_model=NotificationListResponse)
async def get_my_notifications(
    unread_only: bool = False,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Get current user's notifications."""
    notification_service = NotificationService(db)
    return notification_service.get_user_notifications(
        current_user.id,
        unread_only=unread_only
    )

@router.post("/me/notifications/{notification_id}/read")
async def mark_notification_read(
    notification_id: int,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Mark a notification as read."""
    notification_service = NotificationService(db)
    success = notification_service.mark_as_read(notification_id, current_user.id)

    if not success:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Notification not found"
        )

    return {"message": "Notification marked as read"}

@router.post("/me/notifications/read-all")
async def mark_all_notifications_read(
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Mark all notifications as read."""
    notification_service = NotificationService(db)
    count = notification_service.mark_all_as_read(current_user.id)
    return {"message": f"Marked {count} notifications as read"}
FILE: backend/app/api/v1/websocket.py
from fastapi import APIRouter, WebSocket, WebSocketDisconnect, Depends, Query
from sqlalchemy.orm import Session
from app.database import get_db
from app.services.websocket_service import connection_manager
from app.core.security import verify_token
from app.repositories.user_repository import UserRepository
from app.utils.logger import app_logger

router = APIRouter(prefix="/ws", tags=["WebSocket"])

@router.websocket("")
async def websocket_endpoint(
    websocket: WebSocket,
    token: str = Query(...),
    db: Session = Depends(get_db)
):
    """
    WebSocket endpoint for real-time updates.

    Usage from frontend:
    ```javascript
    const ws = new WebSocket('ws://localhost:8000/api/v1/ws?token=YOUR_JWT_TOKEN');
    ```
    """
    try:
        payload = verify_token(token)
        user_id = payload.get("user_id")

        if not user_id:
            await websocket.close(code=1008, reason="Invalid token")
            return

        user_repo = UserRepository(db)
        user = user_repo.get_by_id(user_id)

        if not user or not user.is_active or user.is_banned:
            await websocket.close(code=1008, reason="User not authorized")
            return

        await connection_manager.connect(websocket, user_id)

        try:
            await websocket.send_json({
                "type": "connection",
                "message": "Connected to real-time updates",
                "user_id": user_id
            })

            while True:
                data = await websocket.receive_text()

                await websocket.send_json({
                    "type": "echo",
                    "message": data
                })

        except WebSocketDisconnect:
            connection_manager.disconnect(websocket, user_id)
            app_logger.info(f"WebSocket disconnected: User {user_id}")

    except Exception as e:
        app_logger.error(f"WebSocket error: {e}")
        try:
            await websocket.close(code=1011, reason="Internal server error")
        except:
            pass
FILE: backend/app/config.py
from pydantic_settings import BaseSettings, SettingsConfigDict
from typing import List, Optional

class Settings(BaseSettings):
    """Application settings loaded from environment variables."""

    APP_NAME: str = "MemeForum"
    APP_VERSION: str = "1.0.0"
    DEBUG: bool = True
    ENVIRONMENT: str = "development"

    HOST: str = "0.0.0.0"
    PORT: int = 8000

    DATABASE_URL: str
    DB_ECHO: bool = False

    REDIS_HOST: str = "localhost"
    REDIS_PORT: int = 6379
    REDIS_DB: int = 0
    REDIS_PASSWORD: str = ""

    FIREBASE_CREDENTIALS_PATH: Optional[str] = None
    FIREBASE_PROJECT_ID: Optional[str] = None

    SECRET_KEY: str
    ALGORITHM: str = "HS256"
    ACCESS_TOKEN_EXPIRE_MINUTES: int = 30

    CORS_ORIGINS: List[str] = ["http://localhost:4200"]

    MAX_FILE_SIZE: int = 10485760
    ALLOWED_FILE_TYPES: List[str] = [
        "image/jpeg",
        "image/png",
        "image/gif",
        "image/webp"
    ]
    UPLOAD_DIR: str = "./uploads"

    RATE_LIMIT_PER_MINUTE: int = 60

    LOG_LEVEL: str = "INFO"
    LOG_FILE: str = "logs/app.log"

    model_config = SettingsConfigDict(
        env_file=".env",
        case_sensitive=True,
        extra="ignore"
    )

    @property
    def redis_url(self) -> str:
        """Construct Redis URL."""
        if self.REDIS_PASSWORD:
            return f"redis://:{self.REDIS_PASSWORD}@{self.REDIS_HOST}:{self.REDIS_PORT}/{self.REDIS_DB}"
        return f"redis://{self.REDIS_HOST}:{self.REDIS_PORT}/{self.REDIS_DB}"

settings = Settings()
FILE: backend/app/core/firebase_auth.py
from functools import lru_cache
from typing import Any, Dict

import firebase_admin
from firebase_admin import auth as firebase_auth, credentials

from app.config import settings
from app.utils.logger import app_logger

@lru_cache(maxsize=1)
def _initialize_firebase() -> None:
    if firebase_admin._apps:
        return

    if settings.FIREBASE_CREDENTIALS_PATH:
        cred = credentials.Certificate(settings.FIREBASE_CREDENTIALS_PATH)
        firebase_admin.initialize_app(cred, {"projectId": settings.FIREBASE_PROJECT_ID})
    else:
        firebase_admin.initialize_app()

def verify_firebase_id_token(id_token: str) -> Dict[str, Any]:
    """
    Validate a Firebase ID token and return its claims.

    Raises:
        ValueError: when token is invalid.
    """
    _initialize_firebase()
    try:
        return firebase_auth.verify_id_token(id_token)
    except Exception as exc:
        app_logger.error(f"Firebase token verification failed: {exc}")
        raise ValueError("Invalid Firebase ID token") from exc
FILE: backend/app/core/permissions.py
from typing import List
from functools import wraps
from fastapi import HTTPException, status
from app.models.user import User
from app.utils.logger import app_logger

PERMISSIONS = {
    'user': [
        'post:create',
        'post:edit:own',
        'post:delete:own',
        'comment:create',
        'comment:edit:own',
        'comment:delete:own',
        'vote:create',
        'favorite:manage',
    ],
    'moderator': [
        'post:create',
        'post:edit:own',
        'post:delete:own',
        'comment:create',
        'comment:edit:own',
        'comment:delete:own',
        'comment:delete:any',
        'vote:create',
        'favorite:manage',
        'user:ban:comment',
        'thread:lock',
        'reports:view',
    ],
    'admin': [
        'post:create',
        'post:edit:own',
        'post:edit:any',
        'post:delete:own',
        'post:delete:any',
        'post:lock',
        'comment:create',
        'comment:edit:own',
        'comment:edit:any',
        'comment:delete:own',
        'comment:delete:any',
        'vote:create',
        'favorite:manage',
        'user:ban:platform',
        'user:ban:comment',
        'moderator:manage',
        'logs:view',
        'reports:view',
    ]
}

def get_user_permissions(user: User) -> List[str]:
    """
    Get all permissions for a user based on their role.

    Args:
        user: User model instance

    Returns:
        List of permission strings
    """
    if not user.role:
        return PERMISSIONS.get('user', [])

    role_name = user.role.name.lower()
    return PERMISSIONS.get(role_name, [])

def has_permission(user: User, permission: str) -> bool:
    """
    Check if user has specific permission.

    Args:
        user: User model instance
        permission: Permission string (e.g., 'post:delete:any')

    Returns:
        True if user has permission, False otherwise
    """
    if not user.is_active or user.is_banned:
        return False

    user_permissions = get_user_permissions(user)
    return permission in user_permissions

def require_permission(permission: str):
    """
    Decorator to require specific permission for endpoint.

    Usage:
        @router.delete("/posts/{post_id}")
        @require_permission("post:delete:any")
        async def delete_post(post_id: int, current_user: User = Depends(get_current_user)):
            ...
    """
    def decorator(func):
        @wraps(func)
        async def wrapper(*args, **kwargs):
            current_user = kwargs.get('current_user')

            if not current_user:
                raise HTTPException(
                    status_code=status.HTTP_401_UNAUTHORIZED,
                    detail="Authentication required"
                )

            if not has_permission(current_user, permission):
                app_logger.warning(
                    f"User {current_user.id} denied permission: {permission}"
                )
                raise HTTPException(
                    status_code=status.HTTP_403_FORBIDDEN,
                    detail=f"You don't have permission to perform this action"
                )

            return await func(*args, **kwargs)

        return wrapper
    return decorator

def check_resource_ownership(user: User, resource_user_id: int) -> bool:
    """
    Check if user owns the resource or has admin privileges.

    Args:
        user: Current user
        resource_user_id: User ID of resource owner

    Returns:
        True if user owns resource or is admin
    """
    if user.id == resource_user_id:
        return True

    return has_permission(user, 'post:edit:any')
FILE: backend/app/core/redis_client.py
import redis
from redis import Redis
from typing import Optional
from app.config import settings
from app.utils.logger import app_logger

class RedisClient:
    """Redis client wrapper for caching and pub/sub."""

    def __init__(self):
        self._client: Optional[Redis] = None

    def connect(self):
        """Establish Redis connection."""
        try:
            self._client = redis.from_url(
                settings.redis_url,
                decode_responses=True,
                socket_connect_timeout=5,
                socket_keepalive=True,
            )
            self._client.ping()
            app_logger.info(f"Redis connected: {settings.REDIS_HOST}:{settings.REDIS_PORT}")
        except Exception as e:
            app_logger.error(f"Redis connection failed: {e}")
            raise

    def disconnect(self):
        """Close Redis connection."""
        if self._client:
            self._client.close()
            app_logger.info("Redis disconnected")

    @property
    def client(self) -> Redis:
        """Get Redis client instance."""
        if not self._client:
            self.connect()
        return self._client

    def set_cache(self, key: str, value: str, expire: int = 300):
        """Set cache with expiration (default 5 minutes)."""
        return self.client.setex(key, expire, value)

    def get_cache(self, key: str) -> Optional[str]:
        """Get cached value."""
        return self.client.get(key)

    def delete_cache(self, key: str):
        """Delete cache key."""
        return self.client.delete(key)

    def exists(self, key: str) -> bool:
        """Check if key exists."""
        return bool(self.client.exists(key))

    def publish(self, channel: str, message: str):
        """Publish message to channel."""
        return self.client.publish(channel, message)

    def subscribe(self, channel: str):
        """Subscribe to channel."""
        pubsub = self.client.pubsub()
        pubsub.subscribe(channel)
        return pubsub

    def add_to_stream(self, stream: str, data: dict) -> str:
        """Add message to Redis stream."""
        return self.client.xadd(stream, data)

    def read_stream(self, stream: str, count: int = 10, block: int = 1000):
        """Read messages from stream."""
        return self.client.xread({stream: '0'}, count=count, block=block)

    def add_to_set(self, key: str, value: str):
        """Add value to set."""
        return self.client.sadd(key, value)

    def remove_from_set(self, key: str, value: str):
        """Remove value from set."""
        return self.client.srem(key, value)

    def get_set_members(self, key: str):
        """Get all members of set."""
        return self.client.smembers(key)

redis_client = RedisClient()
FILE: backend/app/core/security.py
from datetime import datetime, timedelta
from typing import Optional
from jose import JWTError, jwt
from passlib.context import CryptContext
from fastapi import HTTPException, status, Depends
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from sqlalchemy.orm import Session
from app.config import settings
from app.database import get_db
from app.models.user import User
from app.utils.logger import app_logger

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

bearer_scheme = HTTPBearer()

def create_access_token(data: dict, expires_delta: Optional[timedelta] = None) -> str:
    """
    Create JWT access token.

    Args:
        data: Dictionary to encode in token
        expires_delta: Token expiration time

    Returns:
        Encoded JWT token
    """
    to_encode = data.copy()

    if expires_delta:
        expire = datetime.utcnow() + expires_delta
    else:
        expire = datetime.utcnow() + timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)

    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(to_encode, settings.SECRET_KEY, algorithm=settings.ALGORITHM)

    return encoded_jwt

def verify_token(token: str) -> dict:
    """
    Verify and decode JWT token.

    Args:
        token: JWT token string

    Returns:
        Decoded token payload

    Raises:
        HTTPException: If token is invalid
    """
    try:
        payload = jwt.decode(token, settings.SECRET_KEY, algorithms=[settings.ALGORITHM])
        return payload
    except JWTError as e:
        app_logger.error(f"Token verification failed: {e}")
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Could not validate credentials",
            headers={"WWW-Authenticate": "Bearer"},
        )

def verify_password(plain_password: str, hashed_password: str) -> bool:
    """Verify password against hash."""
    return pwd_context.verify(plain_password, hashed_password)

def get_password_hash(password: str) -> str:
    """Hash password."""
    return pwd_context.hash(password)
FILE: backend/app/database.py
from sqlalchemy import create_engine
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker, Session
from typing import Generator
from app.config import settings
from app.utils.logger import app_logger

engine = create_engine(
    settings.DATABASE_URL,
    echo=settings.DB_ECHO,
    pool_pre_ping=True,
    pool_size=10,
    max_overflow=20,
)

SessionLocal = sessionmaker(
    autocommit=False,
    autoflush=False,
    bind=engine
)

Base = declarative_base()

def get_db() -> Generator[Session, None, None]:
    """
    Dependency function to get database session.

    Usage in FastAPI:
        @router.get("/items")
        def get_items(db: Session = Depends(get_db)):
            ...
    """
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

def init_db():
    """Initialize database - create all tables."""
    from app.models import user, role, post, comment, notification

    app_logger.info("Creating database tables...")
    Base.metadata.create_all(bind=engine)
    app_logger.info("Database tables created successfully")
FILE: backend/app/dependencies.py
from typing import Optional
from fastapi import Depends, HTTPException, status
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from sqlalchemy.orm import Session
from app.database import get_db
from app.core.security import verify_token
from app.models.user import User
from app.utils.logger import app_logger

bearer_scheme = HTTPBearer()

async def get_current_user(
    credentials: HTTPAuthorizationCredentials = Depends(bearer_scheme),
    db: Session = Depends(get_db)
) -> User:
    """
    Dependency to get current authenticated user.

    Usage:
        @router.get("/me")
        async def get_me(current_user: User = Depends(get_current_user)):
            return current_user
    """
    token = credentials.credentials

    payload = verify_token(token)
    user_id: int = payload.get("user_id")

    if user_id is None:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid authentication credentials"
        )

    user = db.query(User).filter(User.id == user_id).first()

    if user is None:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="User not found"
        )

    if not user.is_active:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="User account is inactive"
        )

    if user.is_banned:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="User account is banned"
        )

    return user

async def get_optional_user(
    credentials: Optional[HTTPAuthorizationCredentials] = Depends(bearer_scheme),
    db: Session = Depends(get_db)
) -> Optional[User]:
    """
    Dependency to get current user if authenticated, None otherwise.
    Useful for endpoints that work with or without authentication.
    """
    if not credentials:
        return None

    try:
        return await get_current_user(credentials, db)
    except HTTPException:
        return None
FILE: backend/app/main.py
import asyncio
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from contextlib import asynccontextmanager
from app.config import settings
from app.database import init_db
from app.core.redis_client import redis_client
from app.middleware.logging import LoggingMiddleware
from app.middleware.rate_limit import RateLimitMiddleware
from app.utils.logger import app_logger

from app.services.notification_stream import (
    notification_stream_worker,
    stop_notification_worker,
)

from app.api.v1 import auth, posts, comments, users, websocket

@asynccontextmanager
async def lifespan(app: FastAPI):
    """Startup and shutdown events."""
    app_logger.info("Starting %s v%s", settings.APP_NAME, settings.APP_VERSION)

    init_db()

    notification_task = None
    try:
        redis_client.connect()
        notification_task = asyncio.create_task(notification_stream_worker())
    except Exception as exc:
        app_logger.error(f"Redis initialization failed: {exc}")

    app_logger.info("Application started successfully")
    try:
        yield
    finally:
        app_logger.info("Shutting down application")
        await stop_notification_worker(notification_task)
        redis_client.disconnect()

app = FastAPI(
    title=settings.APP_NAME,
    version=settings.APP_VERSION,
    description="Real-time meme sharing forum API",
    lifespan=lifespan
)

app.add_middleware(
    CORSMiddleware,
    allow_origins=settings.CORS_ORIGINS,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

app.add_middleware(LoggingMiddleware)
app.add_middleware(RateLimitMiddleware)

app.include_router(auth.router, prefix="/api/v1")
app.include_router(posts.router, prefix="/api/v1")
app.include_router(comments.router, prefix="/api/v1")
app.include_router(users.router, prefix="/api/v1")
app.include_router(websocket.router, prefix="/api/v1")

@app.get("/")
async def root():
    """Root endpoint."""
    return {
        "message": f"Welcome to {settings.APP_NAME}",
        "version": settings.APP_VERSION,
        "docs": "/docs"
    }

@app.get("/health")
async def health_check():
    """Health check endpoint."""
    return {
        "status": "healthy",
        "app": settings.APP_NAME,
        "version": settings.APP_VERSION,
        "environment": settings.ENVIRONMENT
    }
FILE: backend/app/middleware/logging.py
from fastapi import Request
from starlette.middleware.base import BaseHTTPMiddleware
from app.utils.logger import app_logger
import time

class LoggingMiddleware(BaseHTTPMiddleware):
    """Middleware to log all HTTP requests."""

    async def dispatch(self, request: Request, call_next):
        start_time = time.time()

        app_logger.info(
            f"Request: {request.method} {request.url.path} "
            f"from {request.client.host if request.client else 'unknown'}"
        )

        response = await call_next(request)

        process_time = time.time() - start_time

        app_logger.info(
            f"Response: {response.status_code} "
            f"for {request.method} {request.url.path} "
            f"in {process_time:.3f}s"
        )

        response.headers["X-Process-Time"] = str(process_time)

        return response
FILE: backend/app/middleware/rate_limit.py
from fastapi import Request, HTTPException, status
from starlette.middleware.base import BaseHTTPMiddleware
from app.core.redis_client import redis_client
from app.config import settings
from app.utils.logger import app_logger
import time

class RateLimitMiddleware(BaseHTTPMiddleware):
    """Simple rate limiting middleware using Redis."""

    async def dispatch(self, request: Request, call_next):
        if request.url.path == "/health":
            return await call_next(request)

        client_ip = request.client.host if request.client else "unknown"

        rate_limit_key = f"rate_limit:{client_ip}:{int(time.time() / 60)}"

        try:
            current_count = redis_client.get_cache(rate_limit_key)

            if current_count is None:
                redis_client.set_cache(rate_limit_key, "1", expire=60)
            else:
                count = int(current_count)

                if count >= settings.RATE_LIMIT_PER_MINUTE:
                    app_logger.warning(f"Rate limit exceeded for {client_ip}")
                    raise HTTPException(
                        status_code=status.HTTP_429_TOO_MANY_REQUESTS,
                        detail="Too many requests. Please try again later."
                    )

                redis_client.client.incr(rate_limit_key)

        except HTTPException:
            raise
        except Exception as e:
            app_logger.error(f"Rate limit check failed: {e}")

        return await call_next(request)
FILE: backend/app/models/comment.py
from sqlalchemy import Column, Integer, String, Text, DateTime, ForeignKey, Boolean
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func
from app.database import Base

class Comment(Base):
    __tablename__ = "comments"

    id = Column(Integer, primary_key=True, index=True)
    post_id = Column(Integer, ForeignKey("posts.id", ondelete="CASCADE"), nullable=False, index=True)
    user_id = Column(Integer, ForeignKey("users.id", ondelete="CASCADE"), nullable=False)
    parent_id = Column(Integer, ForeignKey("comments.id", ondelete="CASCADE"), nullable=True, index=True)

    content = Column(Text, nullable=False)

    upvotes = Column(Integer, default=0, nullable=False)
    downvotes = Column(Integer, default=0, nullable=False)

    is_deleted = Column(Boolean, default=False, nullable=False)

    created_at = Column(DateTime(timezone=True), server_default=func.now(), nullable=False, index=True)
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())

    post = relationship("Post", back_populates="comments")
    author = relationship("User", back_populates="comments")

    replies = relationship(
        "Comment",
        backref="parent",
        remote_side=[id],
        cascade="all, delete-orphan",
        single_parent=True,
    )

    votes = relationship("Vote", back_populates="comment", cascade="all, delete-orphan")

    def __repr__(self):
        return f"<Comment {self.id} on Post {self.post_id}>"
FILE: backend/app/models/notification.py
from sqlalchemy import Column, Integer, String, Text, DateTime, ForeignKey, Boolean
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func
from app.database import Base

class Notification(Base):
    __tablename__ = "notifications"

    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id", ondelete="CASCADE"), nullable=False, index=True)

    type = Column(String(50), nullable=False)
    message = Column(Text, nullable=False)
    link = Column(String(500), nullable=True)

    is_read = Column(Boolean, default=False, nullable=False, index=True)

    created_at = Column(DateTime(timezone=True), server_default=func.now(), nullable=False, index=True)

    user = relationship("User", back_populates="notifications")

    def __repr__(self):
        return f"<Notification {self.id} for user {self.user_id}>"
FILE: backend/app/models/post.py
from sqlalchemy import Column, Integer, String, Text, DateTime, ForeignKey, Boolean
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func
from app.database import Base

class Post(Base):
    __tablename__ = "posts"

    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id", ondelete="CASCADE"), nullable=False)

    title = Column(String(300), nullable=False)
    image_url = Column(Text, nullable=True)
    tag = Column(String(50), nullable=True, index=True)
    description = Column(Text, nullable=True)

    upvotes = Column(Integer, default=0, nullable=False)
    downvotes = Column(Integer, default=0, nullable=False)

    is_locked = Column(Boolean, default=False, nullable=False)
    is_deleted = Column(Boolean, default=False, nullable=False)

    created_at = Column(DateTime(timezone=True), server_default=func.now(), nullable=False, index=True)
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())

    author = relationship("User", back_populates="posts")
    comments = relationship("Comment", back_populates="post", cascade="all, delete-orphan")
    votes = relationship("Vote", back_populates="post", cascade="all, delete-orphan")
    favorites = relationship("Favorite", back_populates="post", cascade="all, delete-orphan")

    def __repr__(self):
        return f"<Post {self.id}: {self.title[:30]}>"

class Vote(Base):
    __tablename__ = "votes"

    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id", ondelete="CASCADE"), nullable=False)
    post_id = Column(Integer, ForeignKey("posts.id", ondelete="CASCADE"), nullable=True)
    comment_id = Column(Integer, ForeignKey("comments.id", ondelete="CASCADE"), nullable=True)
    vote_type = Column(String(10), nullable=False)

    created_at = Column(DateTime(timezone=True), server_default=func.now(), nullable=False)

    post = relationship("Post", back_populates="votes")
    comment = relationship("Comment", back_populates="votes")

    def __repr__(self):
        return f"<Vote {self.vote_type} by user {self.user_id}>"

class Favorite(Base):
    __tablename__ = "favorites"

    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id", ondelete="CASCADE"), nullable=False)
    post_id = Column(Integer, ForeignKey("posts.id", ondelete="CASCADE"), nullable=False)

    created_at = Column(DateTime(timezone=True), server_default=func.now(), nullable=False)

    post = relationship("Post", back_populates="favorites")

    def __repr__(self):
        return f"<Favorite user={self.user_id} post={self.post_id}>"
FILE: backend/app/models/role.py
from sqlalchemy import Column, Integer, String, JSON
from app.database import Base

class Role(Base):
    __tablename__ = "roles"

    id = Column(Integer, primary_key=True, index=True)
    name = Column(String(50), unique=True, nullable=False)
    permissions = Column(JSON, nullable=False, default=list)

    def __repr__(self):
        return f"<Role {self.name}>"
FILE: backend/app/models/user.py
from sqlalchemy import Column, Integer, String, DateTime, ForeignKey, Boolean
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func
from app.database import Base

class User(Base):
    __tablename__ = "users"

    id = Column(Integer, primary_key=True, index=True)
    firebase_uid = Column(String(128), unique=True, nullable=False, index=True)
    email = Column(String(255), unique=True, nullable=False, index=True)
    username = Column(String(50), unique=True, nullable=False, index=True)
    avatar_url = Column(String(500), nullable=True)
    bio = Column(String(500), nullable=True)

    role_id = Column(Integer, ForeignKey("roles.id"), nullable=False, default=3)
    role = relationship("Role", backref="users")

    is_active = Column(Boolean, default=True, nullable=False)
    is_banned = Column(Boolean, default=False, nullable=False)

    created_at = Column(DateTime(timezone=True), server_default=func.now(), nullable=False)
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())

    posts = relationship("Post", back_populates="author", cascade="all, delete-orphan")
    comments = relationship("Comment", back_populates="author", cascade="all, delete-orphan")
    notifications = relationship("Notification", back_populates="user", cascade="all, delete-orphan")

    def __repr__(self):
        return f"<User {self.username}>"
FILE: backend/app/repositories/comment_repository.py
from typing import Optional, List
from sqlalchemy.orm import Session, joinedload
from sqlalchemy import desc
from app.models.comment import Comment
from app.models.post import Vote
from app.schemas.comment import CommentCreate, CommentUpdate
from app.utils.logger import app_logger

class CommentRepository:
    """Repository for Comment database operations."""

    def __init__(self, db: Session):
        self.db = db

    def create(self, comment_data: CommentCreate, user_id: int) -> Comment:
        """Create a new comment."""
        comment = Comment(
            post_id=comment_data.post_id,
            user_id=user_id,
            parent_id=comment_data.parent_id,
            content=comment_data.content
        )
        self.db.add(comment)
        self.db.commit()
        self.db.refresh(comment)
        app_logger.info(f"Comment created: ID {comment.id} on post {comment.post_id}")
        return comment

    def get_by_id(self, comment_id: int, include_deleted: bool = False) -> Optional[Comment]:
        """Get comment by ID."""
        query = self.db.query(Comment).options(joinedload(Comment.author)).filter(
            Comment.id == comment_id
        )

        if not include_deleted:
            query = query.filter(Comment.is_deleted == False)

        return query.first()

    def get_by_post(self, post_id: int, parent_id: Optional[int] = None) -> List[Comment]:
        """Get comments for a post (optionally filtered by parent)."""
        query = self.db.query(Comment).options(joinedload(Comment.author)).filter(
            Comment.post_id == post_id,
            Comment.is_deleted == False
        )

        if parent_id is not None:
            query = query.filter(Comment.parent_id == parent_id)
        else:
            query = query.filter(Comment.parent_id.is_(None))

        return query.order_by(Comment.created_at).all()

    def get_comment_tree(self, post_id: int) -> List[Comment]:
        """Get nested comment tree for a post using recursive query."""
        from sqlalchemy import text

        query = text("""
            WITH RECURSIVE comment_tree AS (
                -- Base case: top-level comments
                SELECT c.*, u.username as author_username, u.avatar_url as author_avatar
                FROM comments c
                JOIN users u ON c.user_id = u.id
                WHERE c.post_id = :post_id AND c.parent_id IS NULL AND c.is_deleted = FALSE

                UNION ALL

                -- Recursive case: child comments
                SELECT c.*, u.username as author_username, u.avatar_url as author_avatar
                FROM comments c
                JOIN users u ON c.user_id = u.id
                INNER JOIN comment_tree ct ON c.parent_id = ct.id
                WHERE c.is_deleted = FALSE
            )
            SELECT * FROM comment_tree ORDER BY created_at;
        """)

        result = self.db.execute(query, {"post_id": post_id})
        return result.fetchall()

    def count_by_post(self, post_id: int) -> int:
        """Count comments on a post."""
        return self.db.query(Comment).filter(
            Comment.post_id == post_id,
            Comment.is_deleted == False
        ).count()

    def update(self, comment: Comment, comment_data: CommentUpdate) -> Comment:
        """Update comment."""
        comment.content = comment_data.content
        self.db.commit()
        self.db.refresh(comment)
        app_logger.info(f"Comment updated: ID {comment.id}")
        return comment

    def soft_delete(self, comment: Comment) -> Comment:
        """Soft delete comment."""
        comment.is_deleted = True
        comment.content = "[deleted]"
        self.db.commit()
        self.db.refresh(comment)
        app_logger.info(f"Comment soft deleted: ID {comment.id}")
        return comment

    def get_user_vote(self, comment_id: int, user_id: int) -> Optional[Vote]:
        """Get user's vote on a comment."""
        return self.db.query(Vote).filter(
            Vote.comment_id == comment_id,
            Vote.user_id == user_id
        ).first()

    def create_vote(self, comment_id: int, user_id: int, vote_type: str) -> Vote:
        """Create or update vote on comment."""
        existing_vote = self.get_user_vote(comment_id, user_id)

        if existing_vote:
            old_type = existing_vote.vote_type
            existing_vote.vote_type = vote_type

            comment = self.get_by_id(comment_id, include_deleted=True)
            if old_type == "up":
                comment.upvotes -= 1
            else:
                comment.downvotes -= 1

            if vote_type == "up":
                comment.upvotes += 1
            else:
                comment.downvotes += 1

            self.db.commit()
            return existing_vote

        vote = Vote(comment_id=comment_id, user_id=user_id, vote_type=vote_type)
        self.db.add(vote)

        comment = self.get_by_id(comment_id, include_deleted=True)
        if vote_type == "up":
            comment.upvotes += 1
        else:
            comment.downvotes += 1

        self.db.commit()
        self.db.refresh(vote)
        app_logger.info(f"Vote created: {vote_type} on comment {comment_id}")
        return vote

    def remove_vote(self, comment_id: int, user_id: int) -> None:
        """Remove vote from comment."""
        vote = self.get_user_vote(comment_id, user_id)
        if vote:
            comment = self.get_by_id(comment_id, include_deleted=True)
            if vote.vote_type == "up":
                comment.upvotes -= 1
            else:
                comment.downvotes -= 1

            self.db.delete(vote)
            self.db.commit()
            app_logger.info(f"Vote removed from comment {comment_id}")
FILE: backend/app/repositories/post_repository.py
from typing import Optional, List
from sqlalchemy.orm import Session, joinedload
from sqlalchemy import desc, or_
from app.models.post import Post, Vote, Favorite
from app.models.user import User
from app.schemas.post import PostCreate, PostUpdate
from app.utils.logger import app_logger

class PostRepository:
    """Repository for Post database operations."""

    def __init__(self, db: Session):
        self.db = db

    def create(self, post_data: PostCreate, user_id: int) -> Post:
        """Create a new post."""
        post = Post(
            user_id=user_id,
            title=post_data.title,
            description=post_data.description,
            tag=post_data.tag,
            image_url=post_data.image_url
        )
        self.db.add(post)
        self.db.commit()
        self.db.refresh(post)
        app_logger.info(f"Post created: ID {post.id} by user {user_id}")
        return post

    def get_by_id(self, post_id: int, include_deleted: bool = False) -> Optional[Post]:
        """Get post by ID."""
        query = self.db.query(Post).options(joinedload(Post.author)).filter(Post.id == post_id)

        if not include_deleted:
            query = query.filter(Post.is_deleted == False)

        return query.first()

    def get_all(
        self,
        skip: int = 0,
        limit: int = 20,
        tag: Optional[str] = None,
        user_id: Optional[int] = None,
        sort_by: str = "new"
    ) -> List[Post]:
        """Get all posts with filters and pagination."""
        query = self.db.query(Post).options(joinedload(Post.author)).filter(
            Post.is_deleted == False
        )

        if tag:
            query = query.filter(Post.tag == tag)

        if user_id:
            query = query.filter(Post.user_id == user_id)

        if sort_by == "new":
            query = query.order_by(desc(Post.created_at))
        elif sort_by == "hot":
            query = query.order_by(desc(Post.upvotes - Post.downvotes))
        elif sort_by == "top":
            query = query.order_by(desc(Post.upvotes))

        return query.offset(skip).limit(limit).all()

    def count_all(self, tag: Optional[str] = None, user_id: Optional[int] = None) -> int:
        """Count total posts with filters."""
        query = self.db.query(Post).filter(Post.is_deleted == False)

        if tag:
            query = query.filter(Post.tag == tag)

        if user_id:
            query = query.filter(Post.user_id == user_id)

        return query.count()

    def search(self, query_text: str, skip: int = 0, limit: int = 20) -> List[Post]:
        """Search posts by title or description."""
        search_filter = or_(
            Post.title.ilike(f"%{query_text}%"),
            Post.description.ilike(f"%{query_text}%")
        )

        return self.db.query(Post).options(joinedload(Post.author)).filter(
            Post.is_deleted == False,
            search_filter
        ).order_by(desc(Post.created_at)).offset(skip).limit(limit).all()

    def update(self, post: Post, post_data: PostUpdate) -> Post:
        """Update post."""
        update_data = post_data.model_dump(exclude_unset=True)

        for field, value in update_data.items():
            setattr(post, field, value)

        self.db.commit()
        self.db.refresh(post)
        app_logger.info(f"Post updated: ID {post.id}")
        return post

    def soft_delete(self, post: Post) -> Post:
        """Soft delete post."""
        post.is_deleted = True
        self.db.commit()
        self.db.refresh(post)
        app_logger.info(f"Post soft deleted: ID {post.id}")
        return post

    def lock_post(self, post: Post) -> Post:
        """Lock post (prevent new comments)."""
        post.is_locked = True
        self.db.commit()
        self.db.refresh(post)
        app_logger.info(f"Post locked: ID {post.id}")
        return post

    def unlock_post(self, post: Post) -> Post:
        """Unlock post."""
        post.is_locked = False
        self.db.commit()
        self.db.refresh(post)
        app_logger.info(f"Post unlocked: ID {post.id}")
        return post

    def get_user_vote(self, post_id: int, user_id: int) -> Optional[Vote]:
        """Get user's vote on a post."""
        return self.db.query(Vote).filter(
            Vote.post_id == post_id,
            Vote.user_id == user_id
        ).first()

    def create_vote(self, post_id: int, user_id: int, vote_type: str) -> Vote:
        """Create or update vote."""
        existing_vote = self.get_user_vote(post_id, user_id)

        if existing_vote:
            old_type = existing_vote.vote_type
            existing_vote.vote_type = vote_type

            post = self.get_by_id(post_id, include_deleted=True)
            if old_type == "up":
                post.upvotes -= 1
            else:
                post.downvotes -= 1

            if vote_type == "up":
                post.upvotes += 1
            else:
                post.downvotes += 1

            self.db.commit()
            return existing_vote

        vote = Vote(post_id=post_id, user_id=user_id, vote_type=vote_type)
        self.db.add(vote)

        post = self.get_by_id(post_id, include_deleted=True)
        if vote_type == "up":
            post.upvotes += 1
        else:
            post.downvotes += 1

        self.db.commit()
        self.db.refresh(vote)
        app_logger.info(f"Vote created: {vote_type} on post {post_id} by user {user_id}")
        return vote

    def remove_vote(self, post_id: int, user_id: int) -> None:
        """Remove vote."""
        vote = self.get_user_vote(post_id, user_id)
        if vote:
            post = self.get_by_id(post_id, include_deleted=True)
            if vote.vote_type == "up":
                post.upvotes -= 1
            else:
                post.downvotes -= 1

            self.db.delete(vote)
            self.db.commit()
            app_logger.info(f"Vote removed from post {post_id} by user {user_id}")

    def add_favorite(self, post_id: int, user_id: int) -> Favorite:
        """Add post to favorites."""
        existing = self.db.query(Favorite).filter(
            Favorite.post_id == post_id,
            Favorite.user_id == user_id
        ).first()

        if existing:
            return existing

        favorite = Favorite(post_id=post_id, user_id=user_id)
        self.db.add(favorite)
        self.db.commit()
        self.db.refresh(favorite)
        app_logger.info(f"Post {post_id} favorited by user {user_id}")
        return favorite

    def remove_favorite(self, post_id: int, user_id: int) -> None:
        """Remove post from favorites."""
        favorite = self.db.query(Favorite).filter(
            Favorite.post_id == post_id,
            Favorite.user_id == user_id
        ).first()

        if favorite:
            self.db.delete(favorite)
            self.db.commit()
            app_logger.info(f"Post {post_id} unfavorited by user {user_id}")

    def is_favorited(self, post_id: int, user_id: int) -> bool:
        """Check if post is favorited by user."""
        return self.db.query(Favorite).filter(
            Favorite.post_id == post_id,
            Favorite.user_id == user_id
        ).first() is not None

    def get_user_favorites(self, user_id: int, skip: int = 0, limit: int = 20) -> List[Post]:
        """Get user's favorite posts."""
        return self.db.query(Post).join(Favorite).options(joinedload(Post.author)).filter(
            Favorite.user_id == user_id,
            Post.is_deleted == False
        ).order_by(desc(Favorite.created_at)).offset(skip).limit(limit).all()
FILE: backend/app/repositories/user_repository.py
from typing import Optional, List
from sqlalchemy.orm import Session, joinedload
from app.models.user import User
from app.models.role import Role
from app.schemas.user import UserCreate, UserUpdate
from app.utils.logger import app_logger

class UserRepository:
    """Repository for User database operations."""

    def __init__(self, db: Session):
        self.db = db

    def create(self, user_data: UserCreate) -> User:
        """Create a new user."""
        user = User(
            firebase_uid=user_data.firebase_uid,
            email=user_data.email,
            username=user_data.username,
            avatar_url=user_data.avatar_url,
            role_id=3
        )
        self.db.add(user)
        self.db.commit()
        self.db.refresh(user)
        app_logger.info(f"User created: {user.username} (ID: {user.id})")
        return user

    def get_by_id(self, user_id: int) -> Optional[User]:
        """Get user by ID."""
        return self.db.query(User).options(joinedload(User.role)).filter(User.id == user_id).first()

    def get_by_firebase_uid(self, firebase_uid: str) -> Optional[User]:
        """Get user by Firebase UID."""
        return self.db.query(User).options(joinedload(User.role)).filter(
            User.firebase_uid == firebase_uid
        ).first()

    def get_by_email(self, email: str) -> Optional[User]:
        """Get user by email."""
        return self.db.query(User).options(joinedload(User.role)).filter(
            User.email == email
        ).first()

    def get_by_username(self, username: str) -> Optional[User]:
        """Get user by username."""
        return self.db.query(User).options(joinedload(User.role)).filter(
            User.username == username
        ).first()

    def update(self, user: User, user_data: UserUpdate) -> User:
        """Update user information."""
        update_data = user_data.model_dump(exclude_unset=True)

        for field, value in update_data.items():
            setattr(user, field, value)

        self.db.commit()
        self.db.refresh(user)
        app_logger.info(f"User updated: {user.username} (ID: {user.id})")
        return user

    def ban_user(self, user: User) -> User:
        """Ban a user."""
        user.is_banned = True
        user.is_active = False
        self.db.commit()
        self.db.refresh(user)
        app_logger.warning(f"User banned: {user.username} (ID: {user.id})")
        return user

    def unban_user(self, user: User) -> User:
        """Unban a user."""
        user.is_banned = False
        user.is_active = True
        self.db.commit()
        self.db.refresh(user)
        app_logger.info(f"User unbanned: {user.username} (ID: {user.id})")
        return user

    def delete(self, user: User) -> None:
        """Delete a user."""
        username = user.username
        self.db.delete(user)
        self.db.commit()
        app_logger.warning(f"User deleted: {username}")
FILE: backend/app/schemas/__init__.py
"""Pydantic schemas for request/response validation."""

from app.schemas.user import UserCreate, UserUpdate, UserResponse
from app.schemas.post import PostCreate, PostUpdate, PostResponse
from app.schemas.comment import CommentCreate, CommentUpdate, CommentResponse
from app.schemas.auth import RegisterRequest, TokenResponse
FILE: backend/app/schemas/auth.py
from pydantic import BaseModel, EmailStr

class FirebaseTokenRequest(BaseModel):
    """Firebase ID token for authentication."""
    id_token: str

class RegisterRequest(BaseModel):
    """User registration request."""
    id_token: str
    firebase_uid: str
    email: EmailStr
    username: str
    avatar_url: str | None = None

class TokenUser(BaseModel):
    id: int
    username: str
    email: EmailStr
    avatar_url: str | None = None
    role: str

class TokenResponse(BaseModel):
    """JWT token response."""
    access_token: str
    token_type: str = "bearer"
    user: TokenUser
FILE: backend/app/schemas/comment.py
from pydantic import BaseModel, Field, ConfigDict
from typing import Optional
from datetime import datetime

class CommentBase(BaseModel):
    """Base comment schema."""
    content: str = Field(..., min_length=1, max_length=10000)

class CommentCreate(CommentBase):
    """Schema for creating a comment."""
    post_id: int
    parent_id: Optional[int] = None

class CommentUpdate(BaseModel):
    """Schema for updating a comment."""
    content: str = Field(..., min_length=1, max_length=10000)

class CommentResponse(CommentBase):
    """Schema for comment response."""
    id: int
    post_id: int
    user_id: int
    parent_id: Optional[int] = None
    upvotes: int
    downvotes: int
    is_deleted: bool
    created_at: datetime
    updated_at: Optional[datetime] = None

    author_username: str
    author_avatar: Optional[str] = None

    user_vote: Optional[str] = None
    replies: list["CommentResponse"] = []

    model_config = ConfigDict(from_attributes=True)

class CommentTreeResponse(BaseModel):
    """Nested comment tree."""
    comments: list[CommentResponse]
    total: int
FILE: backend/app/schemas/notification.py
from pydantic import BaseModel, ConfigDict
from datetime import datetime
from typing import Optional

class NotificationCreate(BaseModel):
    """Schema for creating notification."""
    user_id: int
    type: str
    message: str
    link: Optional[str] = None

class NotificationResponse(BaseModel):
    """Schema for notification response."""
    id: int
    user_id: int
    type: str
    message: str
    link: Optional[str] = None
    is_read: bool
    created_at: datetime

    model_config = ConfigDict(from_attributes=True)

class NotificationListResponse(BaseModel):
    """List of notifications."""
    notifications: list[NotificationResponse]
    unread_count: int
FILE: backend/app/schemas/post.py
from pydantic import BaseModel, Field, ConfigDict
from typing import Optional
from datetime import datetime

class PostBase(BaseModel):
    """Base post schema."""
    title: str = Field(..., min_length=1, max_length=300)
    description: Optional[str] = None
    tag: Optional[str] = Field(None, max_length=50)

class PostCreate(PostBase):
    """Schema for creating a post."""
    image_url: Optional[str] = None

class PostUpdate(BaseModel):
    """Schema for updating a post."""
    title: Optional[str] = Field(None, min_length=1, max_length=300)
    description: Optional[str] = None
    tag: Optional[str] = Field(None, max_length=50)

class PostResponse(PostBase):
    """Schema for post response."""
    id: int
    user_id: int
    image_url: Optional[str] = None
    upvotes: int
    downvotes: int
    is_locked: bool
    is_deleted: bool
    created_at: datetime
    updated_at: Optional[datetime] = None

    author_username: str
    author_avatar: Optional[str] = None

    comment_count: int = 0
    user_vote: Optional[str] = None
    is_favorited: bool = False

    model_config = ConfigDict(from_attributes=True)

class PostListResponse(BaseModel):
    """Paginated list of posts."""
    posts: list[PostResponse]
    total: int
    page: int
    page_size: int
    has_more: bool

class VoteCreate(BaseModel):
    """Schema for voting."""
    vote_type: str = Field(..., pattern="^(up|down)$")

class VoteResponse(BaseModel):
    """Vote response."""
    id: int
    user_id: int
    post_id: Optional[int] = None
    comment_id: Optional[int] = None
    vote_type: str
    created_at: datetime

    model_config = ConfigDict(from_attributes=True)
FILE: backend/app/schemas/user.py
from pydantic import BaseModel, EmailStr, Field, ConfigDict
from typing import Optional
from datetime import datetime

class UserBase(BaseModel):
    """Base user schema with common attributes."""
    email: EmailStr
    username: str = Field(..., min_length=3, max_length=50)

class UserCreate(UserBase):
    """Schema for user registration."""
    firebase_uid: str
    avatar_url: Optional[str] = None

class UserUpdate(BaseModel):
    """Schema for updating user profile."""
    username: Optional[str] = Field(None, min_length=3, max_length=50)
    bio: Optional[str] = Field(None, max_length=500)
    avatar_url: Optional[str] = None

class UserResponse(UserBase):
    """Schema for user response."""
    id: int
    avatar_url: Optional[str] = None
    bio: Optional[str] = None
    role_id: int
    is_active: bool
    is_banned: bool
    created_at: datetime

    model_config = ConfigDict(from_attributes=True)

class UserWithRole(UserResponse):
    """User response with role information."""
    role_name: str
    permissions: list[str]

class UserProfile(BaseModel):
    """Public user profile."""
    id: int
    username: str
    avatar_url: Optional[str] = None
    bio: Optional[str] = None
    created_at: datetime

    model_config = ConfigDict(from_attributes=True)
FILE: backend/app/services/auth_service.py
from datetime import timedelta

from fastapi import HTTPException, status
from sqlalchemy.orm import Session

from app.config import settings
from app.core.firebase_auth import verify_firebase_id_token
from app.models.user import User
from app.repositories.user_repository import UserRepository
from app.schemas.auth import RegisterRequest, TokenResponse, TokenUser
from app.schemas.user import UserCreate
from app.core.security import create_access_token
from app.utils.logger import app_logger

class AuthService:
    """Service for authentication and authorization."""

    def __init__(self, db: Session):
        self.db = db
        self.user_repo = UserRepository(db)

    def register_user(self, register_data: RegisterRequest) -> TokenResponse:
        """Create a user after verifying the Firebase token."""
        try:
            claims = verify_firebase_id_token(register_data.id_token)
        except ValueError:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Invalid Firebase credentials",
            ) from None

        firebase_uid = claims["uid"]
        if firebase_uid != register_data.firebase_uid:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Firebase UID mismatch",
            )

        email = claims.get("email")
        if email and email.lower() != register_data.email.lower():
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Email does not match Firebase token",
            )

        if self.user_repo.get_by_firebase_uid(firebase_uid):
            app_logger.info("User already exists, issuing token")
            existing_user = self.user_repo.get_by_firebase_uid(firebase_uid)
            return self._generate_token_response(existing_user)

        if self.user_repo.get_by_email(register_data.email):
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Email already registered",
            )

        if self.user_repo.get_by_username(register_data.username):
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Username already taken",
            )

        avatar = register_data.avatar_url or claims.get("picture")
        user = self.user_repo.create(
            UserCreate(
                firebase_uid=firebase_uid,
                email=register_data.email,
                username=register_data.username,
                avatar_url=avatar,
            )
        )
        app_logger.info("New user registered: %s", user.username)
        return self._generate_token_response(user)

    def login_user(self, id_token: str) -> TokenResponse:
        """Authenticate a user using a Firebase ID token."""
        try:
            claims = verify_firebase_id_token(id_token)
        except ValueError:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Invalid Firebase credentials",
            ) from None

        firebase_uid = claims["uid"]
        user = self.user_repo.get_by_firebase_uid(firebase_uid)
        if not user:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="User not found. Please register first.",
            )

        if not user.is_active:
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail="User account is inactive",
            )

        if user.is_banned:
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail="User account is banned",
            )

        return self._generate_token_response(user)

    def _generate_token_response(self, user: User) -> TokenResponse:
        access_token_expires = timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)
        access_token = create_access_token(
            data={"user_id": user.id, "username": user.username},
            expires_delta=access_token_expires,
        )

        return TokenResponse(
            access_token=access_token,
            user=TokenUser(
                id=user.id,
                username=user.username,
                email=user.email,
                avatar_url=user.avatar_url,
                role=user.role.name if user.role else "user",
            ),
        )
FILE: backend/app/services/comment_service.py
from typing import List, Optional
from fastapi import HTTPException, status
from sqlalchemy.orm import Session
from app.models.comment import Comment
from app.models.user import User
from app.schemas.comment import (
    CommentCreate, CommentUpdate, CommentResponse, CommentTreeResponse
)
from app.repositories.comment_repository import CommentRepository
from app.repositories.post_repository import PostRepository
from app.services.notification_service import NotificationService
from app.schemas.notification import NotificationCreate
from app.core.permissions import has_permission, check_resource_ownership
from app.utils.logger import app_logger

class CommentService:
    """Service for comment operations."""

    def __init__(self, db: Session):
        self.db = db
        self.comment_repo = CommentRepository(db)
        self.post_repo = PostRepository(db)
        self.notification_service = NotificationService(db)

    def create_comment(self, comment_data: CommentCreate, current_user: User) -> CommentResponse:
        """Create a new comment or reply."""
        if not has_permission(current_user, "comment:create"):
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail="You don't have permission to create comments"
            )

        post = self.post_repo.get_by_id(comment_data.post_id)
        if not post:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Post not found"
            )

        if post.is_locked:
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail="Post is locked. Cannot add comments."
            )

        if comment_data.parent_id:
            parent = self.comment_repo.get_by_id(comment_data.parent_id)
            if not parent:
                raise HTTPException(
                    status_code=status.HTTP_404_NOT_FOUND,
                    detail="Parent comment not found"
                )

            if parent.post_id != comment_data.post_id:
                raise HTTPException(
                    status_code=status.HTTP_400_BAD_REQUEST,
                    detail="Parent comment does not belong to this post"
                )

        comment = self.comment_repo.create(comment_data, current_user.id)

        if post.user_id != current_user.id:
            notification_data = NotificationCreate(
                user_id=post.user_id,
                type="new_comment",
                message=f"{current_user.username} commented on your post: {post.title[:50]}",
                link=f"/posts/{post.id}"
            )
            self.notification_service.create_notification(notification_data)

        if comment_data.parent_id and parent.user_id != current_user.id:
            notification_data = NotificationCreate(
                user_id=parent.user_id,
                type="reply",
                message=f"{current_user.username} replied to your comment",
                link=f"/posts/{post.id}
            )
            self.notification_service.create_notification(notification_data)

        return self._comment_to_response(comment, current_user)

    def get_comment(self, comment_id: int, current_user: Optional[User] = None) -> CommentResponse:
        """Get comment by ID."""
        comment = self.comment_repo.get_by_id(comment_id)

        if not comment:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Comment not found"
            )

        return self._comment_to_response(comment, current_user)

    def get_post_comments(
        self,
        post_id: int,
        current_user: Optional[User] = None
    ) -> CommentTreeResponse:
        """Get all comments for a post in tree structure."""
        post = self.post_repo.get_by_id(post_id)
        if not post:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Post not found"
            )

        top_level_comments = self.comment_repo.get_by_post(post_id)

        comment_responses = []
        for comment in top_level_comments:
            comment_responses.append(self._build_comment_tree(comment, current_user))

        total = self.comment_repo.count_by_post(post_id)

        return CommentTreeResponse(
            comments=comment_responses,
            total=total
        )

    def update_comment(
        self,
        comment_id: int,
        comment_data: CommentUpdate,
        current_user: User
    ) -> CommentResponse:
        """Update a comment."""
        comment = self.comment_repo.get_by_id(comment_id)

        if not comment:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Comment not found"
            )

        if not check_resource_ownership(current_user, comment.user_id):
            if not has_permission(current_user, "comment:edit:any"):
                raise HTTPException(
                    status_code=status.HTTP_403_FORBIDDEN,
                    detail="You don't have permission to edit this comment"
                )

        updated_comment = self.comment_repo.update(comment, comment_data)
        return self._comment_to_response(updated_comment, current_user)

    def delete_comment(self, comment_id: int, current_user: User) -> dict:
        """Delete a comment (soft delete)."""
        comment = self.comment_repo.get_by_id(comment_id)

        if not comment:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Comment not found"
            )

        if not check_resource_ownership(current_user, comment.user_id):
            if not has_permission(current_user, "comment:delete:any"):
                raise HTTPException(
                    status_code=status.HTTP_403_FORBIDDEN,
                    detail="You don't have permission to delete this comment"
                )

        self.comment_repo.soft_delete(comment)
        return {"message": "Comment deleted successfully"}

    def vote_comment(
        self,
        comment_id: int,
        vote_type: str,
        current_user: User
    ) -> CommentResponse:
        """Vote on a comment."""
        if not has_permission(current_user, "vote:create"):
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail="You don't have permission to vote"
            )

        comment = self.comment_repo.get_by_id(comment_id)

        if not comment:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Comment not found"
            )

        self.comment_repo.create_vote(comment_id, current_user.id, vote_type)

        updated_comment = self.comment_repo.get_by_id(comment_id)
        return self._comment_to_response(updated_comment, current_user)

    def remove_vote(self, comment_id: int, current_user: User) -> CommentResponse:
        """Remove vote from comment."""
        comment = self.comment_repo.get_by_id(comment_id)

        if not comment:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Comment not found"
            )

        self.comment_repo.remove_vote(comment_id, current_user.id)

        updated_comment = self.comment_repo.get_by_id(comment_id)
        return self._comment_to_response(updated_comment, current_user)

    def _comment_to_response(
        self,
        comment: Comment,
        current_user: Optional[User] = None
    ) -> CommentResponse:
        """Convert Comment model to CommentResponse schema."""
        user_vote = None
        if current_user:
            vote = self.comment_repo.get_user_vote(comment.id, current_user.id)
            if vote:
                user_vote = vote.vote_type

        return CommentResponse(
            id=comment.id,
            post_id=comment.post_id,
            user_id=comment.user_id,
            parent_id=comment.parent_id,
            content=comment.content,
            upvotes=comment.upvotes,
            downvotes=comment.downvotes,
            is_deleted=comment.is_deleted,
            created_at=comment.created_at,
            updated_at=comment.updated_at,
            author_username=comment.author.username,
            author_avatar=comment.author.avatar_url,
            user_vote=user_vote,
            replies=[]
        )

    def _build_comment_tree(
        self,
        comment: Comment,
        current_user: Optional[User] = None
    ) -> CommentResponse:
        """Recursively build comment tree with replies."""
        comment_response = self._comment_to_response(comment, current_user)

        replies = self.comment_repo.get_by_post(comment.post_id, parent_id=comment.id)

        comment_response.replies = [
            self._build_comment_tree(reply, current_user) for reply in replies
        ]

        return comment_response
FILE: backend/app/services/notification_service.py
from typing import List
from sqlalchemy.orm import Session
from app.models.notification import Notification
from app.models.user import User
from app.schemas.notification import NotificationCreate, NotificationResponse, NotificationListResponse
from app.core.redis_client import redis_client
from app.utils.logger import app_logger
import json

class NotificationService:
    """Service for notification operations."""

    def __init__(self, db: Session):
        self.db = db

    def create_notification(self, notification_data: NotificationCreate) -> Notification:
        """Create a new notification."""
        notification = Notification(
            user_id=notification_data.user_id,
            type=notification_data.type,
            message=notification_data.message,
            link=notification_data.link
        )

        self.db.add(notification)
        self.db.commit()
        self.db.refresh(notification)

        app_logger.info(f"Notification created for user {notification.user_id}")

        self._publish_to_stream(notification)

        return notification

    def get_user_notifications(
        self,
        user_id: int,
        skip: int = 0,
        limit: int = 20,
        unread_only: bool = False
    ) -> NotificationListResponse:
        """Get notifications for a user."""
        query = self.db.query(Notification).filter(Notification.user_id == user_id)

        if unread_only:
            query = query.filter(Notification.is_read == False)

        notifications = query.order_by(Notification.created_at.desc()).offset(skip).limit(limit).all()

        unread_count = self.db.query(Notification).filter(
            Notification.user_id == user_id,
            Notification.is_read == False
        ).count()

        notification_responses = [
            NotificationResponse(
                id=n.id,
                user_id=n.user_id,
                type=n.type,
                message=n.message,
                link=n.link,
                is_read=n.is_read,
                created_at=n.created_at
            ) for n in notifications
        ]

        return NotificationListResponse(
            notifications=notification_responses,
            unread_count=unread_count
        )

    def mark_as_read(self, notification_id: int, user_id: int) -> bool:
        """Mark notification as read."""
        notification = self.db.query(Notification).filter(
            Notification.id == notification_id,
            Notification.user_id == user_id
        ).first()

        if notification:
            notification.is_read = True
            self.db.commit()
            app_logger.info(f"Notification {notification_id} marked as read")
            return True

        return False

    def mark_all_as_read(self, user_id: int) -> int:
        """Mark all notifications as read for a user."""
        count = self.db.query(Notification).filter(
            Notification.user_id == user_id,
            Notification.is_read == False
        ).update({"is_read": True})

        self.db.commit()
        app_logger.info(f"Marked {count} notifications as read for user {user_id}")
        return count

    def _publish_to_stream(self, notification: Notification):
        """Publish notification to Redis Stream for real-time delivery."""
        try:
            notification_data = {
                "id": str(notification.id),
                "user_id": str(notification.user_id),
                "type": notification.type,
                "message": notification.message,
                "link": notification.link or "",
                "created_at": notification.created_at.isoformat()
            }

            redis_client.add_to_stream("notifications:stream", notification_data)
            app_logger.debug(f"Notification published to stream: {notification.id}")
        except Exception as e:
            app_logger.error(f"Failed to publish notification to stream: {e}")
FILE: backend/app/services/notification_stream.py
import asyncio
from contextlib import suppress

from app.core.redis_client import redis_client
from app.services.websocket_service import connection_manager
from app.utils.logger import app_logger

STREAM_KEY = "notifications:stream"
READ_BLOCK_MS = 5000
BATCH_COUNT = 20

async def notification_stream_worker():
    """
    Pump Redis stream entries into WebSocket connections.
    Runs forever; cancel on shutdown.
    """
    last_id = "0-0"

    while True:
        try:
            await asyncio.sleep(0)
            result = await asyncio.to_thread(
                redis_client.client.xread,
                {STREAM_KEY: last_id},
                block=READ_BLOCK_MS,
                count=BATCH_COUNT,
            )

            if not result:
                continue

            for _, messages in result:
                for entry_id, data in messages:
                    last_id = entry_id
                    user_id = data.get("user_id")
                    if not user_id:
                        continue

                    await connection_manager.send_personal_message(
                        {
                            "type": "notification",
                            "notification": {
                                "id": int(data["id"]),
                                "user_id": int(user_id),
                                "type": data.get("type", ""),
                                "message": data.get("message", ""),
                                "link": data.get("link") or None,
                                "created_at": data.get("created_at"),
                            },
                        },
                        int(user_id),
                    )
        except asyncio.CancelledError:
            raise
        except Exception as exc:
            app_logger.error(f"Notification stream worker error: {exc}")
            await asyncio.sleep(2)

async def stop_notification_worker(task: asyncio.Task | None):
    if task:
        task.cancel()
        with suppress(asyncio.CancelledError):
            await task
FILE: backend/app/services/post_service.py
from typing import List, Optional
from fastapi import HTTPException, status
from sqlalchemy.orm import Session
from app.models.post import Post, Favorite
from app.models.user import User
from app.schemas.post import (
    PostCreate, PostUpdate, PostResponse, PostListResponse, VoteCreate
)
from app.repositories.post_repository import PostRepository
from app.repositories.comment_repository import CommentRepository
from app.core.permissions import has_permission, check_resource_ownership
from app.utils.logger import app_logger

class PostService:
    """Service for post operations."""

    def __init__(self, db: Session):
        self.db = db
        self.post_repo = PostRepository(db)
        self.comment_repo = CommentRepository(db)

    def create_post(self, post_data: PostCreate, current_user: User) -> PostResponse:
        """Create a new post."""
        if not has_permission(current_user, "post:create"):
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail="You don't have permission to create posts"
            )

        post = self.post_repo.create(post_data, current_user.id)
        return self._post_to_response(post, current_user)

    def get_post(self, post_id: int, current_user: Optional[User] = None) -> PostResponse:
        """Get post by ID."""
        post = self.post_repo.get_by_id(post_id)

        if not post:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Post not found"
            )

        return self._post_to_response(post, current_user)

    def get_posts(
        self,
        page: int = 1,
        page_size: int = 20,
        tag: Optional[str] = None,
        sort_by: str = "new",
        current_user: Optional[User] = None
    ) -> PostListResponse:
        """Get paginated list of posts."""
        skip = (page - 1) * page_size

        posts = self.post_repo.get_all(
            skip=skip,
            limit=page_size,
            tag=tag,
            sort_by=sort_by
        )

        total = self.post_repo.count_all(tag=tag)

        post_responses = [self._post_to_response(post, current_user) for post in posts]

        return PostListResponse(
            posts=post_responses,
            total=total,
            page=page,
            page_size=page_size,
            has_more=skip + page_size < total
        )

    def get_favorites(
        self,
        page: int = 1,
        page_size: int = 20,
        current_user: User = None
    ) -> PostListResponse:
        """Get user's favorite posts."""
        skip = (page - 1) * page_size

        posts = self.post_repo.get_user_favorites(
            user_id=current_user.id,
            skip=skip,
            limit=page_size
        )

        total = self.db.query(Favorite).filter(
            Favorite.user_id == current_user.id
        ).count()

        post_responses = [self._post_to_response(post, current_user) for post in posts]

        return PostListResponse(
            posts=post_responses,
            total=total,
            page=page,
            page_size=page_size,
            has_more=skip + page_size < total
        )

    def get_user_posts(
        self,
        user_id: int,
        page: int = 1,
        page_size: int = 20,
        current_user: Optional[User] = None
    ) -> PostListResponse:
        """Get posts by specific user."""
        skip = (page - 1) * page_size

        posts = self.post_repo.get_all(
            skip=skip,
            limit=page_size,
            user_id=user_id,
            sort_by="new"
        )

        total = self.post_repo.count_all(user_id=user_id)

        post_responses = [self._post_to_response(post, current_user) for post in posts]

        return PostListResponse(
            posts=post_responses,
            total=total,
            page=page,
            page_size=page_size,
            has_more=skip + page_size < total
        )

    def update_post(
        self,
        post_id: int,
        post_data: PostUpdate,
        current_user: User
    ) -> PostResponse:
        """Update a post."""
        post = self.post_repo.get_by_id(post_id)

        if not post:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Post not found"
            )

        if not check_resource_ownership(current_user, post.user_id):
            if not has_permission(current_user, "post:edit:any"):
                raise HTTPException(
                    status_code=status.HTTP_403_FORBIDDEN,
                    detail="You don't have permission to edit this post"
                )

        updated_post = self.post_repo.update(post, post_data)
        return self._post_to_response(updated_post, current_user)

    def delete_post(self, post_id: int, current_user: User) -> dict:
        """Delete a post."""
        post = self.post_repo.get_by_id(post_id)

        if not post:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Post not found"
            )

        if not check_resource_ownership(current_user, post.user_id):
            if not has_permission(current_user, "post:delete:any"):
                raise HTTPException(
                    status_code=status.HTTP_403_FORBIDDEN,
                    detail="You don't have permission to delete this post"
                )

        self.post_repo.soft_delete(post)
        return {"message": "Post deleted successfully"}

    def vote_post(self, post_id: int, vote_data: VoteCreate, current_user: User) -> PostResponse:
        """Vote on a post."""
        if not has_permission(current_user, "vote:create"):
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail="You don't have permission to vote"
            )

        post = self.post_repo.get_by_id(post_id)

        if not post:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Post not found"
            )

        self.post_repo.create_vote(post_id, current_user.id, vote_data.vote_type)

        updated_post = self.post_repo.get_by_id(post_id)
        return self._post_to_response(updated_post, current_user)

    def remove_vote(self, post_id: int, current_user: User) -> PostResponse:
        """Remove vote from post."""
        post = self.post_repo.get_by_id(post_id)

        if not post:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Post not found"
            )

        self.post_repo.remove_vote(post_id, current_user.id)

        updated_post = self.post_repo.get_by_id(post_id)
        return self._post_to_response(updated_post, current_user)

    def add_favorite(self, post_id: int, current_user: User) -> dict:
        """Add post to favorites."""
        post = self.post_repo.get_by_id(post_id)

        if not post:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Post not found"
            )

        if self.post_repo.is_favorited(post_id, current_user.id):
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Post already favorited"
            )

        self.post_repo.add_favorite(post_id, current_user.id)
        app_logger.info(f"Post {post_id} favorited by user {current_user.id}")

        return {
            "message": "Post added to favorites",
            "is_favorited": True
        }

    def remove_favorite(self, post_id: int, current_user: User) -> dict:
        """Remove post from favorites."""
        post = self.post_repo.get_by_id(post_id)

        if not post:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Post not found"
            )

        if not self.post_repo.is_favorited(post_id, current_user.id):
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Post not in favorites"
            )

        self.post_repo.remove_favorite(post_id, current_user.id)
        app_logger.info(f"Post {post_id} unfavorited by user {current_user.id}")

        return {
            "message": "Post removed from favorites",
            "is_favorited": False
        }

    def _post_to_response(self, post: Post, current_user: Optional[User] = None) -> PostResponse:
        """Convert Post model to PostResponse schema."""
        comment_count = self.comment_repo.count_by_post(post.id)

        user_vote = None
        is_favorited = False

        if current_user:
            vote = self.post_repo.get_user_vote(post.id, current_user.id)
            if vote:
                user_vote = vote.vote_type

            is_favorited = self.post_repo.is_favorited(post.id, current_user.id)

        return PostResponse(
            id=post.id,
            user_id=post.user_id,
            title=post.title,
            description=post.description,
            tag=post.tag,
            image_url=post.image_url,
            upvotes=post.upvotes,
            downvotes=post.downvotes,
            is_locked=post.is_locked,
            is_deleted=post.is_deleted,
            created_at=post.created_at,
            updated_at=post.updated_at,
            author_username=post.author.username,
            author_avatar=post.author.avatar_url,
            comment_count=comment_count,
            user_vote=user_vote,
            is_favorited=is_favorited
        )
FILE: backend/app/services/websocket_service.py
from typing import Dict, Set
from fastapi import WebSocket
from app.utils.logger import app_logger
import json

class ConnectionManager:
    """Manage WebSocket connections."""

    def __init__(self):
        self.active_connections: Dict[int, Set[WebSocket]] = {}

    async def connect(self, websocket: WebSocket, user_id: int):
        """Accept WebSocket connection."""
        await websocket.accept()

        if user_id not in self.active_connections:
            self.active_connections[user_id] = set()

        self.active_connections[user_id].add(websocket)
        app_logger.info(f"WebSocket connected: User {user_id}")

    def disconnect(self, websocket: WebSocket, user_id: int):
        """Remove WebSocket connection."""
        if user_id in self.active_connections:
            self.active_connections[user_id].discard(websocket)

            if not self.active_connections[user_id]:
                del self.active_connections[user_id]

        app_logger.info(f"WebSocket disconnected: User {user_id}")

    async def send_personal_message(self, message: dict, user_id: int):
        """Send message to specific user (all their connections)."""
        if user_id in self.active_connections:
            disconnected = set()

            for connection in self.active_connections[user_id]:
                try:
                    await connection.send_json(message)
                except Exception as e:
                    app_logger.error(f"Failed to send message to user {user_id}: {e}")
                    disconnected.add(connection)

            for connection in disconnected:
                self.active_connections[user_id].discard(connection)

    async def broadcast(self, message: dict):
        """Broadcast message to all connected users."""
        disconnected = []

        for user_id, connections in self.active_connections.items():
            for connection in connections:
                try:
                    await connection.send_json(message)
                except Exception as e:
                    app_logger.error(f"Failed to broadcast to user {user_id}: {e}")
                    disconnected.append((user_id, connection))

        for user_id, connection in disconnected:
            self.disconnect(connection, user_id)

    def is_user_online(self, user_id: int) -> bool:
        """Check if user is online."""
        return user_id in self.active_connections and len(self.active_connections[user_id]) > 0

    def get_online_count(self) -> int:
        """Get total number of online users."""
        return len(self.active_connections)

connection_manager = ConnectionManager()
FILE: backend/app/utils/logger.py
import sys
from pathlib import Path
from loguru import logger
from app.config import settings

def setup_logger():
    """Configure Loguru logger."""

    logger.remove()

    logger.add(
        sys.stdout,
        format="<green>{time:YYYY-MM-DD HH:mm:ss}</green> | <level>{level: <8}</level> | <cyan>{name}</cyan>:<cyan>{function}</cyan>:<cyan>{line}</cyan> - <level>{message}</level>",
        level=settings.LOG_LEVEL,
        colorize=True,
    )

    log_path = Path(settings.LOG_FILE)
    log_path.parent.mkdir(parents=True, exist_ok=True)

    logger.add(
        settings.LOG_FILE,
        format="{time:YYYY-MM-DD HH:mm:ss} | {level: <8} | {name}:{function}:{line} - {message}",
        level=settings.LOG_LEVEL,
        rotation="10 MB",
        retention="1 week",
        compression="zip",
    )

    logger.info(f"Logger initialized - Level: {settings.LOG_LEVEL}")

    return logger

app_logger = setup_logger()
FILE: backend/firebase-service-account.json
{
  "type": "service_account",
  "project_id": "my-metkit18",
  "private_key_id": "446969e143adf1fb7ef28d2a9e3fac88a6f252a4",
  "private_key": "-----BEGIN PRIVATE KEY-----\nMIIEvgIBADANBgkqhkiG9w0BAQEFAASCBKgwggSkAgEAAoIBAQCy9IWNIJPpW9zy\nzOiCoed54OiSgehOLVf5TnAOlB0iHzimWWJbiQ5yhbYYdIE3kuxv+2kl86GbvLWm\nekrI4LwrWDV+nuCsPnNjxwUCIv2xFtPdcF81SjX9cbDwGQGNoWFdpCWhCLC5NBGx\nqp+Zub2Ykn9nDE4s36pfzk/iVde2Zb8aG8VPBzoFXKJ5IpF2l9znPcGwph3WJ0Bo\nhsATlEo0rbm7LwzT3qR0UOhB9I6RrqzuK78Ita/LLUNjYQDFW7RHoSP3Uwwq6j2i\niTPJP3Cs7Up68R3HFDTBHaTQ9CtYfA39gueqMPpGngCc0CTS57KwXDY0mSqneL4z\ns/ALZPD/AgMBAAECggEAAOnTlq1QY/QGlCyskSIfatVVio3kMCX2GX0ngEOMRITR\nRrQVFu+Dpdz92XEaybxTvZyUZE+yhvd3G+Lq58yR2UzJdRx9fBOThjJZWbHxBord\nyPcOXVjEHseKRidyhRUKSK6STJidQky8PGJpDyFOEO3Kfa2n5n27wmJssPSMNc+b\n7oSyf2+34lZVIF4pPf8vQQPRwIxdtFg5XNIQHlwBj6TaxnUpihp55eMfAIbta26R\nFNNWgCGyMFNzbpnDdmCZDWWOyTTC07Uw64PtFT94iACw7U+0slMIGk2zF8iLVX9x\nDbRWMxT4/wQf+E/PC2BxTy9PGXPslqFT/OPJvd4DsQKBgQDzvxzIl8qAceox2xim\nr7eFf3t4QOUiDf/qX7N8sGCO6Fnu1l2v8scNvwReX1x3Z9d8HXxtl8c+gplbTmzC\n8JlkaeXvq7xtpeRezCmC9ncNFMbWLq+aIQ75mpztrheuFu1k8xHMozj6uj92ps/9\nxZOCXvZ4xXdzZcubdvv91qf1DwKBgQC785Q2ZS60LRxeep0oQ64FXP0DINXWHrCN\nfHIdLkyqWKMQrocg+xniMmoWl0OQMR8e6Z6dOzVfSBaUPV3OwG6QKEQOl7OtFaej\nXfQWeljSNBsHPNkKtGMJ6c+fbJwcyxqswXAH9NoXSCm+DSEr4nsT509UAIZS9TVF\nxnThQAWlEQKBgQDJwaxqobI95Yzr3aYm+xXWi7JA1L6VFK97aeHg2QHj6JHgb1I3\nPKblSvKrxxV7xNmJ48JF2LdUl7em62B9b7gYdMueOjILNKC2kxndTHM4wbTgPt6d\nnrWNiBxTZKI3OMUhpU1bbNPSPe4gIW3SagNyi3ZKe3EndOA2/CMTduWpowKBgEwa\nyFPySqQIdClJiuNn7EodqhGfNRcbnC/eSTLJsZ90fqrdkLfpFUUDVvPI0kHLsidJ\nP8G43Na1EPd7lcWHI/3ZYB1sjgOy9gtvmsuTRO3wzVTz7YqpGkVEWJ7cUqZSE34K\nYbvHCJxOyyA6nsjvTxjzG6sO/1UOF0Emp+MhkmeRAoGBAPI/mHdrYDyD+oQC0ID0\nrBOXK3yyp2CO8wsDGniZtDOpQaYjb8BDYVmrmyv4KcCgdC4dzeHcodD5D9F9KT/l\nA6xScwGyh9FI233+hbOZdnZ+zgHS1OMVXiSiL44VJuTlCNhINyVGjMZvrLybeG++\nT9ciLDKN83it+R9oIoo+w2Ml\n-----END PRIVATE KEY-----\n",
  "client_email": "firebase-adminsdk-ckpgc@my-metkit18.iam.gserviceaccount.com",
  "client_id": "101296791156231089871",
  "auth_uri": "https://accounts.google.com/o/oauth2/auth",
  "token_uri": "https://oauth2.googleapis.com/token",
  "auth_provider_x509_cert_url": "https://www.googleapis.com/oauth2/v1/certs",
  "client_x509_cert_url": "https://www.googleapis.com/robot/v1/metadata/x509/firebase-adminsdk-ckpgc%40my-metkit18.iam.gserviceaccount.com",
  "universe_domain": "googleapis.com"
}
FILE: backend/main.py
"""
Entry point for running the FastAPI application.

Usage:
    uv run python main.py

Or with uvicorn directly:
    uv run uvicorn app.main:app --reload --host 0.0.0.0 --port 8000
"""

import uvicorn
from app.config import settings

if __name__ == "__main__":
    uvicorn.run(
        "app.main:app",
        host=settings.HOST,
        port=settings.PORT,
        reload=settings.DEBUG,
        log_level=settings.LOG_LEVEL.lower()
    )
FILE: backend/seed.py
from app.database import SessionLocal
from app.models.role import Role
from app.utils.logger import app_logger

def seed_roles(db):
    """Seed initial roles and permissions."""

    roles_data = [
        {
            "id": 1,
            "name": "admin",
            "permissions": [
                "post:create", "post:edit:own", "post:edit:any", "post:delete:own",
                "post:delete:any", "post:lock",
                "comment:create", "comment:edit:own", "comment:edit:any",
                "comment:delete:own", "comment:delete:any",
                "vote:create", "favorite:manage",
                "user:ban:platform", "user:ban:comment",
                "moderator:manage", "logs:view", "reports:view",
            ]
        },
        {
            "id": 2,
            "name": "moderator",
            "permissions": [
                "post:create", "post:edit:own", "post:delete:own",
                "comment:create", "comment:edit:own", "comment:delete:own",
                "comment:delete:any",
                "vote:create", "favorite:manage",
                "user:ban:comment", "thread:lock", "reports:view",
            ]
        },
        {
            "id": 3,
            "name": "user",
            "permissions": [
                "post:create", "post:edit:own", "post:delete:own",
                "comment:create", "comment:edit:own", "comment:delete:own",
                "vote:create", "favorite:manage",
            ]
        }
    ]

    for role_data in roles_data:
        existing = db.query(Role).filter(Role.name == role_data["name"]).first()
        if not existing:
            role = Role(**role_data)
            db.add(role)
            app_logger.info(f"Created role: {role_data['name']}")
        else:
            app_logger.info(f"Role already exists: {role_data['name']}")

    db.commit()
    app_logger.info("Roles seeded successfully")

def main():
    """Main seed function."""
    db = SessionLocal()
    try:
        app_logger.info("Starting database seeding...")
        seed_roles(db)
        app_logger.info("Database seeded successfully!")
    except Exception as e:
        app_logger.error(f"Seeding failed: {e}")
        db.rollback()
        raise
    finally:
        db.close()

if __name__ == "__main__":
    main()
FILE: db/docker-compose.yml
version: '3.8'

services:
  postgres:
    image: postgres:16-alpine
    container_name: meme_forum_postgres
    restart: unless-stopped
    environment:
      POSTGRES_USER: meme_user
      POSTGRES_PASSWORD: meme_pass
      POSTGRES_DB: meme_forum
      POSTGRES_INITDB_ARGS: "--encoding=UTF8"
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./init-scripts:/docker-entrypoint-initdb.d  # Run SQL scripts on startup
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U meme_user -d meme_forum"]
      interval: 10s
      timeout: 5s
      retries: 5
    networks:
      - meme_network

  # Optional: PgAdmin for database management
  pgadmin:
    image: dpage/pgadmin4:latest
    container_name: meme_forum_pgadmin
    restart: unless-stopped
    environment:
      PGADMIN_DEFAULT_EMAIL: admin@memeforum.com
      PGADMIN_DEFAULT_PASSWORD: admin
      PGADMIN_CONFIG_SERVER_MODE: 'False'
    ports:
      - "5050:80"
    depends_on:
      - postgres
    networks:
      - meme_network

volumes:
  postgres_data:
    driver: local

networks:
  meme_network:
    driver: bridge
FILE: docker-compose.yml
services:
  db:
    image: postgres:15-alpine
    environment:
      POSTGRES_USER: meme_user
      POSTGRES_PASSWORD: meme_pass
      POSTGRES_DB: meme_forum
    volumes:
      - postgres_data:/var/lib/postgresql/data
    ports:
      - "5432:5432"

  redis-cache:
    image: redis:7-alpine
    command: ["redis-server", "--save", "", "--appendonly", "no"]
    ports:
      - "6379:6379"

  backend:
    build: ./backend
    env_file:
      - ./backend/.env
    volumes:
      - ./backend:/app
      - ./backend/logs:/app/logs
    ports:
      - "8000:8000"
    depends_on:
      - db
      - redis-cache

  frontend:
    build: ./frontend
    ports:
      - "4200:80"
    depends_on:
      - backend

volumes:
  postgres_data:
FILE: frontend/src/app/app.config.ts
import { ApplicationConfig, provideZoneChangeDetection } from '@angular/core';
import { provideRouter } from '@angular/router';
import { provideHttpClient, withInterceptors } from '@angular/common/http';
import { provideAnimations } from '@angular/platform-browser/animations';
import { routes } from './app.routes';
import { jwtInterceptor } from './core/interceptors/jwt-interceptor';
import { errorInterceptor } from './core/interceptors/error-interceptor';
export const appConfig: ApplicationConfig = {
  providers: [
    provideZoneChangeDetection({ eventCoalescing: true }),
    provideRouter(routes),
    provideHttpClient(
      withInterceptors([jwtInterceptor, errorInterceptor])
    ),
    provideAnimations()
  ]
};
FILE: frontend/src/app/app.css
.app-container {
  height: 100vh;
  display: flex;
  flex-direction: column;
  background-color: var(--bg-primary);
}
.app-body {
  display: flex;
  flex: 1;
  overflow: hidden;
  padding-top: 48px;
}
.main-content {
  flex: 1;
  overflow-y: auto;
  background-color: var(--bg-primary);
  padding: 20px;
  margin-left: 280px;
}
@media (max-width: 960px) {
  .main-content {
    margin-left: 0;
    padding: 16px;
  }
}
FILE: frontend/src/app/app.html
@if (!auth.isReady()) {
  <app-loading-spinner
    [fullscreen]="true"
    message="Loading application..."
  ></app-loading-spinner>
} @else {
  <div class="app-container">
    <app-header></app-header>
    <div class="app-body">
      <app-sidebar></app-sidebar>
      <main class="main-content">
        <router-outlet></router-outlet>
      </main>
    </div>
  </div>
}
FILE: frontend/src/app/app.routes.ts
import { Routes } from '@angular/router';
import { Feed } from './pages/feed/feed';
import { Login } from './features/auth/login/login';
import { Signup } from './features/auth/signup/signup';
import { PostDetail } from './features/posts/post-detail/post-detail';
import { PostCreate } from './features/posts/post-create/post-create';
import { Profile } from './features/user/profile/profile';
import { Settings } from './features/user/settings/settings';
import { SavedPosts } from './pages/saved-posts/saved-posts';
import { Category } from './pages/category/category';
import { NotFound } from './pages/not-found/not-found';
import { authGuard } from './core/guards/auth-guard';
import { guestGuard } from './core/guards/guest-guard';
export const routes: Routes = [
  { path: '', redirectTo: '/feed', pathMatch: 'full' },
  { path: 'feed', component: Feed, canActivate: [authGuard] },
  { path: 'feed/:filter', component: Feed, canActivate: [authGuard] },
  { path: 'post/:id', component: PostDetail, canActivate: [authGuard] },
  { path: 'create-post', component: PostCreate, canActivate: [authGuard] },
  { path: 'saved', component: SavedPosts, canActivate: [authGuard] },
  { path: 'category/:slug', component: Category, canActivate: [authGuard] },
  { path: 'profile/:username', component: Profile, canActivate: [authGuard] },
  { path: 'settings', component: Settings, canActivate: [authGuard] },
  { path: 'login', component: Login, canActivate: [guestGuard] },
  { path: 'signup', component: Signup, canActivate: [guestGuard] },
  { path: '**', component: NotFound, canActivate: [authGuard] },
];
FILE: frontend/src/app/app.spec.ts
import { TestBed } from '@angular/core/testing';
import { App } from './app';
describe('App', () => {
  beforeEach(async () => {
    await TestBed.configureTestingModule({
      imports: [App],
    }).compileComponents();
  });
  it('should create the app', () => {
    const fixture = TestBed.createComponent(App);
    const app = fixture.componentInstance;
    expect(app).toBeTruthy();
  });
  it('should render title', async () => {
    const fixture = TestBed.createComponent(App);
    await fixture.whenStable();
    const compiled = fixture.nativeElement as HTMLElement;
    expect(compiled.querySelector('h1')?.textContent).toContain('Hello, frontend');
  });
});
FILE: frontend/src/app/app.ts
import { ChangeDetectionStrategy, Component, inject } from '@angular/core';
import { RouterOutlet } from '@angular/router';
import { Header } from './shared/components/header/header';
import { Sidebar } from './shared/components/sidebar/sidebar';
import { Auth } from './core/services/auth';
import { LoadingSpinner } from './shared/components/loading-spinner/loading-spinner';
@Component({
  selector: 'app-root',
  standalone: true,
  imports: [RouterOutlet, Header, Sidebar, LoadingSpinner],
  templateUrl: './app.html',
  styleUrls: ['./app.css'],
  changeDetection: ChangeDetectionStrategy.OnPush,
})
export class App {
  protected readonly auth = inject(Auth);
}
FILE: frontend/src/app/core/config/environment.ts
export const environment = {
  apiUrl: 'http://localhost:8000/api/v1',
  websocketUrl: 'ws:
  storageKeys: {
    auth: 'memeforum.auth',
  },
  firebase: {
    apiKey: 'AIzaSyBhytWfxcCQvuLeggoWVHzwEBFd9-yi2Vk',
    authDomain: 'my-metkit18.firebaseapp.com',
    databaseURL: 'https://my-metkit18-default-rtdb.asia-southeast1.firebasedatabase.app',
    projectId: 'my-metkit18',
    storageBucket: 'my-metkit18.firebasestorage.app',
    messagingSenderId: '405491881603',
    appId: '1:405491881603:web:56e6e072d78ed32fca2db6',
    measurementId: 'G-45Q2DK9C36',
  },
};
FILE: frontend/src/app/core/constants/categories.ts
export interface Category {
  id: string;
  name: string;
  emoji: string;
  slug: string;
}
export const CATEGORIES: Category[] = [
  { id: 'funny', name: 'Funny', emoji: 'ğŸ˜‚', slug: 'funny' },
  { id: 'gaming', name: 'Gaming', emoji: 'ğŸ®', slug: 'gaming' },
  { id: 'programming', name: 'Programming', emoji: 'ğŸ’»', slug: 'programming' },
  { id: 'dank', name: 'Dank', emoji: 'ğŸŒš', slug: 'dank' },
  { id: 'wholesome', name: 'Wholesome', emoji: 'ğŸ¥°', slug: 'wholesome' },
];
FILE: frontend/src/app/core/firebase/firebase.ts
import { initializeApp } from 'firebase/app';
import { getAuth } from 'firebase/auth';
import type { Auth } from 'firebase/auth';
import { environment } from '../config/environment';
let authInstance: Auth | null = null;
let initialised = false;
export function getFirebaseAuth(): Auth | null {
  if (authInstance) return authInstance;
  if (!environment.firebase.apiKey) {
    console.warn('[Firebase] Missing configuration. Update environment.firebase.*');
    return null;
  }
  if (!initialised) {
    const app = initializeApp(environment.firebase);
    initialised = true;
    if (typeof window !== 'undefined' && environment.firebase.measurementId) {
      import('firebase/analytics')
        .then(({ getAnalytics }) => getAnalytics(app))
        .catch((error) => console.warn('Analytics init failed', error));
    }
  }
  authInstance = getAuth();
  return authInstance;
}
FILE: frontend/src/app/core/guards/admin-guard.ts
import { CanActivateFn } from '@angular/router';
export const adminGuard: CanActivateFn = (route, state) => {
  return true;
};
FILE: frontend/src/app/core/guards/auth-guard.ts
import { CanActivateFn, Router } from '@angular/router';
import { inject } from '@angular/core';
import { Auth } from '../services/auth';
export const authGuard: CanActivateFn = (_route, state) => {
  const auth = inject(Auth);
  const router = inject(Router);
  if (auth.isAuthenticated()) return true;
  auth.setRedirect(state.url);
  router.navigate(['/login']);
  return false;
};
FILE: frontend/src/app/core/guards/guest-guard.ts
import { CanActivateFn, Router } from '@angular/router';
import { inject } from '@angular/core';
import { Auth } from '../services/auth';
export const guestGuard: CanActivateFn = () => {
  const auth = inject(Auth);
  const router = inject(Router);
  if (auth.isAuthenticated()) {
    router.navigate(['/feed']);
    return false;
  }
  return true;
};
FILE: frontend/src/app/core/guards/role-guard.ts
import { CanActivateFn } from '@angular/router';
export const roleGuard: CanActivateFn = (route, state) => {
  return true;
};
FILE: frontend/src/app/core/interceptors/error-interceptor.ts
import { HttpErrorResponse, HttpInterceptorFn } from '@angular/common/http';
import { inject } from '@angular/core';
import { catchError, throwError } from 'rxjs';
import { Auth } from '../services/auth';
export const errorInterceptor: HttpInterceptorFn = (req, next) => {
  const auth = inject(Auth);
  return next(req).pipe(
    catchError((error: HttpErrorResponse) => {
      if (error.status === 401) auth.handleUnauthorized();
      return throwError(() => error);
    }),
  );
};
FILE: frontend/src/app/core/interceptors/jwt-interceptor.ts
import { HttpInterceptorFn } from '@angular/common/http';
import { inject } from '@angular/core';
import { Auth } from '../services/auth';
export const jwtInterceptor: HttpInterceptorFn = (req, next) => {
  const auth = inject(Auth);
  const token = auth.token();
  if (!token) return next(req);
  return next(
    req.clone({
      setHeaders: { Authorization: `Bearer ${token}` },
    }),
  );
};
FILE: frontend/src/app/core/models/auth.model.ts
export interface TokenResponseUser {
  id: number;
  username: string;
  email: string;
  avatar_url: string | null;
  role: string;
}
export interface TokenResponse {
  access_token: string;
  token_type: string;
  user: TokenResponseUser;
}
FILE: frontend/src/app/core/models/comment.model.ts
export interface Comment {
  id: number;
  postId: number;
  userId: number;
  parentId?: number | null;
  content: string;
  upvotes: number;
  downvotes: number;
  isDeleted: boolean;
  createdAt: string;
  updatedAt?: string | null;
  authorUsername: string;
  authorAvatar: string | null;
  userVote: 'up' | 'down' | null;
  replies: Comment[];
  isOp?: boolean;
}
FILE: frontend/src/app/core/models/notification.model.ts
export interface Notification {
  id: number;
  userId: number;
  type: string;
  message: string;
  link?: string | null;
  isRead: boolean;
  createdAt: string;
}
FILE: frontend/src/app/core/models/post.model.ts
export interface Post {
  id: number;
  userId: number;
  title: string;
  description: string | null;
  tag: string | null;
  imageUrl: string | null;
  upvotes: number;
  downvotes: number;
  commentCount: number;
  createdAt: string;
  updatedAt?: string | null;
  authorUsername: string;
  authorAvatar: string | null;
  userVote: 'up' | 'down' | null;
  isFavorited: boolean;
}
export interface PostList {
  posts: Post[];
  total: number;
  page: number;
  pageSize: number;
  hasMore: boolean;
}
FILE: frontend/src/app/core/models/user.model.ts
export interface User {
  id: number;
  username: string;
  email: string;
  avatarUrl: string | null;
  bio: string | null;
  role: string;
  createdAt: string;
}
FILE: frontend/src/app/core/services/auth.ts
import { Injectable, computed, inject, signal } from '@angular/core';
import { HttpClient, HttpErrorResponse } from '@angular/common/http';
import { Router } from '@angular/router';
import { environment } from '../config/environment';
import { getFirebaseAuth } from '../firebase/firebase';
import {
  GithubAuthProvider,
  GoogleAuthProvider,
  UserCredential,
  createUserWithEmailAndPassword,
  signInWithEmailAndPassword,
  signInWithPopup,
  signOut,
} from 'firebase/auth';
import { lastValueFrom } from 'rxjs';
import { TokenResponse } from '../models/auth.model';
import { User } from '../models/user.model';
@Injectable({ providedIn: 'root' })
export class Auth {
  private readonly http = inject(HttpClient);
  private readonly router = inject(Router);
  private readonly storageKey = environment.storageKeys.auth;
  private readonly userSignal = signal<User | null>(null);
  private readonly tokenSignal = signal<string | null>(null);
  private readonly readySignal = signal(false);
  private redirectUrl: string | null = null;
  readonly user = computed(() => this.userSignal());
  readonly isAuthenticated = computed(() => !!this.tokenSignal());
  readonly isReady = computed(() => this.readySignal());
  constructor() {
    this.restoreSession();
  }
  token(): string | null {
    return this.tokenSignal();
  }
  setRedirect(url: string) {
    this.redirectUrl = url;
  }
  async loginWithEmail(email: string, password: string) {
    const auth = this.ensureFirebase();
    const credentials = await signInWithEmailAndPassword(auth, email, password);
    await this.exchangeFirebaseToken(credentials);
  }
  async signupWithEmail(username: string, email: string, password: string) {
    const auth = this.ensureFirebase();
    const credentials = await createUserWithEmailAndPassword(auth, email, password);
    await this.registerWithBackend(credentials, username);
  }
  async loginWithGoogle() {
    const auth = this.ensureFirebase();
    const credentials = await signInWithPopup(auth, new GoogleAuthProvider());
    await this.exchangeFirebaseToken(credentials);
  }
  async loginWithGithub() {
    const auth = this.ensureFirebase();
    const credentials = await signInWithPopup(auth, new GithubAuthProvider());
    await this.exchangeFirebaseToken(credentials);
  }
  async logout() {
    const auth = getFirebaseAuth();
    if (auth) await signOut(auth);
    this.clearSession();
    await this.router.navigate(['/login']);
  }
  handleUnauthorized() {
    this.clearSession();
    this.router.navigate(['/login']);
  }
  private async registerWithBackend(credentials: UserCredential, username: string) {
    const idToken = await credentials.user.getIdToken();
    const email = credentials.user.email ?? this.buildFallbackEmail(credentials.user.uid);
    await lastValueFrom(
      this.http.post(`${environment.apiUrl}/auth/register`, {
        id_token: idToken,
        firebase_uid: credentials.user.uid,
        email,
        username,
        avatar_url: credentials.user.photoURL ?? null,
      }),
    );
    await this.exchangeFirebaseToken(credentials, false);
  }
  private async exchangeFirebaseToken(
    credentials: UserCredential,
    allowAutoRegister = true,
  ) {
    const idToken = await credentials.user.getIdToken();
    try {
      const response = await lastValueFrom(
        this.http.post<TokenResponse>(`${environment.apiUrl}/auth/login`, { id_token: idToken }),
      );
      const user = this.mapUser(response.user);
      this.persistSession(response.access_token, user);
      await this.router.navigateByUrl(this.redirectUrl ?? '/feed');
      this.redirectUrl = null;
    } catch (error) {
      if (
        allowAutoRegister &&
        error instanceof HttpErrorResponse &&
        error.status === 404
      ) {
        const username = this.generateUsername(
          credentials.user.displayName,
          credentials.user.email,
        );
        await this.registerWithBackend(credentials, username);
        return;
      }
      throw error;
    }
  }
  private mapUser(user: TokenResponse['user']): User {
    return {
      id: user.id,
      username: user.username,
      email: user.email,
      avatarUrl: user.avatar_url,
      bio: null,
      role: user.role ?? 'user',
      createdAt: new Date().toISOString(),
    };
  }
  private persistSession(token: string, user: User) {
    this.tokenSignal.set(token);
    this.userSignal.set(user);
    localStorage.setItem(this.storageKey, JSON.stringify({ token, user }));
  }
  private restoreSession() {
    const cache = localStorage.getItem(this.storageKey);
    if (cache) {
      try {
        const parsed = JSON.parse(cache) as { token: string; user: User };
        this.tokenSignal.set(parsed.token);
        this.userSignal.set(parsed.user);
      } catch (error) {
        console.warn('Failed to restore session', error);
        this.clearSession();
      }
    }
    this.readySignal.set(true);
  }
  private clearSession() {
    this.tokenSignal.set(null);
    this.userSignal.set(null);
    localStorage.removeItem(this.storageKey);
  }
  private ensureFirebase() {
    const auth = getFirebaseAuth();
    if (!auth) throw new Error('Firebase is not configured. Update environment.firebase.*');
    return auth;
  }
  private generateUsername(displayName?: string | null, email?: string | null): string {
    const sanitise = (value: string | null | undefined) =>
      value?.replace(/[^a-zA-Z0-9]/g, '').toLowerCase() ?? '';
    let base = sanitise(displayName);
    if (base.length < 3) {
      base = sanitise(email?.split('@')[0]);
    }
    if (base.length < 3) {
      base = 'user';
    }
    const suffix = Math.floor(Math.random() * 10_000)
      .toString()
      .padStart(4, '0');
    return `${base}${suffix}`.slice(0, 20);
  }
  private buildFallbackEmail(uid: string): string {
    return `${uid}@placeholder.local`;
  }
}
FILE: frontend/src/app/core/services/favorite.ts
import { Injectable, signal } from '@angular/core';
@Injectable({ providedIn: 'root' })
export class FavoriteState {
  private readonly favoritesChanged = signal<number>(0);
  readonly changed = this.favoritesChanged.asReadonly();
  notifyChange() {
    this.favoritesChanged.update(v => v + 1);
  }
}
FILE: frontend/src/app/core/services/notification.ts
import { HttpClient } from '@angular/common/http';
import {
  Injectable,
  computed,
  effect,
  inject,
  signal,
} from '@angular/core';
import { environment } from '../config/environment';
import { Auth } from './auth';
import { Notification } from '../models/notification.model';
import { Websocket } from './websocket';
interface RawNotification {
  id: number;
  user_id?: number;
  userId?: number;
  type?: string;
  message?: string;
  link?: string | null;
  is_read?: boolean;
  isRead?: boolean;
  created_at?: string;
  createdAt?: string;
}
interface NotificationListResponse {
  notifications: RawNotification[];
  unread_count: number;
}
@Injectable({ providedIn: 'root' })
export class NotificationService {
  private readonly http = inject(HttpClient);
  private readonly auth = inject(Auth);
  private readonly websocket = inject(Websocket);
  private readonly notificationsSignal = signal<Notification[]>([]);
  private readonly unreadCountSignal = signal(0);
  private readonly loadingSignal = signal(false);
  readonly notifications = this.notificationsSignal.asReadonly();
  readonly unreadCount = this.unreadCountSignal.asReadonly();
  readonly loading = this.loadingSignal.asReadonly();
  constructor() {
    effect(
      () => {
        if (this.auth.isAuthenticated()) {
          this.bootstrap();
          const handler = (payload: unknown) => this.handleIncoming(payload);
          this.websocket.registerHandler('notification', handler);
          return () => this.websocket.unregisterHandler('notification', handler);
        } else {
          this.notificationsSignal.set([]);
          this.unreadCountSignal.set(0);
        }
        return;
      },
      { allowSignalWrites: true },
    );
  }
  async bootstrap() {
    this.loadingSignal.set(true);
    try {
      const data = await this.http
        .get<NotificationListResponse>(`${environment.apiUrl}/users/me/notifications`)
        .toPromise();
      if (!data) return;
      const mapped = data.notifications.map((notification) => ({
        id: Number(notification.id),
        userId: Number(notification.userId ?? notification.user_id ?? 0),
        type: notification.type ?? 'notification',
        message: notification.message ?? '',
        link: notification.link ?? null,
        isRead: notification.isRead ?? notification.is_read ?? false,
        createdAt: notification.createdAt ?? notification.created_at ?? new Date().toISOString(),
      }));
      this.notificationsSignal.set(mapped);
      this.unreadCountSignal.set(data.unread_count);
    } finally {
      this.loadingSignal.set(false);
    }
  }
  async markAsRead(id: number) {
    await this.http
      .post(`${environment.apiUrl}/users/me/notifications/${id}/read`, {})
      .toPromise();
    this.notificationsSignal.update((list) =>
      list.map((notification) =>
        notification.id === id ? { ...notification, isRead: true } : notification,
      ),
    );
    this.unreadCountSignal.update((count) => Math.max(0, count - 1));
  }
  async markAllAsRead() {
    await this.http
      .post<{ message: string }>(`${environment.apiUrl}/users/me/notifications/read-all`, {})
      .toPromise();
    this.notificationsSignal.update((list) =>
      list.map((notification) => ({ ...notification, isRead: true })),
    );
    this.unreadCountSignal.set(0);
  }
  private handleIncoming(payload: unknown) {
    const data = (payload as { notification?: Partial<RawNotification> })?.notification;
    if (!data || !data.id) return;
    const normalised: Notification = {
      id: Number(data.id),
      userId: Number(data.userId ?? data.user_id ?? 0),
      type: data.type ?? 'notification',
      message: data.message ?? '',
      link: data.link ?? null,
      isRead: false,
      createdAt: String(data.createdAt ?? data.created_at ?? new Date().toISOString()),
    };
    this.notificationsSignal.update((list) => [
      normalised,
      ...list.filter((notification) => notification.id !== normalised.id),
    ]);
    this.unreadCountSignal.update((count) => count + 1);
  }
}
FILE: frontend/src/app/core/services/theme.ts
import { Injectable } from '@angular/core';
@Injectable({
  providedIn: 'root',
})
export class Theme {
}
FILE: frontend/src/app/core/services/vote-state.ts
import { Injectable, inject, signal, computed, effect } from '@angular/core';
import { Websocket, VoteUpdate } from './websocket';
import { Auth } from './auth';
interface VoteCache {
  upvotes: number;
  downvotes: number;
  userVote: 'up' | 'down' | null;
  timestamp: number;
}
@Injectable({ providedIn: 'root' })
export class VoteState {
  private readonly websocket = inject(Websocket);
  private readonly auth = inject(Auth);
  private readonly postVotes = signal<Map<number, VoteCache>>(new Map());
  private readonly commentVotes = signal<Map<number, VoteCache>>(new Map());
  private readonly pendingVotes = signal<Set<string>>(new Set());
  constructor() {
    effect(() => {
      if (this.auth.isAuthenticated()) {
        this.initializeWebSocket();
      }
    }, { allowSignalWrites: true });
  }
  private initializeWebSocket() {
    this.websocket.registerHandler('vote_update', (payload: unknown) => {
      this.handleVoteUpdate(payload as VoteUpdate);
    });
  }
  private handleVoteUpdate(update: VoteUpdate) {
    const userId = this.auth.user()?.id;
    if (!userId) return;
    const userVote = update.userVotes[userId] ?? null;
    const cache: VoteCache = {
      upvotes: update.upvotes,
      downvotes: update.downvotes,
      userVote,
      timestamp: Date.now()
    };
    if (update.commentId) {
      this.commentVotes.update(map => {
        const newMap = new Map(map);
        newMap.set(update.commentId!, cache);
        return newMap;
      });
    } else {
      this.postVotes.update(map => {
        const newMap = new Map(map);
        newMap.set(update.postId, cache);
        return newMap;
      });
    }
    const voteKey = update.commentId
      ? `comment-${update.commentId}`
      : `post-${update.postId}`;
    this.pendingVotes.update(set => {
      const newSet = new Set(set);
      newSet.delete(voteKey);
      return newSet;
    });
  }
  getPostVote(postId: number): VoteCache | null {
    return this.postVotes().get(postId) ?? null;
  }
  getCommentVote(commentId: number): VoteCache | null {
    return this.commentVotes().get(commentId) ?? null;
  }
  isPending(type: 'post' | 'comment', id: number): boolean {
    const key = `${type}-${id}`;
    return this.pendingVotes().has(key);
  }
  setPending(type: 'post' | 'comment', id: number, pending: boolean) {
    const key = `${type}-${id}`;
    this.pendingVotes.update(set => {
      const newSet = new Set(set);
      if (pending) {
        newSet.add(key);
      } else {
        newSet.delete(key);
      }
      return newSet;
    });
  }
  optimisticVote(type: 'post' | 'comment', id: number, vote: 'up' | 'down' | null, currentVote: 'up' | 'down' | null) {
    const map = type === 'post' ? this.postVotes : this.commentVotes;
    const current = (type === 'post' ? this.getPostVote(id) : this.getCommentVote(id)) ?? {
      upvotes: 0,
      downvotes: 0,
      userVote: currentVote,
      timestamp: Date.now()
    };
    let newUpvotes = current.upvotes;
    let newDownvotes = current.downvotes;
    if (currentVote === 'up') newUpvotes--;
    else if (currentVote === 'down') newDownvotes--;
    if (vote === 'up') newUpvotes++;
    else if (vote === 'down') newDownvotes++;
    const optimisticCache: VoteCache = {
      upvotes: newUpvotes,
      downvotes: newDownvotes,
      userVote: vote,
      timestamp: Date.now()
    };
    map.update(m => {
      const newMap = new Map(m);
      newMap.set(id, optimisticCache);
      return newMap;
    });
  }
}
FILE: frontend/src/app/core/services/websocket.ts
import { inject, Injectable, signal, effect } from '@angular/core';
import { environment } from '../config/environment';
import { Auth } from './auth';
type Handler = (payload: unknown) => void;
export interface VoteUpdate {
  postId: number;
  commentId?: number;
  upvotes: number;
  downvotes: number;
  userVotes: { [userId: number]: 'up' | 'down' | null };
}
@Injectable({ providedIn: 'root' })
export class Websocket {
  private readonly auth = inject(Auth);
  private socket: WebSocket | null = null;
  private readonly handlers = new Map<string, Set<Handler>>();
  private reconnectAttempts = 0;
  private readonly connecting = signal(false);
  private readonly connected = signal(false);
  readonly isConnected = this.connected.asReadonly();
  constructor() {
    effect(() => {
      if (this.auth.isAuthenticated()) {
        this.connect();
      } else {
        this.disconnect();
      }
    });
  }
  registerHandler(type: string, handler: Handler) {
    if (!this.handlers.has(type)) {
      this.handlers.set(type, new Set());
    }
    this.handlers.get(type)!.add(handler);
    if (this.connected() && type === 'vote') {
      this.send({ type: 'subscribe_votes' });
    }
  }
  unregisterHandler(type: string, handler: Handler) {
    this.handlers.get(type)?.delete(handler);
  }
  send(message: unknown) {
    if (this.socket?.readyState === WebSocket.OPEN) {
      this.socket.send(JSON.stringify(message));
    } else {
      console.warn('WebSocket not connected, queuing message');
    }
  }
  private connect() {
    if (this.connecting() || this.socket?.readyState === WebSocket.OPEN) {
      return;
    }
    const token = this.auth.token();
    if (!token) return;
    this.connecting.set(true);
    const url = new URL(environment.websocketUrl);
    url.searchParams.set('token', token);
    this.socket = new WebSocket(url.toString());
    this.socket.onopen = () => {
      console.log('WebSocket connected');
      this.reconnectAttempts = 0;
      this.connecting.set(false);
      this.connected.set(true);
      this.send({ type: 'subscribe_votes' });
    };
    this.socket.onmessage = (event) => {
      try {
        const data = JSON.parse(event.data);
        const type = data?.type ?? 'message';
        this.handlers.get(type)?.forEach((handler) => handler(data));
        if (type === 'vote_update') {
          this.handlers.get('vote')?.forEach((handler) => handler(data));
        }
      } catch (error) {
        console.error('Failed to parse WebSocket message', error);
      }
    };
    this.socket.onclose = () => {
      console.log('WebSocket disconnected');
      this.socket = null;
      this.connecting.set(false);
      this.connected.set(false);
      this.scheduleReconnect();
    };
    this.socket.onerror = (error) => {
      console.error('WebSocket error', error);
      this.socket?.close();
    };
  }
  private scheduleReconnect() {
    if (!this.auth.isAuthenticated()) return;
    const delay = Math.min(30000, 1000 * 2 ** this.reconnectAttempts);
    this.reconnectAttempts += 1;
    console.log(`Reconnecting WebSocket in ${delay}ms (attempt ${this.reconnectAttempts})`);
    setTimeout(() => {
      if (this.auth.isAuthenticated()) {
        this.connect();
      }
    }, delay);
  }
  private disconnect() {
    this.handlers.clear();
    this.socket?.close();
    this.socket = null;
    this.reconnectAttempts = 0;
    this.connecting.set(false);
    this.connected.set(false);
  }
}
FILE: frontend/src/app/features/auth/login/login.css
.auth-container {
  min-height: 100vh;
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 20px;
  background: linear-gradient(135deg, var(--bg-primary) 0%, var(--bg-secondary) 100%);
}
.auth-card {
  width: 100%;
  max-width: 400px;
  background-color: var(--bg-secondary);
  border: 1px solid var(--border-primary);
  border-radius: 8px;
  padding: 32px;
}
.auth-header {
  text-align: center;
  margin-bottom: 32px;
}
.logo {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 12px;
  margin-bottom: 8px;
}
.logo-icon {
  font-size: 32px;
}
.logo h1 {
  font-size: 28px;
  font-weight: 700;
  color: var(--primary-orange);
  margin: 0;
}
.auth-subtitle {
  color: var(--text-secondary);
  font-size: 14px;
  margin: 0;
}
.auth-form {
  display: flex;
  flex-direction: column;
  gap: 20px;
}
.form-group {
  display: flex;
  flex-direction: column;
  gap: 8px;
}
.form-group label {
  font-size: 12px;
  font-weight: 600;
  color: var(--text-secondary);
  text-transform: uppercase;
  letter-spacing: 0.5px;
}
.form-input {
  padding: 12px;
  background-color: var(--bg-tertiary);
  border: 1px solid var(--border-primary);
  border-radius: 4px;
  color: var(--text-primary);
  font-family: 'JetBrains Mono', monospace;
  font-size: 14px;
  outline: none;
  transition: all 0.2s;
}
.form-input:focus {
  border-color: var(--primary-orange);
  background-color: var(--bg-primary);
}
.form-input.error {
  border-color: var(--error);
}
.password-input-wrapper {
  position: relative;
}
.password-toggle {
  position: absolute;
  right: 12px;
  top: 50%;
  transform: translateY(-50%);
  background: none;
  border: none;
  color: var(--text-secondary);
  cursor: pointer;
  padding: 4px;
}
.password-toggle:hover {
  color: var(--text-primary);
}
.error-message {
  font-size: 12px;
  color: var(--error);
  margin-top: 4px;
}
.form-options {
  display: flex;
  justify-content: space-between;
  align-items: center;
}
.checkbox-label {
  display: flex;
  align-items: center;
  gap: 8px;
  color: var(--text-secondary);
  font-size: 14px;
  cursor: pointer;
}
.checkbox-label input[type="checkbox"] {
  width: 16px;
  height: 16px;
  accent-color: var(--primary-orange);
}
.forgot-link {
  color: var(--primary-orange);
  text-decoration: none;
  font-size: 14px;
}
.forgot-link:hover {
  text-decoration: underline;
}
.alert {
  padding: 12px;
  border-radius: 4px;
  font-size: 14px;
}
.alert-error {
  background-color: rgba(234, 0, 39, 0.1);
  border: 1px solid var(--error);
  color: var(--error);
}
.submit-btn {
  padding: 14px;
  background-color: var(--primary-orange);
  color: white;
  border: none;
  border-radius: 4px;
  font-family: 'JetBrains Mono', monospace;
  font-size: 16px;
  font-weight: 600;
  cursor: pointer;
  transition: background-color 0.2s;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 8px;
}
.submit-btn:hover:not(:disabled) {
  background-color: var(--primary-orange-light);
}
.submit-btn:disabled {
  opacity: 0.6;
  cursor: not-allowed;
}
.spinner-small {
  width: 16px;
  height: 16px;
  border: 2px solid rgba(255, 255, 255, 0.3);
  border-top-color: white;
  border-radius: 50%;
  animation: spin 0.6s linear infinite;
}
.divider {
  position: relative;
  text-align: center;
  margin: 20px 0;
}
.divider::before {
  content: '';
  position: absolute;
  top: 50%;
  left: 0;
  right: 0;
  height: 1px;
  background-color: var(--border-primary);
}
.divider span {
  position: relative;
  padding: 0 16px;
  background-color: var(--bg-secondary);
  color: var(--text-secondary);
  font-size: 12px;
  text-transform: uppercase;
}
.oauth-btn {
  padding: 12px;
  background-color: var(--bg-tertiary);
  border: 1px solid var(--border-primary);
  border-radius: 4px;
  color: var(--text-primary);
  font-family: 'JetBrains Mono', monospace;
  font-size: 14px;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.2s;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 12px;
}
.oauth-btn:hover {
  background-color: var(--bg-hover);
  border-color: var(--border-secondary);
}
.oauth-btn img {
  width: 20px;
  height: 20px;
}
.auth-footer {
  margin-top: 24px;
  text-align: center;
  padding-top: 24px;
  border-top: 1px solid var(--border-primary);
}
.auth-footer p {
  color: var(--text-secondary);
  font-size: 14px;
}
.auth-footer a {
  color: var(--primary-orange);
  text-decoration: none;
  font-weight: 500;
}
.auth-footer a:hover {
  text-decoration: underline;
}
@keyframes spin {
  to { transform: rotate(360deg); }
}
FILE: frontend/src/app/features/auth/login/login.html
<div class="auth-container">
  <div class="auth-card">
    <div class="auth-header">
      <div class="logo">
        <span class="logo-icon">ğŸ”¥</span>
        <h1>MemeForum</h1>
      </div>
      <p class="auth-subtitle">Welcome back, meme lord!</p>
    </div>

    <form [formGroup]="loginForm" (ngSubmit)="onSubmit()" class="auth-form">
      <div class="form-group">
        <label for="email">Email</label>
        <input
          id="email"
          type="email"
          formControlName="email"
          class="form-input"
          placeholder="your@email.com"
          [class.error]="isFieldInvalid('email')"
        >
        @if (isFieldInvalid('email')) {
          <span class="error-message">Please enter a valid email</span>
        }
      </div>

      <div class="form-group">
        <label for="password">Password</label>
        <div class="password-input-wrapper">
          <input
            id="password"
            [type]="showPassword() ? 'text' : 'password'"
            formControlName="password"
            class="form-input"
            placeholder="â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢"
            [class.error]="isFieldInvalid('password')"
          >
          <button
            type="button"
            class="password-toggle"
            (click)="togglePassword()"
          >
            <span class="material-icons">
              {{ showPassword() ? 'visibility_off' : 'visibility' }}
            </span>
          </button>
        </div>
        @if (isFieldInvalid('password')) {
          <span class="error-message">Password is required</span>
        }
      </div>

      <div class="form-options">
        <label class="checkbox-label">
          <input type="checkbox" formControlName="rememberMe">
          <span>Remember me</span>
        </label>
        <a routerLink="/forgot-password" class="forgot-link">Forgot password?</a>
      </div>

      @if (errorMessage()) {
        <div class="alert alert-error">
          {{ errorMessage() }}
        </div>
      }

      <button
        type="submit"
        class="submit-btn"
        [disabled]="loginForm.invalid || isLoading()"
      >
        @if (isLoading()) {
          <span class="spinner-small"></span>
          <span>Logging in...</span>
        } @else {
          <span>Login</span>
        }
      </button>

      <div class="divider">
        <span>OR</span>
      </div>

      <button type="button" class="oauth-btn google" (click)="loginWithGoogle()">
        <img src="https://www.gstatic.com/firebasejs/ui/2.0.0/images/auth/google.svg" alt="Google">
        <span>Continue with Google</span>
      </button>

      <button type="button" class="oauth-btn github" (click)="loginWithGithub()">
        <span class="material-icons">code</span>
        <span>Continue with GitHub</span>
      </button>
    </form>

    <div class="auth-footer">
      <p>New to MemeForum? <a routerLink="/signup">Create an account</a></p>
    </div>
  </div>
</div>
FILE: frontend/src/app/features/auth/login/login.ts
import { ChangeDetectionStrategy, Component, inject, signal } from '@angular/core';
import { FormBuilder, FormGroup, ReactiveFormsModule, Validators } from '@angular/forms';
import { RouterLink } from '@angular/router';
import { Auth } from '../../../core/services/auth';
@Component({
  selector: 'app-login',
  standalone: true,
  imports: [ReactiveFormsModule, RouterLink],
  templateUrl: './login.html',
  styleUrls: ['./login.css'],
  changeDetection: ChangeDetectionStrategy.OnPush,
})
export class Login {
  private readonly fb = inject(FormBuilder);
  private readonly auth = inject(Auth);
  readonly loginForm: FormGroup = this.fb.group({
    email: ['', [Validators.required, Validators.email]],
    password: ['', [Validators.required, Validators.minLength(6)]],
    rememberMe: [false],
  });
  readonly showPassword = signal(false);
  readonly isLoading = signal(false);
  readonly errorMessage = signal('');
  togglePassword() {
    this.showPassword.update((value) => !value);
  }
  isFieldInvalid(field: string) {
    const control = this.loginForm.get(field);
    return !!(control && control.invalid && (control.dirty || control.touched));
  }
  async onSubmit() {
    if (this.loginForm.invalid) {
      Object.keys(this.loginForm.controls).forEach((key) => this.loginForm.get(key)?.markAsTouched());
      return;
    }
    this.isLoading.set(true);
    this.errorMessage.set('');
    try {
      await this.auth.loginWithEmail(
        this.loginForm.get('email')?.value,
        this.loginForm.get('password')?.value,
      );
    } catch (error) {
      console.error('Login failed', error);
      this.errorMessage.set('Invalid credentials or Firebase not configured.');
    } finally {
      this.isLoading.set(false);
    }
  }
  async loginWithGoogle() {
    this.isLoading.set(true);
    this.errorMessage.set('');
    try {
      await this.auth.loginWithGoogle();
    } catch (error) {
      console.error('Google login failed', error);
      this.errorMessage.set('Google login failed.');
    } finally {
      this.isLoading.set(false);
    }
  }
  async loginWithGithub() {
    this.isLoading.set(true);
    this.errorMessage.set('');
    try {
      await this.auth.loginWithGithub();
    } catch (error) {
      console.error('GitHub login failed', error);
      this.errorMessage.set('GitHub login failed.');
    } finally {
      this.isLoading.set(false);
    }
  }
}
FILE: frontend/src/app/features/auth/signup/signup.css
.password-strength {
  margin-top: 8px;
  display: flex;
  align-items: center;
  gap: 8px;
}
.strength-bar {
  flex: 1;
  height: 4px;
  background-color: var(--bg-tertiary);
  border-radius: 2px;
  overflow: hidden;
}
.strength-fill {
  height: 100%;
  transition: width 0.3s, background-color 0.3s;
}
.strength-fill.weak {
  background-color: var(--error);
}
.strength-fill.medium {
  background-color: var(--warning);
}
.strength-fill.strong {
  background-color: var(--success);
}
.strength-text {
  font-size: 12px;
  color: var(--text-secondary);
  min-width: 60px;
}
FILE: frontend/src/app/features/auth/signup/signup.html
<div class="auth-container">
  <div class="auth-card">
    <div class="auth-header">
      <div class="logo">
        <span class="logo-icon">ğŸ”¥</span>
        <h1>MemeForum</h1>
      </div>
      <p class="auth-subtitle">Join the meme revolution!</p>
    </div>

    <form [formGroup]="signupForm" (ngSubmit)="onSubmit()" class="auth-form">
      <div class="form-group">
        <label for="username">Username</label>
        <input
          id="username"
          type="text"
          formControlName="username"
          class="form-input"
          placeholder="memeLord420"
          [class.error]="isFieldInvalid('username')"
        >
        @if (isFieldInvalid('username')) {
          <span class="error-message">Username must be 3-20 characters</span>
        }
      </div>

      <div class="form-group">
        <label for="email">Email</label>
        <input
          id="email"
          type="email"
          formControlName="email"
          class="form-input"
          placeholder="your@email.com"
          [class.error]="isFieldInvalid('email')"
        >
        @if (isFieldInvalid('email')) {
          <span class="error-message">Please enter a valid email</span>
        }
      </div>

      <div class="form-group">
        <label for="password">Password</label>
        <div class="password-input-wrapper">
          <input
            id="password"
            [type]="showPassword() ? 'text' : 'password'"
            formControlName="password"
            class="form-input"
            placeholder="â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢"
            [class.error]="isFieldInvalid('password')"
          >
          <button
            type="button"
            class="password-toggle"
            (click)="togglePassword()"
          >
            <span class="material-icons">
              {{ showPassword() ? 'visibility_off' : 'visibility' }}
            </span>
          </button>
        </div>
        @if (isFieldInvalid('password')) {
          <span class="error-message">Password must be at least 6 characters</span>
        }

        <div class="password-strength">
          <div class="strength-bar">
            <div
              class="strength-fill"
              [style.width.%]="passwordStrength()"
              [class.weak]="passwordStrength() <= 33"
              [class.medium]="passwordStrength() > 33 && passwordStrength() <= 66"
              [class.strong]="passwordStrength() > 66"
            ></div>
          </div>
          <span class="strength-text">{{ getPasswordStrengthText() }}</span>
        </div>
      </div>

      <div class="form-group">
        <label for="confirmPassword">Confirm Password</label>
        <input
          id="confirmPassword"
          [type]="showPassword() ? 'text' : 'password'"
          formControlName="confirmPassword"
          class="form-input"
          placeholder="â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢"
          [class.error]="isFieldInvalid('confirmPassword')"
        >
        @if (isFieldInvalid('confirmPassword')) {
          <span class="error-message">Passwords do not match</span>
        }
      </div>

      <div class="form-options">
        <label class="checkbox-label">
          <input type="checkbox" formControlName="agreeToTerms">
          <span>I agree to the <a href="/terms" target="_blank">Terms of Service</a></span>
        </label>
      </div>

      @if (errorMessage()) {
        <div class="alert alert-error">
          {{ errorMessage() }}
        </div>
      }

      <button
        type="submit"
        class="submit-btn"
        [disabled]="signupForm.invalid || isLoading()"
      >
        @if (isLoading()) {
          <span class="spinner-small"></span>
          <span>Creating account...</span>
        } @else {
          <span>Sign Up</span>
        }
      </button>

      <div class="divider">
        <span>OR</span>
      </div>

      <button type="button" class="oauth-btn google" (click)="signupWithGoogle()">
        <img src="https://www.gstatic.com/firebasejs/ui/2.0.0/images/auth/google.svg" alt="Google">
        <span>Sign up with Google</span>
      </button>

      <button type="button" class="oauth-btn github" (click)="signupWithGithub()">
        <span class="material-icons">code</span>
        <span>Sign up with GitHub</span>
      </button>
    </form>

    <div class="auth-footer">
      <p>Already have an account? <a routerLink="/login">Login</a></p>
    </div>
  </div>
</div>
FILE: frontend/src/app/features/auth/signup/signup.ts
import { ChangeDetectionStrategy, Component, computed, inject, signal } from '@angular/core';
import {
  AbstractControl,
  FormBuilder,
  FormGroup,
  ReactiveFormsModule,
  Validators,
} from '@angular/forms';
import { RouterLink } from '@angular/router';
import { Auth } from '../../../core/services/auth';
@Component({
  selector: 'app-signup',
  standalone: true,
  imports: [ReactiveFormsModule, RouterLink],
  templateUrl: './signup.html',
  styleUrls: ['./signup.css'],
  changeDetection: ChangeDetectionStrategy.OnPush,
})
export class Signup {
  private readonly fb = inject(FormBuilder);
  private readonly auth = inject(Auth);
  readonly showPassword = signal(false);
  readonly isLoading = signal(false);
  readonly errorMessage = signal('');
  readonly signupForm: FormGroup = this.fb.group(
    {
      username: ['', [Validators.required, Validators.minLength(3), Validators.maxLength(20)]],
      email: ['', [Validators.required, Validators.email]],
      password: ['', [Validators.required, Validators.minLength(6)]],
      confirmPassword: ['', [Validators.required]],
      agreeToTerms: [false, [Validators.requiredTrue]],
    },
    { validators: this.passwordMatchValidator },
  );
  readonly passwordStrength = computed(() => {
    const password = this.signupForm.get('password')?.value || '';
    if (!password) return 0;
    let strength = 0;
    if (password.length >= 6) strength += 25;
    if (password.length >= 10) strength += 25;
    if (/[a-z]/.test(password) && /[A-Z]/.test(password)) strength += 25;
    if (/[0-9]/.test(password)) strength += 12.5;
    if (/[^a-zA-Z0-9]/.test(password)) strength += 12.5;
    return Math.min(100, strength);
  });
  passwordMatchValidator(control: AbstractControl) {
    const password = control.get('password');
    const confirmPassword = control.get('confirmPassword');
    if (password?.value !== confirmPassword?.value) {
      confirmPassword?.setErrors({ mismatch: true });
      return { mismatch: true };
    }
    return null;
  }
  togglePassword() {
    this.showPassword.update((value) => !value);
  }
  isFieldInvalid(field: string) {
    const control = this.signupForm.get(field);
    return !!(control && control.invalid && (control.dirty || control.touched));
  }
  getPasswordStrengthText() {
    const strength = this.passwordStrength();
    if (strength <= 33) return 'Weak';
    if (strength <= 66) return 'Medium';
    return 'Strong';
  }
  async onSubmit() {
    if (this.signupForm.invalid) {
      Object.keys(this.signupForm.controls).forEach((key) => this.signupForm.get(key)?.markAsTouched());
      return;
    }
    this.isLoading.set(true);
    this.errorMessage.set('');
    try {
      await this.auth.signupWithEmail(
        this.signupForm.get('username')?.value,
        this.signupForm.get('email')?.value,
        this.signupForm.get('password')?.value,
      );
    } catch (error) {
      console.error('Signup failed', error);
      this.errorMessage.set('Failed to create account. Check Firebase configuration.');
    } finally {
      this.isLoading.set(false);
    }
  }
  async signupWithGoogle() {
    this.isLoading.set(true);
    this.errorMessage.set('');
    try {
      await this.auth.loginWithGoogle();
    } catch (error) {
      console.error('Google signup failed', error);
      this.errorMessage.set('Google signup failed.');
    } finally {
      this.isLoading.set(false);
    }
  }
  async signupWithGithub() {
    this.isLoading.set(true);
    this.errorMessage.set('');
    try {
      await this.auth.loginWithGithub();
    } catch (error) {
      console.error('GitHub signup failed', error);
      this.errorMessage.set('GitHub signup failed.');
    } finally {
      this.isLoading.set(false);
    }
  }
}
FILE: frontend/src/app/features/comments/comment-form/comment-form.css
.comment-form-container {
  margin-bottom: 24px;
}
.comment-form-header {
  display: flex;
  align-items: center;
  gap: 12px;
  margin-bottom: 12px;
}
.comment-as {
  color: var(--text-secondary);
  font-size: 14px;
}
.comment-as strong {
  color: var(--text-primary);
}
.comment-editor {
  background-color: var(--bg-tertiary);
  border: 1px solid var(--border-primary);
  border-radius: 4px;
  overflow: hidden;
  transition: border-color 0.2s;
}
.comment-editor:focus-within {
  border-color: var(--primary-orange);
}
.comment-textarea {
  width: 100%;
  padding: 12px;
  background: transparent;
  border: none;
  color: var(--text-primary);
  font-family: 'JetBrains Mono', monospace;
  font-size: 14px;
  line-height: 1.5;
  resize: vertical;
  outline: none;
  min-height: 100px;
}
.comment-textarea::placeholder {
  color: var(--text-muted);
}
.comment-toolbar {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 8px 12px;
  background-color: var(--bg-secondary);
  border-top: 1px solid var(--border-primary);
}
.toolbar-buttons {
  display: flex;
  gap: 4px;
}
.toolbar-btn {
  background: none;
  border: none;
  color: var(--text-secondary);
  cursor: pointer;
  padding: 6px;
  border-radius: 4px;
  transition: all 0.2s;
  display: flex;
  align-items: center;
  justify-content: center;
}
.toolbar-btn:hover {
  background-color: var(--bg-hover);
  color: var(--text-primary);
}
.toolbar-btn .material-icons {
  font-size: 18px;
}
.comment-actions {
  display: flex;
  gap: 8px;
}
.cancel-btn {
  padding: 6px 16px;
  background: none;
  border: 1px solid var(--border-primary);
  border-radius: 20px;
  color: var(--text-primary);
  font-family: 'JetBrains Mono', monospace;
  font-size: 14px;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.2s;
}
.cancel-btn:hover {
  background-color: var(--bg-hover);
}
.submit-comment-btn {
  padding: 6px 16px;
  background-color: var(--primary-orange);
  border: none;
  border-radius: 20px;
  color: white;
  font-family: 'JetBrains Mono', monospace;
  font-size: 14px;
  font-weight: 500;
  cursor: pointer;
  transition: background-color 0.2s;
  display: flex;
  align-items: center;
  gap: 6px;
}
.submit-comment-btn:hover:not(:disabled) {
  background-color: var(--primary-orange-light);
}
.submit-comment-btn:disabled {
  opacity: 0.6;
  cursor: not-allowed;
}
.spinner-small {
  width: 14px;
  height: 14px;
  border: 2px solid rgba(255, 255, 255, 0.3);
  border-top-color: white;
  border-radius: 50%;
  animation: spin 0.6s linear infinite;
}
@keyframes spin {
  to { transform: rotate(360deg); }
}
FILE: frontend/src/app/features/comments/comment-form/comment-form.html
<div class="comment-form-container">
  <div class="comment-form-header">
    <app-user-avatar
      [size]="32"
      [username]="currentUser()"
      [imageUrl]="currentUserAvatar()"
    ></app-user-avatar>
    <span class="comment-as">Comment as <strong>{{ currentUser() }}</strong></span>
  </div>

  <form [formGroup]="commentForm" (ngSubmit)="onSubmit()">
    <div class="comment-editor">
      <textarea
        formControlName="content"
        class="comment-textarea"
        placeholder="What are your thoughts?"
        rows="4"
        [class.focused]="isFocused()"
        (focus)="isFocused.set(true)"
        (blur)="handleBlur()"
      ></textarea>

      @if (isFocused() || commentForm.get('content')?.value) {
        <div class="comment-toolbar">


          <div class="comment-actions" style="margin-left: auto;">
            @if (isReplying()) {
              <button type="button" class="cancel-btn" (click)="cancel()">
                Cancel
              </button>
            }
            <button
              type="submit"
              class="submit-comment-btn"
              [disabled]="commentForm.invalid || isSubmitting()"
            >
              @if (isSubmitting()) {
                <span class="spinner-small"></span>
              }
              {{ isReplying() ? 'Reply' : 'Comment' }}
            </button>
          </div>
        </div>
      }
    </div>
  </form>
</div>
FILE: frontend/src/app/features/comments/comment-form/comment-form.ts
import { ChangeDetectionStrategy, Component, inject, input, output, signal, computed } from '@angular/core';
import { FormBuilder, FormGroup, Validators, ReactiveFormsModule } from '@angular/forms';
import { UserAvatar } from '../../../shared/components/user-avatar/user-avatar';
import { Auth } from '../../../core/services/auth';
@Component({
  selector: 'app-comment-form',
  standalone: true,
  imports: [ReactiveFormsModule, UserAvatar],
  templateUrl: './comment-form.html',
  styleUrl: './comment-form.css',
  changeDetection: ChangeDetectionStrategy.OnPush,
})
export class CommentForm {
  private readonly fb = inject(FormBuilder);
  private readonly auth = inject(Auth);
  parentCommentId = input<number | null>(null);
  isReplying = input<boolean>(false);
  readonly submit = output<string>();
  readonly cancelReply = output<void>();
  readonly commentForm: FormGroup = this.fb.group({
    content: ['', [Validators.required, Validators.minLength(1)]],
  });
  readonly isFocused = signal(false);
  readonly isSubmitting = signal(false);
  readonly currentUser = computed(() => this.auth.user()?.username ?? 'You');
  readonly currentUserAvatar = computed(() => this.auth.user()?.avatarUrl ?? '');
  async onSubmit() {
    if (this.commentForm.invalid) return;
    this.isSubmitting.set(true);
    try {
      this.submit.emit(this.commentForm.get('content')?.value);
      this.commentForm.reset();
      this.isFocused.set(false);
    } finally {
      this.isSubmitting.set(false);
    }
  }
  cancel() {
    this.commentForm.reset();
    this.isFocused.set(false);
    this.cancelReply.emit();
  }
  handleBlur() {
    if (!this.commentForm.get('content')?.value) {
      this.isFocused.set(false);
    }
  }
}
FILE: frontend/src/app/features/comments/comment-item/comment-item.css
.comment-item {
  position: relative;
  margin-bottom: 16px;
}
.comment-thread-line {
  position: absolute;
  left: -12px;
  top: 0;
  bottom: 0;
  width: 2px;
  background-color: var(--border-primary);
}
.comment-content {
  background-color: var(--bg-tertiary);
  border-radius: 4px;
  padding: 12px;
}
.comment-header {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 8px;
}
.comment-author {
  color: var(--text-primary);
  font-weight: 600;
  font-size: 13px;
  text-decoration: none;
}
.comment-author:hover {
  color: var(--primary-orange);
  text-decoration: underline;
}
.op-badge {
  padding: 2px 6px;
  background-color: var(--primary-orange);
  color: white;
  border-radius: 10px;
  font-size: 10px;
  font-weight: 700;
  text-transform: uppercase;
}
.comment-time {
  color: var(--text-muted);
  font-size: 12px;
  margin-left: auto;
}
.comment-body {
  color: var(--text-primary);
  line-height: 1.5;
  margin-bottom: 12px;
  white-space: pre-wrap;
  word-break: break-word;
}
.comment-footer {
  display: flex;
  align-items: center;
  gap: 8px;
}
.comment-action {
  display: flex;
  align-items: center;
  gap: 4px;
  padding: 4px 8px;
  background: none;
  border: none;
  color: var(--text-secondary);
  font-family: 'JetBrains Mono', monospace;
  font-size: 12px;
  font-weight: 500;
  cursor: pointer;
  border-radius: 4px;
  transition: all 0.2s;
}
.comment-action:hover {
  background-color: var(--bg-hover);
  color: var(--text-primary);
}
.comment-action .material-icons {
  font-size: 16px;
}
.reply-form-container {
  margin-top: 12px;
  padding-top: 12px;
  border-top: 1px solid var(--border-primary);
}
.comment-replies {
  margin-top: 16px;
}
.comment-item .comment-item .comment-content {
  background-color: var(--bg-secondary);
}
.comment-item[style*="margin-left: 120px"] .comment-thread-line {
  background: linear-gradient(to bottom, var(--border-primary), transparent);
}
FILE: frontend/src/app/features/comments/comment-item/comment-item.html
<div class="comment-item" [style.margin-left.px]="depth() * 24">
  @if (depth() > 0) {
    <div class="comment-thread-line"></div>
  }

  <div class="comment-content">
    <div class="comment-header">
      <app-user-avatar
        [username]="comment().authorUsername"
        [imageUrl]="comment().authorAvatar ?? ''"
        [size]="24"
      ></app-user-avatar>
      <a [routerLink]="['/profile', comment().authorUsername]" class="comment-author">
        {{ comment().authorUsername }}
      </a>
      @if (comment().isOp) {
        <span class="op-badge">OP</span>
      }
      <span class="comment-time">{{ formatTime(comment().createdAt) }}</span>
    </div>

    <div class="comment-body">
      {{ comment().content }}
    </div>

    <div class="comment-footer">
      <app-vote-buttons
        [upvotes]="comment().upvotes"
        [downvotes]="comment().downvotes"
        [userVote]="comment().userVote"
        [orientation]="'horizontal'"
        (vote)="onVoteClick($event)"
      ></app-vote-buttons>

      <button class="comment-action" (click)="toggleReply()">
        <span class="material-icons">reply</span>
        <span>Reply</span>
      </button>

      @if (canModerate()) {
        <button class="comment-action" (click)="deleteComment()">
          <span class="material-icons">delete</span>
          <span>Delete</span>
        </button>
      }


    </div>

    @if (showReplyForm()) {
      <div class="reply-form-container">
        <app-comment-form
          [isReplying]="true"
          (submit)="submitReply($event)"
          (cancelReply)="toggleReply()"
        ></app-comment-form>
      </div>
    }

    @if (comment().replies.length > 0) {
      <div class="comment-replies">
        @for (reply of comment().replies; track reply.id) {
          <app-comment-item
            [comment]="reply"
            [depth]="depth() + 1"
            (reply)="onNestedReply($event)"
            (vote)="onNestedVote($event)"
            (delete)="onNestedDelete($event)"
          ></app-comment-item>
        }
      </div>
    }
  </div>
</div>
FILE: frontend/src/app/features/comments/comment-item/comment-item.ts
import { ChangeDetectionStrategy, Component, input, output, signal } from '@angular/core';
import { RouterLink } from '@angular/router';
import { Comment } from '../../../core/models/comment.model';
import { UserAvatar } from '../../../shared/components/user-avatar/user-avatar';
import { VoteButtons } from '../../../shared/components/vote-buttons/vote-buttons';
import { CommentForm } from '../comment-form/comment-form';
@Component({
  selector: 'app-comment-item',
  standalone: true,
  imports: [RouterLink, UserAvatar, VoteButtons, CommentForm],
  templateUrl: './comment-item.html',
  styleUrls: ['./comment-item.css'],
  changeDetection: ChangeDetectionStrategy.OnPush,
})
export class CommentItem {
  comment = input.required<Comment>();
  depth = input<number>(0);
  readonly reply = output<{ commentId: number; content: string }>();
  readonly vote = output<{ commentId: number; voteType: 'up' | 'down' }>();
  readonly delete = output<number>();
  readonly showReplyForm = signal(false);
  toggleReply() {
    this.showReplyForm.update((value) => !value);
  }
  submitReply(content: string) {
    this.reply.emit({ commentId: this.comment().id, content });
    this.showReplyForm.set(false);
  }
  onVoteClick(voteType: 'up' | 'down') {
    this.vote.emit({ commentId: this.comment().id, voteType });
  }
  onNestedReply(event: { commentId: number; content: string }) {
    this.reply.emit(event);
  }
  onNestedVote(event: { commentId: number; voteType: 'up' | 'down' }) {
    this.vote.emit(event);
  }
  onNestedDelete(commentId: number) {
    this.delete.emit(commentId);
  }
  deleteComment() {
    this.delete.emit(this.comment().id);
  }
  canModerate(): boolean {
    return false;
  }
  reportComment() {
    console.log('Report comment', this.comment().id);
  }
  formatTime(isoDate: string): string {
    const date = new Date(isoDate);
    const diffSeconds = (Date.now() - date.getTime()) / 1000;
    if (diffSeconds < 60) return 'Just now';
    if (diffSeconds < 3600) return `${Math.floor(diffSeconds / 60)}m ago`;
    if (diffSeconds < 86400) return `${Math.floor(diffSeconds / 3600)}h ago`;
    return `${Math.floor(diffSeconds / 86400)}d ago`;
  }
}
FILE: frontend/src/app/features/comments/comment-thread/comment-thread.css
.comment-thread {
  display: flex;
  flex-direction: column;
  gap: 16px;
}
.no-comments {
  text-align: center;
  padding: 40px 20px;
  color: var(--text-secondary);
}
.no-comments .material-icons {
  font-size: 48px;
  color: var(--text-muted);
  margin-bottom: 12px;
}
.no-comments p {
  font-size: 14px;
}
FILE: frontend/src/app/features/comments/comment-thread/comment-thread.html
<div class="comment-thread">
  @for (comment of comments(); track comment.id) {
    <app-comment-item
      [comment]="comment"
      [depth]="0"
      (reply)="handleReply($event)"
      (vote)="handleVote($event)"
      (delete)="handleDelete($event)"
    ></app-comment-item>
  } @empty {
    <div class="no-comments">
      <span class="material-icons">chat_bubble_outline</span>
      <p>No comments yet. Be the first to share your thoughts!</p>
    </div>
  }
</div>
FILE: frontend/src/app/features/comments/comment-thread/comment-thread.ts
import { ChangeDetectionStrategy, Component, input, output } from '@angular/core';
import { CommentItem } from '../comment-item/comment-item';
import { Comment } from '../../../core/models/comment.model';
@Component({
  selector: 'app-comment-thread',
  standalone: true,
  imports: [CommentItem],
  templateUrl: './comment-thread.html',
  styleUrl: './comment-thread.css',
  changeDetection: ChangeDetectionStrategy.OnPush,
})
export class CommentThread {
  comments = input.required<Comment[]>();
  readonly reply = output<{ commentId: number; content: string }>();
  readonly vote = output<{ commentId: number; voteType: 'up' | 'down' }>();
  readonly delete = output<number>();
  handleReply(event: { commentId: number; content: string }) {
    this.reply.emit(event);
  }
  handleVote(event: { commentId: number; voteType: 'up' | 'down' }) {
    this.vote.emit(event);
  }
  handleDelete(commentId: number) {
    this.delete.emit(commentId);
  }
}
FILE: frontend/src/app/features/comments/services/comment.ts
import { inject, Injectable } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { environment } from '../../../core/config/environment';
import { map } from 'rxjs';
import { Comment } from '../../../core/models/comment.model';
import { Observable } from 'rxjs';
interface CommentDto {
  id: number;
  post_id: number;
  user_id: number;
  parent_id: number | null;
  content: string;
  upvotes: number;
  downvotes: number;
  is_deleted: boolean;
  created_at: string;
  updated_at: string | null;
  author_username: string;
  author_avatar: string | null;
  user_vote: 'up' | 'down' | null;
  replies: CommentDto[];
}
interface CommentTreeDto {
  comments: CommentDto[];
  total: number;
}
@Injectable({ providedIn: 'root' })
export class CommentService {
  private readonly http = inject(HttpClient);
  vote(commentId: number, voteType: 'up' | 'down'): Observable<any> {
    return this.http.post(`${environment.apiUrl}/comments/${commentId}/vote`, {
      vote_type: voteType,
    });
  }
  removeVote(commentId: number): Observable<any> {
    return this.http.delete(`${environment.apiUrl}/comments/${commentId}/vote`);
  }
  delete(commentId: number): Observable<any> {
    return this.http.delete(`${environment.apiUrl}/comments/${commentId}`);
  }
  getTree(postId: number | string) {
    return this.http
      .get<CommentTreeDto>(`${environment.apiUrl}/comments/post/${postId}`)
      .pipe(map((dto) => dto.comments.map((comment) => this.mapComment(comment))));
  }
  create(postId: number | string, content: string, parentId?: number) {
    return this.http
      .post<CommentDto>(`${environment.apiUrl}/comments`, {
        post_id: Number(postId),
        content,
        parent_id: parentId ?? null,
      })
      .pipe(map((dto) => this.mapComment(dto)));
  }
  private mapComment(dto: CommentDto): Comment {
    return {
      id: dto.id,
      postId: dto.post_id,
      userId: dto.user_id,
      parentId: dto.parent_id,
      content: dto.content,
      upvotes: dto.upvotes,
      downvotes: dto.downvotes,
      isDeleted: dto.is_deleted,
      createdAt: dto.created_at,
      updatedAt: dto.updated_at,
      authorUsername: dto.author_username,
      authorAvatar: dto.author_avatar,
      userVote: dto.user_vote,
      replies: dto.replies?.map((reply) => this.mapComment(reply)) ?? [],
    };
  }
}
FILE: frontend/src/app/features/notifications/notification-bell/notification-bell.css
.notification-bell-container {
  position: relative;
}
.notification-bell {
  position: relative;
  background: none;
  border: none;
  color: var(--text-primary);
  cursor: pointer;
  padding: 8px;
  border-radius: 4px;
  transition: background-color 0.2s;
}
.notification-bell:hover {
  background-color: var(--bg-hover);
}
.notification-badge {
  position: absolute;
  top: 4px;
  right: 4px;
  background-color: var(--error);
  color: white;
  font-size: 10px;
  font-weight: 700;
  padding: 2px 4px;
  border-radius: 10px;
  min-width: 16px;
  text-align: center;
}
.notification-dropdown {
  position: absolute;
  top: calc(100% + 8px);
  right: 0;
  width: 380px;
  max-height: 480px;
  background-color: var(--bg-secondary);
  border: 1px solid var(--border-primary);
  border-radius: 4px;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
  display: flex;
  flex-direction: column;
  z-index: 1001;
}
.notification-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 16px;
  border-bottom: 1px solid var(--border-primary);
}
.notification-header h3 {
  font-size: 16px;
  font-weight: 600;
  color: var(--text-primary);
  margin: 0;
}
.mark-all-read {
  background: none;
  border: none;
  color: var(--primary-orange);
  font-family: 'JetBrains Mono', monospace;
  font-size: 12px;
  font-weight: 500;
  cursor: pointer;
  padding: 4px 8px;
  border-radius: 4px;
  transition: background-color 0.2s;
}
.mark-all-read:hover {
  background-color: var(--bg-hover);
}
.notification-list {
  flex: 1;
  overflow-y: auto;
  max-height: 360px;
}
.empty-notifications {
  padding: 40px;
  text-align: center;
  color: var(--text-secondary);
}
.empty-notifications .material-icons {
  font-size: 48px;
  color: var(--text-muted);
  margin-bottom: 8px;
}
.notification-footer {
  padding: 12px;
  border-top: 1px solid var(--border-primary);
  text-align: center;
}
.view-all {
  color: var(--primary-orange);
  text-decoration: none;
  font-size: 14px;
  font-weight: 500;
}
.view-all:hover {
  text-decoration: underline;
}
FILE: frontend/src/app/features/notifications/notification-bell/notification-bell.html
<div class="notification-bell-container">
  <button
    class="notification-bell"
    (click)="toggleNotifications()"
    [attr.aria-label]="'Notifications'"
  >
    <span class="material-icons">{{ unreadCount() > 0 ? 'notifications_active' : 'notifications' }}</span>
    @if (unreadCount() > 0) {
      <span class="notification-badge">{{ formatCount(unreadCount()) }}</span>
    }
  </button>

  @if (isOpen()) {
    <div class="notification-dropdown">
      <div class="notification-header">
        <h3>Notifications</h3>
        @if (unreadCount() > 0) {
          <button class="mark-all-read" (click)="markAllAsRead()">
            Mark all as read
          </button>
        }
      </div>

      <div class="notification-list">
        @if (notifications().length > 0) {
          @for (notification of notifications(); track notification.id) {
            <app-notification-item
              [notification]="notification"
              (click)="handleNotificationClick(notification)"
            ></app-notification-item>
          }
        } @else {
          <div class="empty-notifications">
            <span class="material-icons">notifications_none</span>
            <p>No notifications yet</p>
          </div>
        }
      </div>

      <div class="notification-footer">
        <a routerLink="/notifications" class="view-all" (click)="close()">View all notifications</a>
      </div>
    </div>
  }
</div>
FILE: frontend/src/app/features/notifications/notification-bell/notification-bell.ts
import { ChangeDetectionStrategy, Component, computed, inject, signal } from '@angular/core';
import { CommonModule } from '@angular/common';
import { RouterLink } from '@angular/router';
import { NotificationItem } from '../notification-item/notification-item';
import { NotificationService } from '../../../core/services/notification';
@Component({
  selector: 'app-notification-bell',
  standalone: true,
  imports: [CommonModule, RouterLink, NotificationItem],
  templateUrl: './notification-bell.html',
  styleUrl: './notification-bell.css',
  changeDetection: ChangeDetectionStrategy.OnPush,
})
export class NotificationBell {
  private readonly notificationService = inject(NotificationService);
  readonly isOpen = signal(false);
  readonly notifications = computed(() => this.notificationService.notifications());
  readonly unreadCount = computed(() => this.notificationService.unreadCount());
  toggleNotifications() {
    this.isOpen.update((open) => !open);
  }
  close() {
    this.isOpen.set(false);
  }
  async markAllAsRead() {
    await this.notificationService.markAllAsRead();
  }
  async handleNotificationClick(notification: { id: number; isRead: boolean; link?: string | null }) {
    if (!notification.isRead) {
      await this.notificationService.markAsRead(notification.id);
    }
    if (notification.link) {
      this.close();
    }
  }
  formatCount(count: number): string {
    return count > 99 ? '99+' : count.toString();
  }
}
FILE: frontend/src/app/features/notifications/notification-item/notification-item.css
.notification-item {
  display: flex;
  align-items: flex-start;
  gap: 12px;
  padding: 12px 16px;
  cursor: pointer;
  transition: background-color 0.2s;
  position: relative;
}
.notification-item:hover {
  background-color: var(--bg-hover);
}
.notification-item.unread {
  background-color: rgba(255, 69, 0, 0.05);
}
.notification-icon {
  width: 36px;
  height: 36px;
  background-color: var(--bg-tertiary);
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  flex-shrink: 0;
}
.notification-icon .material-icons {
  font-size: 18px;
  color: var(--text-secondary);
}
.notification-content {
  flex: 1;
  min-width: 0;
}
.notification-message {
  color: var(--text-primary);
  font-size: 14px;
  line-height: 1.4;
  margin: 0 0 4px 0;
  word-break: break-word;
}
.notification-time {
  color: var(--text-muted);
  font-size: 12px;
}
.unread-indicator {
  position: absolute;
  right: 16px;
  top: 50%;
  transform: translateY(-50%);
  width: 8px;
  height: 8px;
  background-color: var(--primary-orange);
  border-radius: 50%;
}
FILE: frontend/src/app/features/notifications/notification-item/notification-item.html
<div class="notification-item" [class.unread]="!notification().read" (click)="handleClick()">
  <div class="notification-icon">
    @switch (notification().type) {
      @case ('comment') {
        <span class="material-icons">comment</span>
      }
      @case ('upvote') {
        <span class="material-icons">thumb_up</span>
      }
      @case ('mention') {
        <span class="material-icons">alternate_email</span>
      }
      @case ('post') {
        <span class="material-icons">article</span>
      }
      @default {
        <span class="material-icons">notifications</span>
      }
    }
  </div>

  <div class="notification-content">
    <p class="notification-message">{{ notification().message }}</p>
    <span class="notification-time">{{ formatTime(notification().createdAt) }}</span>
  </div>

  @if (!notification().read) {
    <span class="unread-indicator"></span>
  }
</div>
FILE: frontend/src/app/features/notifications/notification-item/notification-item.ts
import { Component, input, output } from '@angular/core';
import { CommonModule } from '@angular/common';
@Component({
  selector: 'app-notification-item',
  standalone: true,
  imports: [CommonModule],
  templateUrl: './notification-item.html',
  styleUrl: './notification-item.css'
})
export class NotificationItem {
  notification = input.required<any>();
  click = output<any>();
  handleClick() {
    this.click.emit(this.notification());
  }
  formatTime(date: Date): string {
    const now = new Date();
    const diff = now.getTime() - new Date(date).getTime();
    const seconds = Math.floor(diff / 1000);
    const minutes = Math.floor(seconds / 60);
    const hours = Math.floor(minutes / 60);
    const days = Math.floor(hours / 24);
    if (days > 0) return `${days}d ago`;
    if (hours > 0) return `${hours}h ago`;
    if (minutes > 0) return `${minutes}m ago`;
    return 'Just now';
  }
}
FILE: frontend/src/app/features/notifications/notification-list/notification-list.css
[EMPTY FILE]
FILE: frontend/src/app/features/notifications/notification-list/notification-list.html
<section>
  <header>
    <h2>Notifications</h2>
    <p>{{ unreadCount() }} unread</p>
  </header>

  <div>
    @if (notifications().length === 0) {
      <p>No notifications yet.</p>
    } @else {
      @for (notification of notifications(); track notification.id) {
        <app-notification-item
          [notification]="notification"
        ></app-notification-item>
      }
    }
  </div>
</section>
FILE: frontend/src/app/features/notifications/notification-list/notification-list.ts
import { ChangeDetectionStrategy, Component, computed, inject } from '@angular/core';
import { CommonModule } from '@angular/common';
import { NotificationService } from '../../../core/services/notification';
import { NotificationItem } from '../notification-item/notification-item';
@Component({
  selector: 'app-notification-list',
  standalone: true,
  imports: [CommonModule, NotificationItem],
  templateUrl: './notification-list.html',
  styleUrl: './notification-list.css',
  changeDetection: ChangeDetectionStrategy.OnPush,
})
export class NotificationList {
  private readonly notificationService = inject(NotificationService);
  readonly notifications = computed(() => this.notificationService.notifications());
  readonly unreadCount = computed(() => this.notificationService.unreadCount());
}
FILE: frontend/src/app/features/posts/post-card/post-card.css
.post-card {
  background-color: var(--bg-secondary);
  border: 1px solid var(--border-primary);
  border-radius: 4px;
  margin-bottom: 16px;
  display: flex;
  cursor: pointer;
  transition: border-color 0.2s;
}
.post-card:hover {
  border-color: var(--border-secondary);
}
.post-votes {
  padding: 8px;
  background-color: var(--bg-tertiary);
  border-radius: 4px 0 0 4px;
}
.post-content {
  flex: 1;
  padding: 12px;
}
.post-header {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 8px;
  font-size: 12px;
  color: var(--text-secondary);
}
.post-author {
  font-weight: 600;
  color: var(--text-primary);
}
.post-separator {
  color: var(--text-muted);
}
.post-tag {
  padding: 2px 8px;
  background-color: var(--primary-orange);
  color: white;
  border-radius: 12px;
  font-size: 10px;
  font-weight: 600;
  margin-left: auto;
}
.post-title {
  font-size: 18px;
  font-weight: 600;
  color: var(--text-primary);
  margin-bottom: 8px;
  line-height: 1.4;
}
.post-image-container {
  margin: 12px 0;
  border-radius: 4px;
  overflow: hidden;
  max-height: 512px;
}
.post-image {
  width: 100%;
  height: auto;
  display: block;
}
.post-description {
  color: var(--text-secondary);
  line-height: 1.5;
  margin-bottom: 12px;
}
.post-footer {
  display: flex;
  gap: 12px;
  margin-top: 12px;
}
.post-action {
  display: flex;
  align-items: center;
  gap: 6px;
  padding: 8px 12px;
  background: none;
  border: none;
  color: var(--text-secondary);
  font-family: 'JetBrains Mono', monospace;
  font-size: 12px;
  font-weight: 600;
  cursor: pointer;
  border-radius: 4px;
  transition: all 0.2s;
}
.post-action:hover {
  background-color: var(--bg-hover);
  color: var(--text-primary);
}
.post-action .material-icons {
  font-size: 18px;
}
FILE: frontend/src/app/features/posts/post-card/post-card.html
<article class="post-card" (click)="navigateToPost()">
  <div class="post-votes">
    <app-vote-buttons
      [upvotes]="currentUpvotes()"
      [downvotes]="currentDownvotes()"
      [userVote]="currentUserVote()"
      [disabled]="isVotePending()"
      (vote)="handleVote($event)"
    ></app-vote-buttons>
  </div>

  <div class="post-content">
    <div class="post-header">
      <app-user-avatar
        [size]="20"
        [username]="post().authorUsername"
        [imageUrl]="post().authorAvatar ?? ''"
      ></app-user-avatar>
      <span class="post-author">{{ post().authorUsername }}</span>
      <span class="post-separator">â€¢</span>
      <span class="post-time">{{ formatTime(post().createdAt) }}</span>
      @if (post().tag) {
        <span class="post-tag">#{{ post().tag }}</span>
      }
    </div>

    <h2 class="post-title">{{ post().title }}</h2>

    @if (post().imageUrl) {
      <div class="post-image-container">
        <img [src]="post().imageUrl" [alt]="post().title" class="post-image" />
      </div>
    }

    @if (post().description) {
      <p class="post-description">{{ post().description }}</p>
    }

    <div class="post-footer">
      <button class="post-action" (click)="openComments($event)">
        <span class="material-icons">comment</span>
        <span>{{ post().commentCount }} Comments</span>
      </button>

      <button class="post-action" (click)="share($event)">
        <span class="material-icons">share</span>
        <span>Share</span>
      </button>

      <button class="post-action" (click)="toggleFavorite($event)">
        <span class="material-icons">{{ isFavorite() ? 'bookmark' : 'bookmark_border' }}</span>
        <span>Save</span>
      </button>


    </div>
  </div>
</article>
FILE: frontend/src/app/features/posts/post-card/post-card.ts
import { ChangeDetectionStrategy, Component, inject, input, signal, effect, computed } from '@angular/core';
import { CommonModule } from '@angular/common';
import { Router } from '@angular/router';
import { VoteButtons } from '../../../shared/components/vote-buttons/vote-buttons';
import { UserAvatar } from '../../../shared/components/user-avatar/user-avatar';
import { Post } from '../../../core/models/post.model';
import { PostService } from '../services/post';
import { FavoriteState } from '../../../core/services/favorite';
import { VoteState } from '../../../core/services/vote-state';
@Component({
  selector: 'app-post-card',
  standalone: true,
  imports: [CommonModule, VoteButtons, UserAvatar],
  templateUrl: './post-card.html',
  styleUrls: ['./post-card.css'],
  changeDetection: ChangeDetectionStrategy.OnPush,
})
export class PostCard {
  private readonly router = inject(Router);
  private readonly postService = inject(PostService);
  private readonly favoriteState = inject(FavoriteState);
  private readonly voteState = inject(VoteState);
  post = input.required<Post>();
  isFavorite = signal(false);
  readonly currentUpvotes = computed(() => {
    const voteCache = this.voteState.getPostVote(this.post().id);
    return voteCache?.upvotes ?? this.post().upvotes;
  });
  readonly currentDownvotes = computed(() => {
    const voteCache = this.voteState.getPostVote(this.post().id);
    return voteCache?.downvotes ?? this.post().downvotes;
  });
  readonly currentUserVote = computed(() => {
    const voteCache = this.voteState.getPostVote(this.post().id);
    return voteCache?.userVote ?? this.post().userVote;
  });
  readonly isVotePending = computed(() => {
    return this.voteState.isPending('post', this.post().id);
  });
  constructor() {
    effect(() => {
      this.isFavorite.set(this.post().isFavorited);
    }, { allowSignalWrites: true });
  }
  navigateToPost() {
    this.router.navigate(['/post', this.post().id]);
  }
  handleVote(vote: 'up' | 'down') {
    if (this.isVotePending()) return;
    const currentVote = this.currentUserVote();
    if (currentVote === vote) {
      this.postService.removeVote(this.post().id, currentVote).subscribe({
        error: (err) => {
          console.error('Failed to remove vote', err);
          this.voteState.optimisticVote('post', this.post().id, currentVote, null);
        },
      });
    } else {
      this.postService.vote(this.post().id, vote, currentVote).subscribe({
        error: (err) => {
          console.error('Failed to vote', err);
          this.voteState.optimisticVote('post', this.post().id, currentVote, vote);
        },
      });
    }
  }
  openComments(event: Event) {
    event.stopPropagation();
    this.navigateToPost();
  }
  share(event: Event) {
    event.stopPropagation();
    if (navigator.share) {
      navigator.share({
        title: this.post().title,
        text: this.post().description ?? '',
        url: `${window.location.origin}/post/${this.post().id}`,
      }).catch(() => {});
    } else {
      navigator.clipboard.writeText(`${window.location.origin}/post/${this.post().id}`);
      alert('Link copied to clipboard!');
    }
  }
  toggleFavorite(event: Event) {
    event.stopPropagation();
    const currentPost = this.post();
    const currentFavoriteState = this.isFavorite();
    if (currentFavoriteState) {
      this.postService.unfavorite(currentPost.id).subscribe({
        next: () => {
          this.isFavorite.set(false);
          currentPost.isFavorited = false;
          this.favoriteState.notifyChange();
          console.log('Post unfavorited successfully');
        },
        error: (err) => {
          console.error('Failed to unfavorite', err);
          alert('Failed to remove bookmark. Please try again.');
        },
      });
    } else {
      this.postService.favorite(currentPost.id).subscribe({
        next: () => {
          this.isFavorite.set(true);
          currentPost.isFavorited = true;
          this.favoriteState.notifyChange();
          console.log('Post favorited successfully');
        },
        error: (err) => {
          console.error('Failed to favorite', err);
          alert('Failed to bookmark. Please try again.');
        },
      });
    }
  }
  formatTime(isoDate: string) {
    const date = new Date(isoDate);
    const diff = (Date.now() - date.getTime()) / 1000;
    if (diff < 60) return 'Just now';
    if (diff < 3600) return `${Math.floor(diff / 60)}m ago`;
    if (diff < 86400) return `${Math.floor(diff / 3600)}h ago`;
    return `${Math.floor(diff / 86400)}d ago`;
  }
}
FILE: frontend/src/app/features/posts/post-create/post-create.css
.create-post-container {
  max-width: 700px;
  margin: 0 auto;
  background-color: var(--bg-secondary);
  border: 1px solid var(--border-primary);
  border-radius: 4px;
  padding: 24px;
}
.create-post-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 24px;
  padding-bottom: 16px;
  border-bottom: 1px solid var(--border-primary);
}
.create-post-header h1 {
  font-size: 20px;
  font-weight: 600;
  color: var(--text-primary);
  margin: 0;
}
.close-btn {
  background: none;
  border: none;
  color: var(--text-secondary);
  cursor: pointer;
  padding: 4px;
  border-radius: 4px;
  transition: all 0.2s;
}
.close-btn:hover {
  background-color: var(--bg-hover);
  color: var(--text-primary);
}
.post-form {
  display: flex;
  flex-direction: column;
  gap: 20px;
}
.form-group {
  position: relative;
  display: flex;
  flex-direction: column;
  gap: 8px;
}
.form-group label {
  font-size: 14px;
  font-weight: 600;
  color: var(--text-primary);
}
.form-input,
.form-select,
.form-textarea {
  padding: 12px;
  background-color: var(--bg-tertiary);
  border: 1px solid var(--border-primary);
  border-radius: 4px;
  color: var(--text-primary);
  font-family: 'JetBrains Mono', monospace;
  font-size: 14px;
  outline: none;
  transition: all 0.2s;
}
.form-input:focus,
.form-select:focus,
.form-textarea:focus {
  border-color: var(--primary-orange);
  background-color: var(--bg-primary);
}
.form-input.error,
.form-textarea.error {
  border-color: var(--error);
}
.form-textarea {
  resize: vertical;
  min-height: 100px;
}
.char-count {
  position: absolute;
  right: 12px;
  bottom: -20px;
  font-size: 12px;
  color: var(--text-muted);
}
.error-message {
  font-size: 12px;
  color: var(--error);
}
.image-upload-area {
  position: relative;
  min-height: 200px;
  background-color: var(--bg-tertiary);
  border: 2px dashed var(--border-primary);
  border-radius: 8px;
  cursor: pointer;
  transition: all 0.2s;
  display: flex;
  align-items: center;
  justify-content: center;
}
.image-upload-area:hover,
.image-upload-area.drag-over {
  border-color: var(--primary-orange);
  background-color: rgba(255, 69, 0, 0.05);
}
.image-upload-area.has-image {
  border-style: solid;
}
.upload-placeholder {
  text-align: center;
  color: var(--text-secondary);
}
.upload-placeholder .material-icons {
  font-size: 48px;
  color: var(--text-muted);
  margin-bottom: 8px;
}
.upload-placeholder p {
  margin: 8px 0 4px;
  font-size: 14px;
}
.upload-hint {
  font-size: 12px;
  color: var(--text-muted);
}
.image-preview {
  max-width: 100%;
  max-height: 400px;
  border-radius: 4px;
}
.remove-image {
  position: absolute;
  top: 8px;
  right: 8px;
  background-color: rgba(0, 0, 0, 0.7);
  border: none;
  color: white;
  cursor: pointer;
  padding: 4px;
  border-radius: 4px;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: background-color 0.2s;
}
.remove-image:hover {
  background-color: rgba(0, 0, 0, 0.9);
}
.form-actions {
  display: flex;
  justify-content: flex-end;
  gap: 12px;
  margin-top: 24px;
  padding-top: 24px;
  border-top: 1px solid var(--border-primary);
}
.cancel-btn {
  padding: 10px 24px;
  background: none;
  border: 1px solid var(--border-primary);
  border-radius: 20px;
  color: var(--text-primary);
  font-family: 'JetBrains Mono', monospace;
  font-size: 14px;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.2s;
}
.cancel-btn:hover {
  background-color: var(--bg-hover);
}
.submit-btn {
  padding: 10px 24px;
  background-color: var(--primary-orange);
  border: none;
  border-radius: 20px;
  color: white;
  font-family: 'JetBrains Mono', monospace;
  font-size: 14px;
  font-weight: 600;
  cursor: pointer;
  transition: background-color 0.2s;
  display: flex;
  align-items: center;
  gap: 8px;
}
.submit-btn:hover:not(:disabled) {
  background-color: var(--primary-orange-light);
}
.submit-btn:disabled {
  opacity: 0.6;
  cursor: not-allowed;
}
.spinner-small {
  width: 14px;
  height: 14px;
  border: 2px solid rgba(255, 255, 255, 0.3);
  border-top-color: white;
  border-radius: 50%;
  animation: spin 0.6s linear infinite;
}
@keyframes spin {
  to { transform: rotate(360deg); }
}
FILE: frontend/src/app/features/posts/post-create/post-create.html
<div class="create-post-container">
  <div class="create-post-header">
    <h1>Create a Post</h1>
    <button class="close-btn" routerLink="/feed">
      <span class="material-icons">close</span>
    </button>
  </div>

  <form [formGroup]="postForm" (ngSubmit)="onSubmit()" class="post-form">
    <div class="form-group">
      <label for="title">Title *</label>
      <input
        id="title"
        type="text"
        formControlName="title"
        class="form-input"
        placeholder="An interesting title..."
        [class.error]="isFieldInvalid('title')"
      >
      <span class="char-count">{{ titleLength() }}/300</span>
      @if (isFieldInvalid('title')) {
        <span class="error-message">Title is required (min 3 characters)</span>
      }
    </div>

    <div class="form-group">
      <label for="tag">Tag</label>
      <select id="tag" formControlName="tag" class="form-select">
        <option value="">Select a tag (optional)</option>
        @for (category of tags(); track category.id) {
          <option [value]="category.slug">
            {{ category.emoji }} {{ category.name }}
          </option>
        }
      </select>
    </div>

    <div class="form-group">
      <label for="image">Image</label>
      <div class="image-upload-area"
           [class.has-image]="imagePreview()"
           (click)="fileInput.click()"
           (drop)="onDrop($event)"
           (dragover)="onDragOver($event)"
           (dragleave)="onDragLeave($event)"
           [class.drag-over]="isDragging()">

        @if (imagePreview()) {
          <img [src]="imagePreview()" alt="Preview" class="image-preview">
          <button type="button" class="remove-image" (click)="removeImage($event)">
            <span class="material-icons">close</span>
          </button>
        } @else {
          <div class="upload-placeholder">
            <span class="material-icons">image</span>
            <p>Click or drag image here</p>
            <span class="upload-hint">PNG, JPG, GIF up to 10MB</span>
          </div>
        }

        <input
          #fileInput
          type="file"
          accept="image/*"
          (change)="onFileSelected($event)"
          style="display: none"
        >
      </div>
    </div>

    <div class="form-group">
      <label for="description">Description</label>
      <textarea
        id="description"
        formControlName="description"
        class="form-textarea"
        placeholder="Add some context... (optional)"
        rows="4"
      ></textarea>
      <span class="char-count">{{ descriptionLength() }}/1000</span>
    </div>

    <div class="form-actions">
      <button type="button" class="cancel-btn" routerLink="/feed">
        Cancel
      </button>
      <button
        type="submit"
        class="submit-btn"
        [disabled]="postForm.invalid || isSubmitting()"
      >
        @if (isSubmitting()) {
          <span class="spinner-small"></span>
          <span>Posting...</span>
        } @else {
          <span>Post</span>
        }
      </button>
    </div>
  </form>
</div>
FILE: frontend/src/app/features/posts/post-create/post-create.ts
import { ChangeDetectionStrategy, Component, computed, inject, signal } from '@angular/core';
import { FormBuilder, FormGroup, ReactiveFormsModule, Validators } from '@angular/forms';
import { Router, RouterLink } from '@angular/router';
import { PostService } from '../services/post';
import { CATEGORIES } from '../../../core/constants/categories';
@Component({
  selector: 'app-post-create',
  standalone: true,
  imports: [ReactiveFormsModule, RouterLink],
  templateUrl: './post-create.html',
  styleUrls: ['./post-create.css'],
  changeDetection: ChangeDetectionStrategy.OnPush,
})
export class PostCreate {
  private readonly fb = inject(FormBuilder);
  private readonly router = inject(Router);
  private readonly postService = inject(PostService);
  readonly tags = signal(CATEGORIES);
  readonly imagePreview = signal<string | null>(null);
  readonly isDragging = signal(false);
  readonly isSubmitting = signal(false);
  readonly postForm: FormGroup = this.fb.group({
    title: ['', [Validators.required, Validators.minLength(3), Validators.maxLength(300)]],
    tag: [''],
    description: ['', [Validators.maxLength(1000)]],
  });
  readonly titleLength = computed(() => this.postForm.get('title')?.value?.length ?? 0);
  readonly descriptionLength = computed(() => this.postForm.get('description')?.value?.length ?? 0);
  isFieldInvalid(field: string) {
    const control = this.postForm.get(field);
    return !!(control && control.invalid && (control.dirty || control.touched));
  }
  onFileSelected(event: Event) {
    const input = event.target as HTMLInputElement;
    if (!input.files?.length) return;
    this.readFile(input.files[0]);
  }
  onDrop(event: DragEvent) {
    event.preventDefault();
    this.isDragging.set(false);
    if (!event.dataTransfer?.files?.length) return;
    this.readFile(event.dataTransfer.files[0]);
  }
  onDragOver(event: DragEvent) {
    event.preventDefault();
    this.isDragging.set(true);
  }
  onDragLeave(event: DragEvent) {
    event.preventDefault();
    this.isDragging.set(false);
  }
  removeImage(event: Event) {
    event.stopPropagation();
    this.imagePreview.set(null);
  }
  private readFile(file: File) {
    if (!file.type.startsWith('image/')) {
      alert('Please select an image file');
      return;
    }
    if (file.size > 10 * 1024 * 1024) {
      alert('Images must be â‰¤10MB');
      return;
    }
    const reader = new FileReader();
    reader.onload = (e) => this.imagePreview.set(e.target?.result as string);
    reader.readAsDataURL(file);
  }
  async onSubmit() {
    if (this.postForm.invalid) {
      Object.keys(this.postForm.controls).forEach((key) => this.postForm.get(key)?.markAsTouched());
      return;
    }
    this.isSubmitting.set(true);
    try {
      const post = await this.postService
        .create({
          title: this.postForm.get('title')?.value,
          description: this.postForm.get('description')?.value || null,
          tag: this.postForm.get('tag')?.value || null,
          imageUrl: this.imagePreview(),
        })
        .toPromise();
      await this.router.navigate(['/post', post?.id ?? '']);
    } catch (error) {
      console.error('Failed to create post', error);
      alert('Failed to create post. Try again.');
    } finally {
      this.isSubmitting.set(false);
    }
  }
}
FILE: frontend/src/app/features/posts/post-detail/post-detail.css
.post-detail-container {
  max-width: 800px;
  margin: 0 auto;
}
.post-detail {
  background-color: var(--bg-secondary);
  border: 1px solid var(--border-primary);
  border-radius: 4px;
  padding: 24px;
  margin-bottom: 24px;
}
.post-detail-header {
  display: flex;
  justify-content: space-between;
  align-items: flex-start;
  margin-bottom: 16px;
}
.post-meta {
  display: flex;
  gap: 12px;
}
.post-meta-info {
  display: flex;
  flex-direction: column;
  gap: 4px;
}
.post-author {
  color: var(--text-primary);
  font-weight: 600;
  text-decoration: none;
}
.post-author:hover {
  color: var(--primary-orange);
  text-decoration: underline;
}
.post-time {
  font-size: 12px;
  color: var(--text-secondary);
}
.post-actions {
  display: flex;
  gap: 8px;
}
.action-btn {
  background: none;
  border: none;
  color: var(--text-secondary);
  cursor: pointer;
  padding: 8px;
  border-radius: 4px;
  transition: all 0.2s;
}
.action-btn:hover {
  background-color: var(--bg-hover);
  color: var(--text-primary);
}
.action-btn.danger:hover {
  background-color: rgba(234, 0, 39, 0.1);
  color: var(--error);
}
.post-detail-title {
  font-size: 24px;
  font-weight: 700;
  color: var(--text-primary);
  margin-bottom: 16px;
  line-height: 1.3;
}
.post-detail-tag {
  display: inline-block;
  padding: 4px 12px;
  background-color: var(--primary-orange);
  color: white;
  border-radius: 16px;
  font-size: 12px;
  font-weight: 600;
  margin-bottom: 16px;
}
.post-detail-image {
  margin: 24px 0;
  border-radius: 8px;
  overflow: hidden;
}
.post-detail-image img {
  width: 100%;
  height: auto;
  display: block;
}
.post-detail-description {
  color: var(--text-primary);
  line-height: 1.6;
  margin-bottom: 24px;
  white-space: pre-wrap;
}
.post-detail-footer {
  display: flex;
  align-items: center;
  gap: 16px;
  padding-top: 16px;
  border-top: 1px solid var(--border-primary);
}
.post-detail-action {
  display: flex;
  align-items: center;
  gap: 6px;
  padding: 8px 12px;
  background: none;
  border: none;
  color: var(--text-secondary);
  font-family: 'JetBrains Mono', monospace;
  font-size: 14px;
  font-weight: 500;
  cursor: pointer;
  border-radius: 4px;
  transition: all 0.2s;
}
.post-detail-action:hover {
  background-color: var(--bg-hover);
  color: var(--text-primary);
}
.comments-section {
  background-color: var(--bg-secondary);
  border: 1px solid var(--border-primary);
  border-radius: 4px;
  padding: 24px;
}
.comments-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 24px;
}
.comments-header h2 {
  font-size: 18px;
  font-weight: 600;
  color: var(--text-primary);
  margin: 0;
}
.comment-sort {
  padding: 8px 12px;
  background-color: var(--bg-tertiary);
  border: 1px solid var(--border-primary);
  border-radius: 4px;
  color: var(--text-primary);
  font-family: 'JetBrains Mono', monospace;
  font-size: 14px;
  cursor: pointer;
  outline: none;
}
.login-prompt {
  padding: 24px;
  background-color: var(--bg-tertiary);
  border-radius: 4px;
  text-align: center;
  margin-bottom: 24px;
}
.login-prompt p {
  color: var(--text-secondary);
}
.login-prompt a {
  color: var(--primary-orange);
  text-decoration: none;
  font-weight: 500;
}
.login-prompt a:hover {
  text-decoration: underline;
}
.error-state {
  text-align: center;
  padding: 60px 20px;
  background-color: var(--bg-secondary);
  border: 1px solid var(--border-primary);
  border-radius: 4px;
}
.error-state .material-icons {
  font-size: 64px;
  color: var(--text-muted);
  margin-bottom: 16px;
}
.error-state h2 {
  color: var(--text-primary);
  margin-bottom: 8px;
}
.error-state p {
  color: var(--text-secondary);
  margin-bottom: 24px;
}
.back-btn {
  padding: 10px 20px;
  background-color: var(--primary-orange);
  color: white;
  border: none;
  border-radius: 4px;
  font-family: 'JetBrains Mono', monospace;
  font-weight: 500;
  cursor: pointer;
  text-decoration: none;
  display: inline-block;
}
.back-btn:hover {
  background-color: var(--primary-orange-light);
}
FILE: frontend/src/app/features/posts/post-detail/post-detail.html
<div class="post-detail-container">
  @if (isLoading()) {
    <app-loading-spinner></app-loading-spinner>
  } @else if (post(); as post) {
    <article class="post-detail">
      <div class="post-detail-header">
        <div class="post-meta">
          <app-user-avatar
            [username]="post.authorUsername"
            [imageUrl]="post.authorAvatar ?? ''"
            [size]="40"
          ></app-user-avatar>

          <div class="post-meta-info">
            <a
              [routerLink]="['/profile', post.authorUsername]"
              class="post-author"
            >
              {{ post.authorUsername }}
            </a>
            <span class="post-time">{{ formatTime(post.createdAt) }}</span>
          </div>
        </div>


        @if (canModerate()) {
          <div class="post-actions">
            <button class="action-btn danger" (click)="deletePost()">
              <span class="material-icons">delete</span>
            </button>
          </div>
        }
      </div>

      <h1 class="post-detail-title">{{ post.title }}</h1>

      @if (post.tag) {
        <span class="post-detail-tag">{{ post.tag }}</span>
      }

      @if (post.imageUrl) {
        <div class="post-detail-image">
          <img [src]="post.imageUrl" [alt]="post.title" />
        </div>
      }

      @if (post.description) {
        <div class="post-detail-description">{{ post.description }}</div>
      }

      <div class="post-detail-footer">
        <app-vote-buttons
          [upvotes]="post.upvotes"
          [downvotes]="post.downvotes"
          [userVote]="post.userVote"
          orientation="horizontal"
          (vote)="handlePostVote($event)"
        ></app-vote-buttons>

        <button class="post-detail-action" (click)="share()">
          <span class="material-icons">share</span>
          <span>Share</span>
        </button>

        <button class="post-detail-action" (click)="toggleFavorite()">
          <span class="material-icons">
            {{ isFavorite() ? 'bookmark' : 'bookmark_border' }}
          </span>
          <span>Save</span>
        </button>
      </div>
    </article>

    <section class="comments-section">
      <div class="comments-header">
        <h2>Comments ({{ post.commentCount }})</h2>
        <select
          class="comment-sort"
          [ngModel]="commentSort()"
          (ngModelChange)="changeCommentSort($event)"
        >
          <option value="best">Best</option>
          <option value="new">New</option>
          <option value="top">Top</option>
        </select>
      </div>

      @if (isAuthenticated()) {
        <app-comment-form (submit)="addComment($event)"></app-comment-form>
      } @else {
        <div class="login-prompt">
          <p>
            Please <a routerLink="/login">login</a> to comment
          </p>
        </div>
      }

      <div class="comments-list">
        <app-comment-thread
          [comments]="comments()"
          (reply)="handleCommentReply($event)"
          (vote)="handleCommentVote($event)"
          (delete)="handleCommentDelete($event)"
        ></app-comment-thread>
      </div>
    </section>
  } @else {
    <div class="error-state">
      <span class="material-icons">error_outline</span>
      <h2>Post not found</h2>
      <p>
        This post may have been deleted or you don't have permission to view it.
      </p>
      <button routerLink="/feed" class="back-btn">Back to Feed</button>
    </div>
  }
</div>
FILE: frontend/src/app/features/posts/post-detail/post-detail.ts
import { ChangeDetectionStrategy, Component, DestroyRef, OnInit, inject, signal, computed } from '@angular/core';
import { ActivatedRoute, Router, RouterLink } from '@angular/router';
import { takeUntilDestroyed } from '@angular/core/rxjs-interop';
import { CommonModule } from '@angular/common';
import { FormsModule } from '@angular/forms';
import { VoteButtons } from '../../../shared/components/vote-buttons/vote-buttons';
import { UserAvatar } from '../../../shared/components/user-avatar/user-avatar';
import { CommentForm } from '../../comments/comment-form/comment-form';
import { CommentThread } from '../../comments/comment-thread/comment-thread';
import { LoadingSpinner } from '../../../shared/components/loading-spinner/loading-spinner';
import { PostService } from '../services/post';
import { CommentService } from '../../comments/services/comment';
import { Post } from '../../../core/models/post.model';
import { Comment } from '../../../core/models/comment.model';
import { Auth } from '../../../core/services/auth';
import { FavoriteState } from '../../../core/services/favorite';
@Component({
  selector: 'app-post-detail',
  standalone: true,
  imports: [
    CommonModule,
    FormsModule,
    RouterLink,
    VoteButtons,
    UserAvatar,
    CommentForm,
    CommentThread,
    LoadingSpinner,
  ],
  templateUrl: './post-detail.html',
  styleUrl: './post-detail.css',
  changeDetection: ChangeDetectionStrategy.OnPush,
})
export class PostDetail implements OnInit {
  private readonly route = inject(ActivatedRoute);
  private readonly router = inject(Router);
  private readonly postService = inject(PostService);
  private readonly commentService = inject(CommentService);
  private readonly destroyRef = inject(DestroyRef);
  private readonly auth = inject(Auth);
  private readonly favoriteState = inject(FavoriteState);
  readonly post = signal<Post | null>(null);
  readonly comments = signal<Comment[]>([]);
  readonly isLoading = signal(true);
  readonly isFavorite = signal(false);
  readonly commentSort = signal<'best' | 'new' | 'top'>('best');
  readonly isAuthenticated = this.auth.isAuthenticated;
  readonly canModerate = computed(() => {
    const currentUser = this.auth.user();
    const postData = this.post();
    if (!currentUser || !postData) return false;
    return currentUser.id === postData.userId || currentUser.role === 'admin';
  });
  ngOnInit() {
    const postId = Number(this.route.snapshot.paramMap.get('id'));
    this.loadPost(postId);
    this.loadComments(postId);
  }
  private loadPost(id: number) {
    this.postService
      .getOne(id)
      .pipe(takeUntilDestroyed(this.destroyRef))
      .subscribe({
        next: (post) => {
          this.post.set(post);
          this.isFavorite.set(post.isFavorited);
          this.isLoading.set(false);
        },
        error: (error) => {
          console.error('Failed to load post', error);
          this.post.set(null);
          this.isLoading.set(false);
        },
      });
  }
  private loadComments(postId: number) {
    this.commentService
      .getTree(postId)
      .pipe(takeUntilDestroyed(this.destroyRef))
      .subscribe({
        next: (comments) => {
          const commentsWithOp = comments.map(comment =>
            this.markOp(comment, this.post()?.userId ?? 0)
          );
          this.comments.set(commentsWithOp);
        },
        error: (error) => {
          console.error('Failed to load comments', error);
          this.comments.set([]);
        },
      });
  }
  private markOp(comment: Comment, opUserId: number): Comment {
    return {
      ...comment,
      isOp: comment.userId === opUserId,
      replies: comment.replies.map(reply => this.markOp(reply, opUserId)),
    };
  }
  handlePostVote(vote: 'up' | 'down') {
  const currentPost = this.post();
  if (!currentPost) return;
  const currentVote = currentPost.userVote;
  if (currentVote === vote) {
    this.postService.removeVote(currentPost.id, currentVote).subscribe({
      next: () => this.loadPost(currentPost.id),
      error: (err) => console.error('Failed to remove vote', err),
    });
  } else {
    this.postService.vote(currentPost.id, vote, currentVote).subscribe({
      next: () => this.loadPost(currentPost.id),
      error: (err) => console.error('Failed to vote', err),
    });
  }
}
  toggleFavorite() {
    const currentPost = this.post();
    if (!currentPost) return;
    const currentFavoriteState = this.isFavorite();
    if (currentFavoriteState) {
      this.postService.unfavorite(currentPost.id).subscribe({
        next: () => {
          this.isFavorite.set(false);
          if (currentPost) currentPost.isFavorited = false;
          this.favoriteState.notifyChange();
        },
        error: (err) => {
          console.error('Failed to unfavorite', err);
          alert('Failed to remove bookmark. Please try again.');
        },
      });
    } else {
      this.postService.favorite(currentPost.id).subscribe({
        next: () => {
          this.isFavorite.set(true);
          if (currentPost) currentPost.isFavorited = true;
          this.favoriteState.notifyChange();
        },
        error: (err) => {
          console.error('Failed to favorite', err);
          alert('Failed to bookmark. Please try again.');
        },
      });
    }
  }
  share() {
    const currentPost = this.post();
    if (!currentPost) return;
    if (navigator.share) {
      navigator.share({
        title: currentPost.title,
        text: currentPost.description ?? '',
        url: window.location.href,
      }).catch(() => {});
    } else {
      navigator.clipboard.writeText(window.location.href);
      alert('Link copied to clipboard!');
    }
  }
  addComment(content: string) {
    const currentPost = this.post();
    if (!currentPost) return;
    this.commentService.create(currentPost.id, content).subscribe({
      next: () => {
        this.loadComments(currentPost.id);
        currentPost.commentCount++;
      },
      error: (err) => console.error('Failed to add comment', err),
    });
  }
  handleCommentReply(event: { commentId: number; content: string }) {
    const currentPost = this.post();
    if (!currentPost) return;
    this.commentService
      .create(currentPost.id, event.content, event.commentId)
      .subscribe({
        next: () => {
          this.loadComments(currentPost.id);
          currentPost.commentCount++;
        },
        error: (err) => console.error('Failed to reply to comment', err),
      });
  }
  handleCommentVote(event: { commentId: number; voteType: 'up' | 'down' }) {
    this.commentService.vote(event.commentId, event.voteType).subscribe({
      next: () => {
        const currentPost = this.post();
        if (currentPost) {
          this.loadComments(currentPost.id);
        }
      },
      error: (err) => console.error('Failed to vote on comment', err),
    });
  }
  handleCommentDelete(commentId: number) {
    if (!confirm('Are you sure you want to delete this comment?')) return;
    this.commentService.delete(commentId).subscribe({
      next: () => {
        const currentPost = this.post();
        if (currentPost) {
          this.loadComments(currentPost.id);
          currentPost.commentCount--;
        }
      },
      error: (err) => console.error('Failed to delete comment', err),
    });
  }
  changeCommentSort(sortBy: 'best' | 'new' | 'top') {
    this.commentSort.set(sortBy);
    const currentPost = this.post();
    if (currentPost) {
      this.loadComments(currentPost.id);
    }
  }
  deletePost() {
    const currentPost = this.post();
    if (!currentPost) return;
    if (!confirm('Are you sure you want to delete this post? This action cannot be undone.')) {
      return;
    }
    this.postService.delete(currentPost.id).subscribe({
      next: () => {
        alert('Post deleted successfully');
        this.router.navigate(['/feed']);
      },
      error: (err) => {
        console.error('Failed to delete post', err);
        alert('Failed to delete post. Please try again.');
      },
    });
  }
  formatTime(isoDate: string): string {
    const date = new Date(isoDate);
    const diff = (Date.now() - date.getTime()) / 1000;
    if (diff < 60) return 'Just now';
    if (diff < 3600) return `${Math.floor(diff / 60)}m ago`;
    if (diff < 86400) return `${Math.floor(diff / 3600)}h ago`;
    if (diff < 604800) return `${Math.floor(diff / 86400)}d ago`;
    return date.toLocaleDateString();
  }
}
FILE: frontend/src/app/features/posts/post-list/post-list.css
[EMPTY FILE]
FILE: frontend/src/app/features/posts/post-list/post-list.html
<p>post-list works!</p>
FILE: frontend/src/app/features/posts/post-list/post-list.ts
import { Component } from '@angular/core';
@Component({
  selector: 'app-post-list',
  imports: [],
  templateUrl: './post-list.html',
  styleUrl: './post-list.css',
})
export class PostList {
}
FILE: frontend/src/app/features/posts/services/post.ts
import { inject, Injectable } from '@angular/core';
import { HttpClient, HttpParams } from '@angular/common/http';
import { environment } from '../../../core/config/environment';
import { map, tap } from 'rxjs';
import { Post, PostList } from '../../../core/models/post.model';
import { VoteState } from '../../../core/services/vote-state';
import { Websocket } from '../../../core/services/websocket';
interface PostDto {
  id: number;
  user_id: number;
  title: string;
  description: string | null;
  tag: string | null;
  image_url: string | null;
  upvotes: number;
  downvotes: number;
  comment_count: number;
  created_at: string;
  updated_at: string | null;
  author_username: string;
  author_avatar: string | null;
  user_vote: 'up' | 'down' | null;
  is_favorited: boolean;
}
interface PostListDto {
  posts: PostDto[];
  total: number;
  page: number;
  page_size: number;
  has_more: boolean;
}
interface CreatePostDto {
  title: string;
  description?: string | null;
  tag?: string | null;
  imageUrl?: string | null;
}
@Injectable({ providedIn: 'root' })
export class PostService {
  private readonly http = inject(HttpClient);
  private readonly voteState = inject(VoteState);
  private readonly websocket = inject(Websocket);
  list(options: { page?: number; sortBy?: 'new' | 'hot' | 'top'; tag?: string | null } = {}) {
    const params = new HttpParams({
      fromObject: {
        page: (options.page ?? 1).toString(),
        page_size: '20',
        sort_by: options.sortBy ?? 'new',
        ...(options.tag ? { tag: options.tag } : {}),
      },
    });
    return this.http
      .get<PostListDto>(`${environment.apiUrl}/posts`, { params })
      .pipe(map((dto) => this.mapList(dto)));
  }
  getOne(id: number | string) {
    return this.http
      .get<PostDto>(`${environment.apiUrl}/posts/${id}`)
      .pipe(map((dto) => this.mapPost(dto)));
  }
  create(payload: CreatePostDto) {
    const body = {
      title: payload.title,
      description: payload.description ?? null,
      tag: payload.tag ?? null,
      image_url: payload.imageUrl ?? null,
    };
    return this.http
      .post<PostDto>(`${environment.apiUrl}/posts`, body)
      .pipe(map((dto) => this.mapPost(dto)));
  }
  delete(postId: number) {
    return this.http.delete(`${environment.apiUrl}/posts/${postId}`);
  }
  vote(postId: number, voteType: 'up' | 'down', currentVote: 'up' | 'down' | null) {
    this.voteState.optimisticVote('post', postId, voteType, currentVote);
    this.voteState.setPending('post', postId, true);
    return this.http.post<{
      upvotes: number;
      downvotes: number;
      user_vote: 'up' | 'down' | null;
    }>(`${environment.apiUrl}/posts/${postId}/vote`, {
      vote_type: voteType,
    }).pipe(
      tap(response => {
        this.voteState.setPending('post', postId, false);
      })
    );
  }
  removeVote(postId: number, currentVote: 'up' | 'down' | null) {
    this.voteState.optimisticVote('post', postId, null, currentVote);
    this.voteState.setPending('post', postId, true);
    return this.http.delete<{
      upvotes: number;
      downvotes: number;
      user_vote: null;
    }>(`${environment.apiUrl}/posts/${postId}/vote`).pipe(
      tap(response => {
        this.voteState.setPending('post', postId, false);
      })
    );
  }
  favorite(postId: number) {
    return this.http.post(`${environment.apiUrl}/posts/${postId}/favorite`, {});
  }
  unfavorite(postId: number) {
    return this.http.delete(`${environment.apiUrl}/posts/${postId}/favorite`);
  }
  getFavorites(options: { page?: number } = {}) {
    const params = new HttpParams({
      fromObject: {
        page: (options.page ?? 1).toString(),
        page_size: '20',
      },
    });
    return this.http
      .get<PostListDto>(`${environment.apiUrl}/posts/favorites`, { params })
      .pipe(map((dto) => this.mapList(dto)));
  }
  private mapList(dto: PostListDto): PostList {
    return {
      posts: dto.posts.map((post) => this.mapPost(post)),
      total: dto.total,
      page: dto.page,
      pageSize: dto.page_size,
      hasMore: dto.has_more,
    };
  }
  private mapPost(dto: PostDto): Post {
    return {
      id: dto.id,
      userId: dto.user_id,
      title: dto.title,
      description: dto.description,
      tag: dto.tag,
      imageUrl: dto.image_url,
      upvotes: dto.upvotes,
      downvotes: dto.downvotes,
      commentCount: dto.comment_count,
      createdAt: dto.created_at,
      updatedAt: dto.updated_at,
      authorUsername: dto.author_username,
      authorAvatar: dto.author_avatar,
      userVote: dto.user_vote,
      isFavorited: dto.is_favorited,
    };
  }
}
FILE: frontend/src/app/features/user/profile/profile.css
[EMPTY FILE]
FILE: frontend/src/app/features/user/profile/profile.html
<p>profile works!</p>
FILE: frontend/src/app/features/user/profile/profile.ts
import { Component } from '@angular/core';
@Component({
  selector: 'app-profile',
  imports: [],
  templateUrl: './profile.html',
  styleUrl: './profile.css',
})
export class Profile {
}
FILE: frontend/src/app/features/user/services/user.ts
import { Injectable } from '@angular/core';
@Injectable({
  providedIn: 'root',
})
export class User {
}
FILE: frontend/src/app/features/user/settings/settings.css
[EMPTY FILE]
FILE: frontend/src/app/features/user/settings/settings.html
<p>settings works!</p>
FILE: frontend/src/app/features/user/settings/settings.ts
import { Component } from '@angular/core';
@Component({
  selector: 'app-settings',
  imports: [],
  templateUrl: './settings.html',
  styleUrl: './settings.css',
})
export class Settings {
}
FILE: frontend/src/app/pages/category/category.ts
import { ChangeDetectionStrategy, Component, DestroyRef, OnInit, inject, signal } from '@angular/core';
import { ActivatedRoute } from '@angular/router';
import { takeUntilDestroyed } from '@angular/core/rxjs-interop';
import { PostCard } from '../../features/posts/post-card/post-card';
import { LoadingSpinner } from '../../shared/components/loading-spinner/loading-spinner';
import { PostService } from '../../features/posts/services/post';
import { Post } from '../../core/models/post.model';
@Component({
  selector: 'app-category',
  standalone: true,
  imports: [PostCard, LoadingSpinner],
  template: `
    <div class="feed-container">
      <div class="feed-header">
        <h1 class="feed-title">{{ getCategoryTitle() }}</h1>
      </div>
      <div class="posts-list">
        @for (post of posts(); track post.id) {
          <app-post-card [post]="post"></app-post-card>
        } @empty {
          @if (!isLoading()) {
            <div class="empty-state">
              <span class="material-icons">inbox</span>
              <p>No posts in this category yet. Be the first to post!</p>
            </div>
          }
        }
      </div>
      @if (isLoading()) {
        <app-loading-spinner></app-loading-spinner>
      }
    </div>
  `,
  styles: [`
    .feed-container {
      max-width: 800px;
      margin: 0 auto;
    }
    .feed-header {
      margin-bottom: 24px;
    }
    .feed-title {
      font-size: 24px;
      font-weight: 700;
      color: var(--text-primary);
      text-transform: capitalize;
    }
    .posts-list {
      display: flex;
      flex-direction: column;
      gap: 16px;
    }
    .empty-state {
      text-align: center;
      padding: 60px 20px;
      color: var(--text-secondary);
    }
    .empty-state .material-icons {
      font-size: 64px;
      color: var(--text-muted);
      margin-bottom: 16px;
    }
  `],
  changeDetection: ChangeDetectionStrategy.OnPush,
})
export class Category implements OnInit {
  private readonly route = inject(ActivatedRoute);
  private readonly postService = inject(PostService);
  private readonly destroyRef = inject(DestroyRef);
  readonly posts = signal<Post[]>([]);
  readonly isLoading = signal(false);
  readonly category = signal<string>('');
  ngOnInit() {
    this.route.paramMap.pipe(takeUntilDestroyed(this.destroyRef)).subscribe(params => {
      const categorySlug = params.get('slug');
      if (categorySlug) {
        this.category.set(categorySlug);
        this.loadPosts(categorySlug);
      }
    });
  }
  loadPosts(tag: string) {
    this.isLoading.set(true);
    this.postService
      .list({ tag, sortBy: 'new' })
      .pipe(takeUntilDestroyed(this.destroyRef))
      .subscribe({
        next: (list) => {
          this.posts.set(list.posts);
          this.isLoading.set(false);
        },
        error: (error) => {
          console.error('Failed to load posts', error);
          this.posts.set([]);
          this.isLoading.set(false);
        },
      });
  }
  getCategoryTitle(): string {
    const cat = this.category();
    return cat ? `#${cat}` : 'Category';
  }
}
FILE: frontend/src/app/pages/feed/feed.css
.feed-container {
  max-width: 800px;
  margin: 0 auto;
}
.feed-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 24px;
}
.feed-title {
  font-size: 24px;
  font-weight: 700;
  color: var(--text-primary);
}
.feed-filters {
  display: flex;
  gap: 8px;
}
.filter-btn {
  display: flex;
  align-items: center;
  gap: 4px;
  padding: 8px 16px;
  background-color: var(--bg-secondary);
  border: 1px solid var(--border-primary);
  border-radius: 20px;
  color: var(--text-secondary);
  font-family: 'JetBrains Mono', monospace;
  font-size: 14px;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.2s;
}
.filter-btn:hover {
  background-color: var(--bg-hover);
  color: var(--text-primary);
}
.filter-btn.active {
  background-color: var(--primary-orange);
  border-color: var(--primary-orange);
  color: white;
}
.filter-btn .material-icons {
  font-size: 18px;
}
.posts-list {
  min-height: 400px;
}
.empty-state {
  text-align: center;
  padding: 60px 20px;
  color: var(--text-secondary);
}
.empty-state .material-icons {
  font-size: 64px;
  color: var(--text-muted);
  margin-bottom: 16px;
}
FILE: frontend/src/app/pages/feed/feed.html
<div class="feed-container">
  <div class="feed-header">
    <h1 class="feed-title">{{ feedTitle() }}</h1>
  </div>

  <div class="posts-list">
    @for (post of posts(); track post.id) {
      <app-post-card [post]="post"></app-post-card>
    } @empty {
      <div class="empty-state">
        <span class="material-icons">article</span>
        <p>No posts yet. Be the first to share a meme!</p>
      </div>
    }
  </div>

  @if (isLoading()) {
    <app-loading-spinner></app-loading-spinner>
  }
</div>
FILE: frontend/src/app/pages/feed/feed.ts
import { ChangeDetectionStrategy, Component, DestroyRef, OnInit, computed, inject, signal } from '@angular/core';
import { ActivatedRoute, Router } from '@angular/router';
import { takeUntilDestroyed } from '@angular/core/rxjs-interop';
import { PostCard } from '../../features/posts/post-card/post-card';
import { LoadingSpinner } from '../../shared/components/loading-spinner/loading-spinner';
import { PostService } from '../../features/posts/services/post';
import { Post } from '../../core/models/post.model';
type FeedFilter = 'home' | 'hot' | 'new' | 'top';
@Component({
  selector: 'app-feed',
  standalone: true,
  imports: [PostCard, LoadingSpinner],
  templateUrl: './feed.html',
  styleUrls: ['./feed.css'],
  changeDetection: ChangeDetectionStrategy.OnPush,
})
export class Feed implements OnInit {
  private readonly postService = inject(PostService);
  private readonly destroyRef = inject(DestroyRef);
  private readonly route = inject(ActivatedRoute);
  private readonly router = inject(Router);
  readonly posts = signal<Post[]>([]);
  readonly currentFilter = signal<FeedFilter>('home');
  readonly isLoading = signal(false);
  private readonly validFilters: FeedFilter[] = ['home', 'hot', 'new', 'top'];
  readonly feedTitle = computed(() => this.getFeedTitle(this.currentFilter()));
  ngOnInit() {
    this.route.paramMap
      .pipe(takeUntilDestroyed(this.destroyRef))
      .subscribe((params) => {
        const param = params.get('filter') as FeedFilter | null;
        const filter = param && this.validFilters.includes(param) ? param : 'home';
        this.currentFilter.set(filter);
        this.loadPosts();
      });
    if (!this.route.snapshot.paramMap.get('filter')) {
      this.loadPosts();
    }
  }
  loadPosts() {
    const filter = this.currentFilter();
    this.isLoading.set(true);
    this.postService
      .list({ sortBy: this.getSortParam(filter) })
      .pipe(takeUntilDestroyed(this.destroyRef))
      .subscribe({
        next: (list) => {
          let posts = [...list.posts];
          switch (filter) {
            case 'home':
              posts = this.shufflePosts(posts);
              break;
            case 'hot':
              posts.sort((a, b) => (b.commentCount ?? 0) - (a.commentCount ?? 0));
              break;
            case 'top':
              posts.sort((a, b) => b.upvotes - a.upvotes);
              break;
            case 'new':
              posts.sort(
                (a, b) =>
                  new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime(),
              );
              break;
          }
          this.posts.set(posts);
          this.isLoading.set(false);
        },
        error: (error) => {
          console.error('Failed to load posts', error);
          this.posts.set([]);
          this.isLoading.set(false);
        },
      });
  }
  private getSortParam(filter: FeedFilter): 'new' | 'hot' | 'top' {
    switch (filter) {
      case 'top':
        return 'top';
      case 'hot':
        return 'new';
      default:
        return 'new';
    }
  }
  private shufflePosts(posts: Post[]): Post[] {
    const shuffled = [...posts];
    for (let i = shuffled.length - 1; i > 0; i -= 1) {
      const j = Math.floor(Math.random() * (i + 1));
      [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
    }
    return shuffled;
  }
  getFeedTitle(filter: FeedFilter): string {
    switch (filter) {
      case 'hot':
        return 'ğŸ”¥ Hot posts (most discussed)';
      case 'new':
        return 'ğŸ†• Latest memes';
      case 'top':
        return 'ğŸ“ˆ Top upvoted memes';
      default:
        return 'ğŸ  Home feed';
    }
  }
  setFilter(filter: FeedFilter) {
    if (filter === this.currentFilter()) return;
    if (filter === 'home') {
      void this.router.navigate(['/feed']);
    } else {
      void this.router.navigate(['/feed', filter]);
    }
  }
}
FILE: frontend/src/app/pages/home/home.css
[EMPTY FILE]
FILE: frontend/src/app/pages/home/home.html
<p>home works!</p>
FILE: frontend/src/app/pages/home/home.ts
import { Component } from '@angular/core';
@Component({
  selector: 'app-home',
  imports: [],
  templateUrl: './home.html',
  styleUrl: './home.css',
})
export class Home {
}
FILE: frontend/src/app/pages/not-found/not-found.css
[EMPTY FILE]
FILE: frontend/src/app/pages/not-found/not-found.html
<p>not-found works!</p>
FILE: frontend/src/app/pages/not-found/not-found.ts
import { Component } from '@angular/core';
@Component({
  selector: 'app-not-found',
  imports: [],
  templateUrl: './not-found.html',
  styleUrl: './not-found.css',
})
export class NotFound {
}
FILE: frontend/src/app/pages/saved-posts/saved-posts.ts
import { ChangeDetectionStrategy, Component, DestroyRef, OnInit, inject, signal, effect } from '@angular/core';
import { takeUntilDestroyed } from '@angular/core/rxjs-interop';
import { CommonModule } from '@angular/common';
import { PostCard } from '../../features/posts/post-card/post-card';
import { LoadingSpinner } from '../../shared/components/loading-spinner/loading-spinner';
import { PostService } from '../../features/posts/services/post';
import { Post } from '../../core/models/post.model';
import { FavoriteState } from '../../core/services/favorite';
@Component({
  selector: 'app-saved-posts',
  standalone: true,
  imports: [CommonModule, PostCard, LoadingSpinner],
  template: `
    <div class="feed-container">
      <div class="feed-header">
        <h1 class="feed-title">ğŸ”– Saved Posts</h1>
        <button class="refresh-btn" (click)="loadSavedPosts()" [disabled]="isLoading()">
          <span class="material-icons">refresh</span>
        </button>
      </div>
      <div class="posts-list">
        @for (post of posts(); track post.id) {
          <app-post-card [post]="post"></app-post-card>
        } @empty {
          @if (!isLoading()) {
            <div class="empty-state">
              <span class="material-icons">bookmark_border</span>
              <p>No saved posts yet. Save posts to view them here!</p>
            </div>
          }
        }
      </div>
      @if (isLoading()) {
        <app-loading-spinner></app-loading-spinner>
      }
    </div>
  `,
  styles: [`
    .feed-container {
      max-width: 800px;
      margin: 0 auto;
      padding: 20px;
    }
    .feed-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 24px;
    }
    .feed-title {
      font-size: 24px;
      font-weight: 700;
      color: var(--text-primary);
    }
    .refresh-btn {
      display: flex;
      align-items: center;
      justify-content: center;
      width: 40px;
      height: 40px;
      border: none;
      background: var(--bg-secondary);
      border-radius: 50%;
      cursor: pointer;
      color: var(--text-primary);
      transition: all 0.2s;
      border: 1px solid var(--border-primary);
    }
    .refresh-btn:hover:not(:disabled) {
      background: var(--bg-hover);
      transform: rotate(180deg);
    }
    .refresh-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    .posts-list {
      display: flex;
      flex-direction: column;
      gap: 16px;
    }
    .empty-state {
      text-align: center;
      padding: 60px 20px;
      color: var(--text-secondary);
    }
    .empty-state .material-icons {
      font-size: 64px;
      color: var(--text-muted);
      margin-bottom: 16px;
    }
  `],
  changeDetection: ChangeDetectionStrategy.OnPush,
})
export class SavedPosts implements OnInit {
  private readonly postService = inject(PostService);
  private readonly destroyRef = inject(DestroyRef);
  private readonly favoriteState = inject(FavoriteState);
  readonly posts = signal<Post[]>([]);
  readonly isLoading = signal(false);
  constructor() {
    effect(() => {
      this.favoriteState.changed();
      this.loadSavedPosts();
    }, { allowSignalWrites: true });
  }
  ngOnInit() {
    this.loadSavedPosts();
  }
  loadSavedPosts() {
    this.isLoading.set(true);
    this.postService
      .getFavorites()
      .pipe(takeUntilDestroyed(this.destroyRef))
      .subscribe({
        next: (list) => {
          console.log('âœ… Loaded saved posts:', list.posts.length);
          this.posts.set(list.posts);
          this.isLoading.set(false);
        },
        error: (error) => {
          console.error('âŒ Failed to load saved posts', error);
          this.posts.set([]);
          this.isLoading.set(false);
        },
      });
  }
}
FILE: frontend/src/app/shared/components/confirm-dialog/confirm-dialog.css
.dialog-overlay {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: rgba(0, 0, 0, 0.8);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 9999;
  animation: fadeIn 0.2s;
}
.dialog-container {
  background-color: var(--bg-secondary);
  border: 1px solid var(--border-primary);
  border-radius: 8px;
  max-width: 400px;
  width: 90%;
  animation: slideUp 0.3s;
}
.dialog-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 20px;
  border-bottom: 1px solid var(--border-primary);
}
.dialog-header h2 {
  font-size: 18px;
  font-weight: 600;
  color: var(--text-primary);
  margin: 0;
}
.dialog-close {
  background: none;
  border: none;
  color: var(--text-secondary);
  cursor: pointer;
  padding: 4px;
  border-radius: 4px;
  transition: all 0.2s;
}
.dialog-close:hover {
  background-color: var(--bg-hover);
  color: var(--text-primary);
}
.dialog-body {
  padding: 20px;
}
.dialog-body p {
  color: var(--text-primary);
  line-height: 1.5;
  margin: 0;
}
.dialog-footer {
  display: flex;
  justify-content: flex-end;
  gap: 12px;
  padding: 20px;
  border-top: 1px solid var(--border-primary);
}
.dialog-btn {
  padding: 8px 20px;
  border-radius: 4px;
  font-family: 'JetBrains Mono', monospace;
  font-size: 14px;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.2s;
  border: none;
}
.dialog-btn.cancel {
  background-color: var(--bg-tertiary);
  color: var(--text-primary);
}
.dialog-btn.cancel:hover {
  background-color: var(--bg-hover);
}
.dialog-btn.confirm {
  background-color: var(--primary-orange);
  color: white;
}
.dialog-btn.confirm:hover {
  background-color: var(--primary-orange-light);
}
.dialog-btn.confirm.danger {
  background-color: var(--error);
}
.dialog-btn.confirm.danger:hover {
  background-color: #ff1744;
}
@keyframes fadeIn {
  from { opacity: 0; }
  to { opacity: 1; }
}
@keyframes slideUp {
  from {
    transform: translateY(20px);
    opacity: 0;
  }
  to {
    transform: translateY(0);
    opacity: 1;
  }
}
FILE: frontend/src/app/shared/components/confirm-dialog/confirm-dialog.html
<div class="dialog-overlay" (click)="cancel()">
  <div class="dialog-container" (click)="$event.stopPropagation()">
    <div class="dialog-header">
      <h2>{{ title() }}</h2>
      <button class="dialog-close" (click)="cancel()">
        <span class="material-icons">close</span>
      </button>
    </div>

    <div class="dialog-body">
      <p>{{ message() }}</p>
    </div>

    <div class="dialog-footer">
      <button class="dialog-btn cancel" (click)="cancel()">
        {{ cancelText() }}
      </button>
      <button class="dialog-btn confirm" [class.danger]="isDanger()" (click)="confirm()">
        {{ confirmText() }}
      </button>
    </div>
  </div>
</div>
FILE: frontend/src/app/shared/components/confirm-dialog/confirm-dialog.ts
import { Component, input, output } from '@angular/core';
@Component({
  selector: 'app-confirm-dialog',
  templateUrl: './confirm-dialog.html',
  styleUrl: './confirm-dialog.css'
})
export class ConfirmDialog {
  title = input<string>('Confirm Action');
  message = input<string>('Are you sure you want to proceed?');
  confirmText = input<string>('Confirm');
  cancelText = input<string>('Cancel');
  isDanger = input<boolean>(false);
  confirmed = output<void>();
  cancelled = output<void>();
  confirm() {
    this.confirmed.emit();
  }
  cancel() {
    this.cancelled.emit();
  }
}
FILE: frontend/src/app/shared/components/error-message/error-message.css
.error-message-container {
  display: flex;
  align-items: flex-start;
  gap: 12px;
  padding: 16px;
  border-radius: 4px;
  border: 1px solid;
  margin-bottom: 16px;
  position: relative;
}
.error-message-container.error-error {
  background-color: rgba(234, 0, 39, 0.1);
  border-color: var(--error);
  color: var(--error);
}
.error-message-container.error-warning {
  background-color: rgba(255, 214, 53, 0.1);
  border-color: var(--warning);
  color: var(--warning);
}
.error-message-container.error-info {
  background-color: rgba(113, 147, 255, 0.1);
  border-color: var(--downvote);
  color: var(--downvote);
}
.error-message-container.error-success {
  background-color: rgba(70, 209, 96, 0.1);
  border-color: var(--success);
  color: var(--success);
}
.error-content {
  flex: 1;
}
.error-title {
  font-size: 14px;
  font-weight: 600;
  margin: 0 0 4px 0;
}
.error-text {
  font-size: 13px;
  margin: 0;
  opacity: 0.9;
}
.dismiss-btn {
  background: none;
  border: none;
  color: inherit;
  cursor: pointer;
  padding: 4px;
  opacity: 0.7;
  transition: opacity 0.2s;
}
.dismiss-btn:hover {
  opacity: 1;
}
FILE: frontend/src/app/shared/components/error-message/error-message.html
<div class="error-message-container" [class]="'error-' + type()">
  <span class="material-icons">{{ getIcon() }}</span>
  <div class="error-content">
    <h3 class="error-title">{{ title() }}</h3>
    <p class="error-text">{{ message() }}</p>
  </div>
  @if (dismissible()) {
    <button class="dismiss-btn" (click)="dismiss.emit()">
      <span class="material-icons">close</span>
    </button>
  }
</div>
FILE: frontend/src/app/shared/components/error-message/error-message.ts
import { Component, input, output } from '@angular/core';
@Component({
  selector: 'app-error-message',
  templateUrl: './error-message.html',
  styleUrl: './error-message.css'
})
export class ErrorMessage {
  type = input<'error' | 'warning' | 'info' | 'success'>('error');
  title = input<string>('');
  message = input.required<string>();
  dismissible = input<boolean>(false);
  dismiss = output<void>();
  getIcon(): string {
    switch (this.type()) {
      case 'error': return 'error';
      case 'warning': return 'warning';
      case 'info': return 'info';
      case 'success': return 'check_circle';
      default: return 'error';
    }
  }
}
FILE: frontend/src/app/shared/components/header/header.css
.header {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  height: 48px;
  background-color: var(--bg-secondary);
  border-bottom: 1px solid var(--border-primary);
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 0 16px;
  z-index: 1000;
}
.header-left {
  display: flex;
  align-items: center;
  gap: 16px;
}
.menu-toggle {
  display: none;
  background: none;
  border: none;
  color: var(--text-primary);
  cursor: pointer;
  padding: 4px;
}
.logo {
  display: flex;
  align-items: center;
  gap: 8px;
  cursor: pointer;
  text-decoration: none;
  color: var(--text-primary);
}
.logo-icon {
  font-size: 24px;
}
.logo-text {
  font-size: 18px;
  font-weight: 700;
  color: var(--primary-orange);
}
.header-center {
  flex: 1;
  max-width: 600px;
  margin: 0 20px;
}
.search-bar {
  position: relative;
  width: 100%;
}
.search-icon {
  position: absolute;
  left: 12px;
  top: 50%;
  transform: translateY(-50%);
  color: var(--text-secondary);
  font-size: 20px;
}
.search-input {
  width: 100%;
  padding: 8px 12px 8px 40px;
  background-color: var(--bg-tertiary);
  border: 1px solid var(--border-primary);
  border-radius: 20px;
  color: var(--text-primary);
  font-family: 'JetBrains Mono', monospace;
  font-size: 14px;
  outline: none;
  transition: all 0.2s;
}
.search-input:focus {
  border-color: var(--primary-orange);
  background-color: var(--bg-primary);
}
.header-right {
  display: flex;
  align-items: center;
  gap: 12px;
}
.icon-button {
  background: none;
  border: none;
  color: var(--text-primary);
  cursor: pointer;
  padding: 8px;
  border-radius: 4px;
  transition: background-color 0.2s;
}
.icon-button:hover {
  background-color: var(--bg-hover);
}
.user-menu {
  display: flex;
  align-items: center;
  gap: 4px;
  padding: 4px 8px;
}
.login-btn {
  padding: 6px 16px;
  background-color: var(--primary-orange);
  color: white;
  border: none;
  border-radius: 20px;
  font-family: 'JetBrains Mono', monospace;
  font-weight: 500;
  cursor: pointer;
  transition: background-color 0.2s;
}
.login-btn:hover {
  background-color: var(--primary-orange-light);
}
@media (max-width: 960px) {
  .menu-toggle {
    display: block;
  }
  .header-center {
    display: none;
  }
}
FILE: frontend/src/app/shared/components/header/header.html
<header class="header">
  <div class="header-left">
    <button class="menu-toggle" (click)="toggleSidebar()">
      <span class="material-icons">menu</span>
    </button>
    <div class="logo" routerLink="/feed">
      <span class="logo-icon">ğŸ”¥</span>
      <span class="logo-text">MemeForum</span>
    </div>
  </div>

  <div class="header-center">
    <div class="search-bar">
      <span class="material-icons search-icon">search</span>
      <input type="text" placeholder="Search memes..." class="search-input" />
    </div>
  </div>

  <div class="header-right">
    <button class="icon-button" routerLink="/create-post" *ngIf="isAuthenticated()">
      <span class="material-icons">add</span>
    </button>

    <app-notification-bell *ngIf="isAuthenticated()"></app-notification-bell>

    @if (isAuthenticated()) {

      <div class="user-menu">
        <app-user-avatar
          [size]="32"
          [username]="user()?.username ?? ''"
          [imageUrl]="user()?.avatarUrl ?? ''"
        ></app-user-avatar>
      </div>
      <button class="login-btn" type="button" (click)="logout()">Logout</button>
    } @else {
      <button class="login-btn" routerLink="/login">Login</button>
    }
  </div>
</header>
FILE: frontend/src/app/shared/components/header/header.ts
import { ChangeDetectionStrategy, Component, inject } from '@angular/core';
import { CommonModule } from '@angular/common';
import { RouterLink } from '@angular/router';
import { NotificationBell } from '../../../features/notifications/notification-bell/notification-bell';
import { UserAvatar } from '../user-avatar/user-avatar';
import { Auth } from '../../../core/services/auth';
@Component({
  selector: 'app-header',
  standalone: true,
  imports: [CommonModule, RouterLink, NotificationBell, UserAvatar],
  templateUrl: './header.html',
  styleUrls: ['./header.css'],
  changeDetection: ChangeDetectionStrategy.OnPush,
})
export class Header {
  private readonly auth = inject(Auth);
  readonly isAuthenticated = this.auth.isAuthenticated;
  readonly user = this.auth.user;
  toggleSidebar() {
    console.log('Toggle sidebar');
  }
  logout() {
    this.auth.logout();
  }
}
FILE: frontend/src/app/shared/components/loading-spinner/loading-spinner.css
.spinner-container {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding: 40px;
  gap: 16px;
}
.spinner-container.fullscreen {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: rgba(10, 10, 10, 0.9);
  z-index: 9999;
}
.spinner {
  position: relative;
  width: 40px;
  height: 40px;
}
.spinner-ring {
  position: absolute;
  width: 100%;
  height: 100%;
  border: 3px solid transparent;
  border-top-color: var(--primary-orange);
  border-radius: 50%;
  animation: spin 1.2s cubic-bezier(0.5, 0, 0.5, 1) infinite;
}
.spinner-ring:nth-child(1) {
  animation-delay: -0.45s;
}
.spinner-ring:nth-child(2) {
  animation-delay: -0.3s;
  border-top-color: var(--primary-orange-light);
}
.spinner-ring:nth-child(3) {
  animation-delay: -0.15s;
  border-top-color: var(--primary-orange-dark);
}
.spinner-message {
  color: var(--text-secondary);
  font-size: 14px;
  margin: 0;
}
@keyframes spin {
  0% {
    transform: rotate(0deg);
  }
  100% {
    transform: rotate(360deg);
  }
}
FILE: frontend/src/app/shared/components/loading-spinner/loading-spinner.html
<div class="spinner-container" [class.fullscreen]="fullscreen()">
  <div class="spinner">
    <div class="spinner-ring"></div>
    <div class="spinner-ring"></div>
    <div class="spinner-ring"></div>
    <div class="spinner-ring"></div>
  </div>
  @if (message()) {
    <p class="spinner-message">{{ message() }}</p>
  }
</div>
FILE: frontend/src/app/shared/components/loading-spinner/loading-spinner.ts
import { Component, input } from '@angular/core';
import { CommonModule } from '@angular/common';
@Component({
  selector: 'app-loading-spinner',
  standalone: true,
  imports: [CommonModule],
  templateUrl: './loading-spinner.html',
  styleUrl: './loading-spinner.css'
})
export class LoadingSpinner {
  fullscreen = input<boolean>(false);
  message = input<string>('');
}
FILE: frontend/src/app/shared/components/sidebar/sidebar.css
.sidebar {
  position: fixed;
  left: 0;
  top: 48px;
  bottom: 0;
  width: 280px;
  background-color: var(--bg-secondary);
  border-right: 1px solid var(--border-primary);
  display: flex;
  flex-direction: column;
  overflow-y: auto;
  transition: transform 0.3s;
  z-index: 999;
}
.sidebar-nav {
  flex: 1;
  padding: 16px 12px;
}
.nav-section {
  margin-bottom: 24px;
}
.section-title {
  font-size: 10px;
  font-weight: 700;
  letter-spacing: 0.5px;
  color: var(--text-secondary);
  margin-bottom: 8px;
  padding: 0 12px;
}
.nav-item {
  display: flex;
  align-items: center;
  gap: 12px;
  padding: 10px 12px;
  color: var(--text-primary);
  text-decoration: none;
  border-radius: 4px;
  transition: all 0.2s;
  margin-bottom: 2px;
}
.nav-item:hover {
  background-color: var(--bg-hover);
  color: var(--primary-orange);
}
.nav-item.active {
  background-color: var(--bg-hover);
  color: var(--primary-orange);
  border-left: 3px solid var(--primary-orange);
}
.nav-item .material-icons {
  font-size: 20px;
}
.category-emoji {
  font-size: 20px;
  width: 20px;
  text-align: center;
}
.nav-text {
  font-size: 14px;
  font-weight: 500;
}
.sidebar-footer {
  padding: 16px;
  border-top: 1px solid var(--border-primary);
}
.create-post-btn {
  width: 100%;
  padding: 12px;
  background-color: var(--primary-orange);
  color: white;
  border: none;
  border-radius: 24px;
  font-family: 'JetBrains Mono', monospace;
  font-weight: 600;
  font-size: 14px;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 8px;
  transition: background-color 0.2s;
}
.create-post-btn:hover {
  background-color: var(--primary-orange-light);
}
@media (max-width: 960px) {
  .sidebar {
    transform: translateX(-100%);
  }
  .sidebar.open {
    transform: translateX(0);
  }
}
FILE: frontend/src/app/shared/components/sidebar/sidebar.html
<aside class="sidebar" [class.collapsed]="isCollapsed()">
  <nav class="sidebar-nav">
    <div class="nav-section">
      <h3 class="section-title">FEEDS</h3>
      <a routerLink="/feed" routerLinkActive="active" [routerLinkActiveOptions]="{ exact: true }" class="nav-item">
        <span class="material-icons">home</span>
        <span class="nav-text">Home</span>
      </a>
      <a routerLink="/feed/hot" routerLinkActive="active" class="nav-item">
        <span class="material-icons">whatshot</span>
        <span class="nav-text">Hot</span>
      </a>
      <a routerLink="/feed/new" routerLinkActive="active" class="nav-item">
        <span class="material-icons">new_releases</span>
        <span class="nav-text">New</span>
      </a>
      <a routerLink="/feed/top" routerLinkActive="active" class="nav-item">
        <span class="material-icons">trending_up</span>
        <span class="nav-text">Top</span>
      </a>


      @if (isAuthenticated()) {
        <a routerLink="/saved" routerLinkActive="active" class="nav-item">
          <span class="material-icons">bookmark</span>
          <span class="nav-text">Saved</span>
        </a>
      }
    </div>

    <div class="nav-section">
      <h3 class="section-title">CATEGORIES</h3>
      @for (category of categories(); track category.id) {
        <a [routerLink]="['/category', category.slug]" routerLinkActive="active" class="nav-item">
          <span class="category-emoji">{{ category.emoji }}</span>
          <span class="nav-text">{{ category.name }}</span>
        </a>
      }
    </div>
  </nav>

  <div class="sidebar-footer">
    <button class="create-post-btn" routerLink="/create-post">
      <span class="material-icons">add</span>
      <span>Create Post</span>
    </button>
  </div>
</aside>
FILE: frontend/src/app/shared/components/sidebar/sidebar.ts
import { ChangeDetectionStrategy, Component, inject, signal } from '@angular/core';
import { CommonModule } from '@angular/common';
import { RouterLink, RouterLinkActive } from '@angular/router';
import { Auth } from '../../../core/services/auth';
import { CATEGORIES } from '../../../core/constants/categories';
@Component({
  selector: 'app-sidebar',
  standalone: true,
  imports: [CommonModule, RouterLink, RouterLinkActive],
  templateUrl: './sidebar.html',
  styleUrls: ['./sidebar.css'],
  changeDetection: ChangeDetectionStrategy.OnPush,
})
export class Sidebar {
  private readonly auth = inject(Auth);
  readonly categories = signal(CATEGORIES);
  readonly isAuthenticated = this.auth.isAuthenticated;
  readonly isCollapsed = signal(false);
}
FILE: frontend/src/app/shared/components/user-avatar/user-avatar.css
.avatar {
  position: relative;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  border-radius: 50%;
  overflow: hidden;
  background-color: var(--bg-tertiary);
  flex-shrink: 0;
}
.avatar.clickable {
  cursor: pointer;
  transition: transform 0.2s;
}
.avatar.clickable:hover {
  transform: scale(1.05);
}
.avatar-image {
  width: 100%;
  height: 100%;
  object-fit: cover;
}
.avatar-fallback {
  width: 100%;
  height: 100%;
  display: flex;
  align-items: center;
  justify-content: center;
  font-weight: 600;
  color: white;
  font-size: calc(var(--size) * 0.4);
  text-transform: uppercase;
}
.online-indicator {
  position: absolute;
  bottom: 0;
  right: 0;
  width: 25%;
  height: 25%;
  background-color: var(--success);
  border: 2px solid var(--bg-secondary);
  border-radius: 50%;
}
FILE: frontend/src/app/shared/components/user-avatar/user-avatar.html
<div
  class="avatar"
  [style.width.px]="size()"
  [style.height.px]="size()"
  [class.clickable]="clickable()"
  (click)="handleClick()"
>
  @if (imageUrl()) {
    <img [src]="imageUrl()" [alt]="username() || 'User avatar'" class="avatar-image">
  } @else {
    <div class="avatar-fallback" [style.background-color]="getAvatarColor()">
      {{ getInitials() }}
    </div>
  }

  @if (showOnlineStatus() && isOnline()) {
    <span class="online-indicator"></span>
  }
</div>
FILE: frontend/src/app/shared/components/user-avatar/user-avatar.ts
import { Component, input, output } from '@angular/core';
import { CommonModule } from '@angular/common';
@Component({
  selector: 'app-user-avatar',
  standalone: true,
  imports: [CommonModule],
  templateUrl: './user-avatar.html',
  styleUrl: './user-avatar.css'
})
export class UserAvatar {
  size = input<number>(40);
  username = input<string>('');
  imageUrl = input<string>('');
  showOnlineStatus = input<boolean>(false);
  isOnline = input<boolean>(false);
  clickable = input<boolean>(false);
  click = output<void>();
  handleClick() {
    if (this.clickable()) {
      this.click.emit();
    }
  }
  getInitials(): string {
    const name = this.username();
    if (!name) return '?';
    const parts = name.split(' ');
    if (parts.length >= 2) {
      return parts[0][0] + parts[1][0];
    }
    return name.substring(0, 2);
  }
  getAvatarColor(): string {
    const colors = [
      '#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4',
      '#FFEAA7', '#DDA0DD', '#98D8C8', '#FFB6C1'
    ];
    const name = this.username();
    if (!name) return colors[0];
    let hash = 0;
    for (let i = 0; i < name.length; i++) {
      hash = name.charCodeAt(i) + ((hash << 5) - hash);
    }
    return colors[Math.abs(hash) % colors.length];
  }
}
FILE: frontend/src/app/shared/components/vote-buttons/vote-buttons.css
.vote-container {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 4px;
  min-width: 40px;
}
.vote-btn {
  background: none;
  border: none;
  color: var(--text-secondary);
  cursor: pointer;
  padding: 4px;
  border-radius: 4px;
  transition: all 0.2s;
  display: flex;
  align-items: center;
  justify-content: center;
}
.vote-btn.disabled {
  opacity: 0.5;
  cursor: not-allowed;
}
.vote-btn:disabled {
  cursor: not-allowed;
}
.vote-count.loading {
  animation: pulse 1s infinite;
}
@keyframes pulse {
  0%, 100% {
    opacity: 1;
  }
  50% {
    opacity: 0.5;
  }
}
.vote-btn:hover {
  background-color: var(--bg-hover);
}
.vote-btn .material-icons {
  font-size: 20px;
}
.vote-btn.upvote.active {
  color: var(--upvote);
}
.vote-btn.downvote.active {
  color: var(--downvote);
}
.vote-count {
  font-size: 12px;
  font-weight: 700;
  color: var(--text-primary);
  min-width: 30px;
  text-align: center;
}
.vote-count.upvoted {
  color: var(--upvote);
}
.vote-count.downvoted {
  color: var(--downvote);
}
.vote-container.horizontal {
  flex-direction: row;
  gap: 8px;
}
.vote-container.horizontal .vote-btn .material-icons {
  font-size: 18px;
}
FILE: frontend/src/app/shared/components/vote-buttons/vote-buttons.html
<div class="vote-container" [class.horizontal]="orientation() === 'horizontal'">
  <button
    class="vote-btn upvote"
    [class.active]="userVote() === 'up'"
    [class.disabled]="disabled()"
    [disabled]="disabled()"
    (click)="handleVote($event, 'up')"
    [attr.aria-label]="'Upvote'"
  >
    <span class="material-icons">arrow_upward</span>
  </button>

  <span class="vote-count"
    [class.upvoted]="userVote() === 'up'"
    [class.downvoted]="userVote() === 'down'"
    [class.loading]="disabled()">
    {{ formatVoteCount(voteCount()) }}
  </span>

  <button
    class="vote-btn downvote"
    [class.active]="userVote() === 'down'"
    [class.disabled]="disabled()"
    [disabled]="disabled()"
    (click)="handleVote($event, 'down')"
    [attr.aria-label]="'Downvote'"
  >
    <span class="material-icons">arrow_downward</span>
  </button>
</div>
FILE: frontend/src/app/shared/components/vote-buttons/vote-buttons.ts
import { Component, input, output, computed } from '@angular/core';
import { CommonModule } from '@angular/common';
@Component({
  selector: 'app-vote-buttons',
  standalone: true,
  imports: [CommonModule],
  templateUrl: './vote-buttons.html',
  styleUrl: './vote-buttons.css'
})
export class VoteButtons {
  upvotes = input.required<number>();
  downvotes = input.required<number>();
  userVote = input<'up' | 'down' | null>(null);
  orientation = input<'vertical' | 'horizontal'>('vertical');
  disabled = input<boolean>(false);
  vote = output<'up' | 'down'>();
  voteCount = computed(() => {
    return this.upvotes() - this.downvotes();
  });
  handleVote(event: Event, voteType: 'up' | 'down') {
    event.stopPropagation();
    event.preventDefault();
    if (!this.disabled()) {
      this.vote.emit(voteType);
    }
  }
  formatVoteCount(count: number): string {
    if (count >= 1000000) {
      return (count / 1000000).toFixed(1) + 'M';
    } else if (count >= 1000) {
      return (count / 1000).toFixed(1) + 'k';
    }
    return count.toString();
  }
}
FILE: frontend/src/custom-theme.scss
// custom components at https://material.angular.dev/guide/theming
@use '@angular/material' as mat;
html {
  @include mat.theme((
    color: (
      primary: mat.$azure-palette,
      tertiary: mat.$blue-palette,
    ),
    typography: Roboto,
    density: 0,
  ));
}
body {
  color-scheme: light;
  // variables at https://material.angular.dev/guide/system-variables
  background-color: var(--mat-sys-surface);
  color: var(--mat-sys-on-surface);
  font: var(--mat-sys-body-medium);
  margin: 0;
}
FILE: frontend/src/index.html
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>MemeForum</title>
  <base href="/">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="icon" type="image/x-icon" href="favicon.ico">
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;500;600;700&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
</head>
<body>
  <app-root></app-root>
</body>
</html>
FILE: frontend/src/main.ts
import 'zone.js';
import { bootstrapApplication } from '@angular/platform-browser';
import { appConfig } from './app/app.config';
import { App } from './app/app';
bootstrapApplication(App, appConfig)
  .catch((err) => console.error(err));
FILE: frontend/src/styles.css
@import url('https://fonts.googleapis.com/icon?family=Material+Icons');
@import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;500;700&display=swap');
:root {
  --primary-orange: #ff4500;
  --primary-orange-light: #ff6b4a;
  --primary-orange-dark: #cc3700;
  --bg-primary: #0a0a0a;
  --bg-secondary: #1a1a1b;
  --bg-tertiary: #272729;
  --bg-hover: #343536;
  --text-primary: #d7dadc;
  --text-secondary: #818384;
  --text-muted: #565758;
  --border-primary: #343536;
  --border-secondary: #474748;
  --primary-orange-light: #ff6b4a;
  --primary-orange-dark: #cc3700;
  --upvote: #ff4500;
  --downvote: #7193ff;
  --success: #46d160;
  --error: #ea0027;
  --warning: #ffd635;
}
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}
html, body {
  height: 100%;
  font-family: 'JetBrains Mono', monospace;
  background-color: var(--bg-primary);
  color: var(--text-primary);
  font-size: 14px;
  line-height: 1.6;
}
::-webkit-scrollbar {
  width: 8px;
  height: 8px;
}
::-webkit-scrollbar-track {
  background: var(--bg-secondary);
}
::-webkit-scrollbar-thumb {
  background: var(--border-secondary);
  border-radius: 4px;
}
::-webkit-scrollbar-thumb:hover {
  background: var(--text-muted);
}
.mat-mdc-button.mat-primary {
  --mdc-filled-button-container-color: var(--primary-orange);
}
.mat-mdc-raised-button.mat-primary {
  --mdc-protected-button-container-color: var(--primary-orange);
}
FILE: frontend/tsconfig.app.json
/* To learn more about Typescript configuration file: https://www.typescriptlang.org/docs/handbook/tsconfig-json.html. */
/* To learn more about Angular compiler options: https://angular.dev/reference/configs/angular-compiler-options. */
{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "outDir": "./out-tsc/app",
    "types": []
  },
  "include": [
    "src/**/*.ts"
  ],
  "exclude": [
    "src/**/*.spec.ts"
  ]
}
FILE: frontend/tsconfig.json
/* To learn more about Typescript configuration file: https://www.typescriptlang.org/docs/handbook/tsconfig-json.html. */
/* To learn more about Angular compiler options: https://angular.dev/reference/configs/angular-compiler-options. */
{
  "compileOnSave": false,
  "compilerOptions": {
    "strict": true,
    "noImplicitOverride": true,
    "noPropertyAccessFromIndexSignature": true,
    "noImplicitReturns": true,
    "noFallthroughCasesInSwitch": true,
    "skipLibCheck": true,
    "isolatedModules": true,
    "experimentalDecorators": true,
    "importHelpers": true,
    "target": "ES2022",
    "module": "preserve"
  },
  "angularCompilerOptions": {
    "enableI18nLegacyMessageIdFormat": false,
    "strictInjectionParameters": true,
    "strictInputAccessModifiers": true,
    "strictTemplates": true
  },
  "files": [],
  "references": [
    {
      "path": "./tsconfig.app.json"
    },
    {
      "path": "./tsconfig.spec.json"
    }
  ]
}
FILE: frontend/tsconfig.spec.json
/* To learn more about Typescript configuration file: https://www.typescriptlang.org/docs/handbook/tsconfig-json.html. */
/* To learn more about Angular compiler options: https://angular.dev/reference/configs/angular-compiler-options. */
{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "outDir": "./out-tsc/spec",
    "types": [
      "vitest/globals"
    ]
  },
  "include": [
    "src/**/*.d.ts",
    "src/**/*.spec.ts"
  ]
}
FILE: redis-cache/docker-compose.yml
services:
  redis:
    image: redis:7-alpine
    container_name: meme_forum_redis
    restart: unless-stopped
    command: redis-server /usr/local/etc/redis/redis.conf
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data
      - ./redis.conf:/usr/local/etc/redis/redis.conf
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 3s
      retries: 5
    networks:
      - meme_network

  # Optional: Redis Commander for management
  redis-commander:
    image: rediscommander/redis-commander:latest
    container_name: meme_forum_redis_commander
    restart: unless-stopped
    environment:
      REDIS_HOSTS: local:redis:6379
    ports:
      - "8081:8081"
    depends_on:
      - redis
    networks:
      - meme_network

volumes:
  redis_data:
    driver: local

networks:
  meme_network:
    driver: bridge
SUMMARY
Total files: 158
Original size: 281,424 chars
Processed size: 269,690 chars
Reduction: 4.2%

File types:
 .ts: 54
 .py: 42
 .css: 26
 .html: 26
 .json: 4
 .yml: 3
 .example: 1
 [no extension]: 1
 .scss: 1
