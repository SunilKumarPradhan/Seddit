DIRECTORY TREE
ðŸ“ backend/
â”‚ ðŸ“„ .env.example
â”‚ ðŸ“„ Dockerfile
â”‚ âš™ï¸ firebase-service-account.json
â”‚ ðŸ“„ main.py
â”‚ ðŸ“„ seed.py
â”‚ ðŸ“ alembic/
â”‚ â”‚ ðŸ“„ README
â”‚ â”‚ ðŸ“„ env.py
â”‚ â”‚ ðŸ“ versions/
â”‚ â”‚ â”‚ ðŸ“„ 20251130_allow_long_image_url.py
â”‚ â”‚ â”‚ ðŸ“„ 382b9ef7d182_initial_schema.py
â”‚ â”‚ â”‚ ðŸ“„ a8007ce4c758_add_rbac_fields.py
â”‚ ðŸ“ app/
â”‚ â”‚ ðŸ“„ config.py
â”‚ â”‚ ðŸ“„ database.py
â”‚ â”‚ ðŸ“„ dependencies.py
â”‚ â”‚ ðŸ“„ main.py
â”‚ â”‚ ðŸ“ api/
â”‚ â”‚ â”‚ ðŸ“ v1/
â”‚ â”‚ â”‚ â”‚ ðŸ“„ __init__.py
â”‚ â”‚ â”‚ â”‚ ðŸ“„ admin.py
â”‚ â”‚ â”‚ â”‚ ðŸ“„ auth.py
â”‚ â”‚ â”‚ â”‚ ðŸ“„ comments.py
â”‚ â”‚ â”‚ â”‚ ðŸ“„ posts.py
â”‚ â”‚ â”‚ â”‚ ðŸ“„ users.py
â”‚ â”‚ â”‚ â”‚ ðŸ“„ websocket.py
â”‚ â”‚ ðŸ“ core/
â”‚ â”‚ â”‚ ðŸ“„ firebase_auth.py
â”‚ â”‚ â”‚ ðŸ“„ permissions.py
â”‚ â”‚ â”‚ ðŸ“„ redis_client.py
â”‚ â”‚ â”‚ ðŸ“„ security.py
â”‚ â”‚ ðŸ“ middleware/
â”‚ â”‚ â”‚ ðŸ“„ logging.py
â”‚ â”‚ â”‚ ðŸ“„ rate_limit.py
â”‚ â”‚ ðŸ“ models/
â”‚ â”‚ â”‚ ðŸ“„ comment.py
â”‚ â”‚ â”‚ ðŸ“„ notification.py
â”‚ â”‚ â”‚ ðŸ“„ post.py
â”‚ â”‚ â”‚ ðŸ“„ role.py
â”‚ â”‚ â”‚ ðŸ“„ user.py
â”‚ â”‚ ðŸ“ repositories/
â”‚ â”‚ â”‚ ðŸ“„ comment_repository.py
â”‚ â”‚ â”‚ ðŸ“„ post_repository.py
â”‚ â”‚ â”‚ ðŸ“„ user_repository.py
â”‚ â”‚ ðŸ“ schemas/
â”‚ â”‚ â”‚ ðŸ“„ __init__.py
â”‚ â”‚ â”‚ ðŸ“„ admin.py
â”‚ â”‚ â”‚ ðŸ“„ auth.py
â”‚ â”‚ â”‚ ðŸ“„ comment.py
â”‚ â”‚ â”‚ ðŸ“„ notification.py
â”‚ â”‚ â”‚ ðŸ“„ post.py
â”‚ â”‚ â”‚ ðŸ“„ user.py
â”‚ â”‚ ðŸ“ services/
â”‚ â”‚ â”‚ ðŸ“„ admin_service.py
â”‚ â”‚ â”‚ ðŸ“„ auth_service.py
â”‚ â”‚ â”‚ ðŸ“„ comment_service.py
â”‚ â”‚ â”‚ ðŸ“„ notification_service.py
â”‚ â”‚ â”‚ ðŸ“„ notification_stream.py
â”‚ â”‚ â”‚ ðŸ“„ post_service.py
â”‚ â”‚ â”‚ ðŸ“„ websocket_service.py
â”‚ â”‚ ðŸ“ utils/
â”‚ â”‚ â”‚ ðŸ“„ logger.py
â”‚ ðŸ“ logs/
â”‚ ðŸ“ migrations/
FILE CONTENTS
FILE: .env.example
# Application
APP_NAME=MemeForum
APP_VERSION=1.0.0
DEBUG=True
ENVIRONMENT=development

# Server
HOST=0.0.0.0
PORT=8000

# Database
DATABASE_URL=postgresql://meme_user:meme_pass@localhost:5432/meme_forum
DB_ECHO=False

# Redis
REDIS_HOST=localhost
REDIS_PORT=6379
REDIS_DB=0
REDIS_PASSWORD=

# Firebase
FIREBASE_CREDENTIALS_PATH=./firebase-credentials.json
FIREBASE_PROJECT_ID=your-project-id

# Security
SECRET_KEY=your-super-secret-key-change-this-in-production
ALGORITHM=HS256
ACCESS_TOKEN_EXPIRE_MINUTES=30

# CORS
CORS_ORIGINS=["http://localhost:4200","http://localhost:80"]

# File Upload
MAX_FILE_SIZE=10485760  # 10MB in bytes
ALLOWED_FILE_TYPES=["image/jpeg","image/png","image/gif","image/webp"]
UPLOAD_DIR=./uploads

# Rate Limiting
RATE_LIMIT_PER_MINUTE=60

# Logging
LOG_LEVEL=INFO
LOG_FILE=logs/app.log
FILE: Dockerfile
FROM python:3.11-slim

WORKDIR /app

# System deps (for psycopg2 etc.)
RUN apt-get update && apt-get install -y gcc libpq-dev && rm -rf /var/lib/apt/lists/*

# Install requirements
COPY requirements.txt ./
RUN pip install --upgrade pip && pip install -r requirements.txt

# Copy all project files
COPY . .

# Expose port
EXPOSE 8000

# ---- THIS IS THE IMPORTANT LINE ----
CMD ["uvicorn", "app.main:app", "--reload", "--host", "0.0.0.0", "--port", "8000"]
FILE: alembic/README
Generic single-database configuration.
FILE: alembic/env.py
from logging.config import fileConfig
from sqlalchemy import engine_from_config, pool
from alembic import context
import sys
from pathlib import Path

sys.path.insert(0, str(Path(__file__).resolve().parent.parent))

from app.config import settings
from app.database import Base
from app.models import user, role, post, comment, notification

config = context.config

config.set_main_option("sqlalchemy.url", settings.DATABASE_URL)

if config.config_file_name is not None:
    fileConfig(config.config_file_name)

target_metadata = Base.metadata

def run_migrations_offline() -> None:
    """Run migrations in 'offline' mode."""
    url = config.get_main_option("sqlalchemy.url")
    context.configure(
        url=url,
        target_metadata=target_metadata,
        literal_binds=True,
        dialect_opts={"paramstyle": "named"},
    )

    with context.begin_transaction():
        context.run_migrations()

def run_migrations_online() -> None:
    """Run migrations in 'online' mode."""
    connectable = engine_from_config(
        config.get_section(config.config_ini_section, {}),
        prefix="sqlalchemy.",
        poolclass=pool.NullPool,
    )

    with connectable.connect() as connection:
        context.configure(
            connection=connection,
            target_metadata=target_metadata
        )

        with context.begin_transaction():
            context.run_migrations()

if context.is_offline_mode():
    run_migrations_offline()
else:
    run_migrations_online()
FILE: alembic/versions/20251130_allow_long_image_url.py
"""allow long image data for posts

Revision ID: 7d82d4f9f341
Revises: 382b9ef7d182
Create Date: 2025-11-30 15:25:00.000000
"""
from alembic import op
import sqlalchemy as sa

revision = "7d82d4f9f341"
down_revision = "382b9ef7d182"
branch_labels = None
depends_on = None

def upgrade() -> None:
    op.alter_column("posts", "image_url", type_=sa.Text(), existing_nullable=True)

def downgrade() -> None:
    op.alter_column("posts", "image_url", type_=sa.String(length=500), existing_nullable=True)
FILE: alembic/versions/382b9ef7d182_initial_schema.py
"""initial schema

Revision ID: 382b9ef7d182
Revises:
Create Date: 2025-11-28 09:59:03.206082

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa

revision: str = '382b9ef7d182'
down_revision: Union[str, Sequence[str], None] = None
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None

def upgrade() -> None:
    """Upgrade schema."""
    op.create_table('roles',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('name', sa.String(length=50), nullable=False),
    sa.Column('permissions', sa.JSON(), nullable=False),
    sa.PrimaryKeyConstraint('id'),
    sa.UniqueConstraint('name')
    )
    op.create_index(op.f('ix_roles_id'), 'roles', ['id'], unique=False)
    op.create_table('users',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('firebase_uid', sa.String(length=128), nullable=False),
    sa.Column('email', sa.String(length=255), nullable=False),
    sa.Column('username', sa.String(length=50), nullable=False),
    sa.Column('avatar_url', sa.String(length=500), nullable=True),
    sa.Column('bio', sa.String(length=500), nullable=True),
    sa.Column('role_id', sa.Integer(), nullable=False),
    sa.Column('is_active', sa.Boolean(), nullable=False),
    sa.Column('is_banned', sa.Boolean(), nullable=False),
    sa.Column('created_at', sa.DateTime(timezone=True), server_default=sa.text('now()'), nullable=False),
    sa.Column('updated_at', sa.DateTime(timezone=True), nullable=True),
    sa.ForeignKeyConstraint(['role_id'], ['roles.id'], ),
    sa.PrimaryKeyConstraint('id')
    )
    op.create_index(op.f('ix_users_email'), 'users', ['email'], unique=True)
    op.create_index(op.f('ix_users_firebase_uid'), 'users', ['firebase_uid'], unique=True)
    op.create_index(op.f('ix_users_id'), 'users', ['id'], unique=False)
    op.create_index(op.f('ix_users_username'), 'users', ['username'], unique=True)
    op.create_table('notifications',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('user_id', sa.Integer(), nullable=False),
    sa.Column('type', sa.String(length=50), nullable=False),
    sa.Column('message', sa.Text(), nullable=False),
    sa.Column('link', sa.String(length=500), nullable=True),
    sa.Column('is_read', sa.Boolean(), nullable=False),
    sa.Column('created_at', sa.DateTime(timezone=True), server_default=sa.text('now()'), nullable=False),
    sa.ForeignKeyConstraint(['user_id'], ['users.id'], ondelete='CASCADE'),
    sa.PrimaryKeyConstraint('id')
    )
    op.create_index(op.f('ix_notifications_created_at'), 'notifications', ['created_at'], unique=False)
    op.create_index(op.f('ix_notifications_id'), 'notifications', ['id'], unique=False)
    op.create_index(op.f('ix_notifications_is_read'), 'notifications', ['is_read'], unique=False)
    op.create_index(op.f('ix_notifications_user_id'), 'notifications', ['user_id'], unique=False)
    op.create_table('posts',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('user_id', sa.Integer(), nullable=False),
    sa.Column('title', sa.String(length=300), nullable=False),
    sa.Column('image_url', sa.String(length=500), nullable=True),
    sa.Column('tag', sa.String(length=50), nullable=True),
    sa.Column('description', sa.Text(), nullable=True),
    sa.Column('upvotes', sa.Integer(), nullable=False),
    sa.Column('downvotes', sa.Integer(), nullable=False),
    sa.Column('is_locked', sa.Boolean(), nullable=False),
    sa.Column('is_deleted', sa.Boolean(), nullable=False),
    sa.Column('created_at', sa.DateTime(timezone=True), server_default=sa.text('now()'), nullable=False),
    sa.Column('updated_at', sa.DateTime(timezone=True), nullable=True),
    sa.ForeignKeyConstraint(['user_id'], ['users.id'], ondelete='CASCADE'),
    sa.PrimaryKeyConstraint('id')
    )
    op.create_index(op.f('ix_posts_created_at'), 'posts', ['created_at'], unique=False)
    op.create_index(op.f('ix_posts_id'), 'posts', ['id'], unique=False)
    op.create_index(op.f('ix_posts_tag'), 'posts', ['tag'], unique=False)
    op.create_table('comments',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('post_id', sa.Integer(), nullable=False),
    sa.Column('user_id', sa.Integer(), nullable=False),
    sa.Column('parent_id', sa.Integer(), nullable=True),
    sa.Column('content', sa.Text(), nullable=False),
    sa.Column('upvotes', sa.Integer(), nullable=False),
    sa.Column('downvotes', sa.Integer(), nullable=False),
    sa.Column('is_deleted', sa.Boolean(), nullable=False),
    sa.Column('created_at', sa.DateTime(timezone=True), server_default=sa.text('now()'), nullable=False),
    sa.Column('updated_at', sa.DateTime(timezone=True), nullable=True),
    sa.ForeignKeyConstraint(['parent_id'], ['comments.id'], ondelete='CASCADE'),
    sa.ForeignKeyConstraint(['post_id'], ['posts.id'], ondelete='CASCADE'),
    sa.ForeignKeyConstraint(['user_id'], ['users.id'], ondelete='CASCADE'),
    sa.PrimaryKeyConstraint('id')
    )
    op.create_index(op.f('ix_comments_created_at'), 'comments', ['created_at'], unique=False)
    op.create_index(op.f('ix_comments_id'), 'comments', ['id'], unique=False)
    op.create_index(op.f('ix_comments_parent_id'), 'comments', ['parent_id'], unique=False)
    op.create_index(op.f('ix_comments_post_id'), 'comments', ['post_id'], unique=False)
    op.create_table('favorites',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('user_id', sa.Integer(), nullable=False),
    sa.Column('post_id', sa.Integer(), nullable=False),
    sa.Column('created_at', sa.DateTime(timezone=True), server_default=sa.text('now()'), nullable=False),
    sa.ForeignKeyConstraint(['post_id'], ['posts.id'], ondelete='CASCADE'),
    sa.ForeignKeyConstraint(['user_id'], ['users.id'], ondelete='CASCADE'),
    sa.PrimaryKeyConstraint('id')
    )
    op.create_index(op.f('ix_favorites_id'), 'favorites', ['id'], unique=False)
    op.create_table('votes',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('user_id', sa.Integer(), nullable=False),
    sa.Column('post_id', sa.Integer(), nullable=True),
    sa.Column('comment_id', sa.Integer(), nullable=True),
    sa.Column('vote_type', sa.String(length=10), nullable=False),
    sa.Column('created_at', sa.DateTime(timezone=True), server_default=sa.text('now()'), nullable=False),
    sa.ForeignKeyConstraint(['comment_id'], ['comments.id'], ondelete='CASCADE'),
    sa.ForeignKeyConstraint(['post_id'], ['posts.id'], ondelete='CASCADE'),
    sa.ForeignKeyConstraint(['user_id'], ['users.id'], ondelete='CASCADE'),
    sa.PrimaryKeyConstraint('id')
    )
    op.create_index(op.f('ix_votes_id'), 'votes', ['id'], unique=False)

def downgrade() -> None:
    """Downgrade schema."""
    op.drop_index(op.f('ix_votes_id'), table_name='votes')
    op.drop_table('votes')
    op.drop_index(op.f('ix_favorites_id'), table_name='favorites')
    op.drop_table('favorites')
    op.drop_index(op.f('ix_comments_post_id'), table_name='comments')
    op.drop_index(op.f('ix_comments_parent_id'), table_name='comments')
    op.drop_index(op.f('ix_comments_id'), table_name='comments')
    op.drop_index(op.f('ix_comments_created_at'), table_name='comments')
    op.drop_table('comments')
    op.drop_index(op.f('ix_posts_tag'), table_name='posts')
    op.drop_index(op.f('ix_posts_id'), table_name='posts')
    op.drop_index(op.f('ix_posts_created_at'), table_name='posts')
    op.drop_table('posts')
    op.drop_index(op.f('ix_notifications_user_id'), table_name='notifications')
    op.drop_index(op.f('ix_notifications_is_read'), table_name='notifications')
    op.drop_index(op.f('ix_notifications_id'), table_name='notifications')
    op.drop_index(op.f('ix_notifications_created_at'), table_name='notifications')
    op.drop_table('notifications')
    op.drop_index(op.f('ix_users_username'), table_name='users')
    op.drop_index(op.f('ix_users_id'), table_name='users')
    op.drop_index(op.f('ix_users_firebase_uid'), table_name='users')
    op.drop_index(op.f('ix_users_email'), table_name='users')
    op.drop_table('users')
    op.drop_index(op.f('ix_roles_id'), table_name='roles')
    op.drop_table('roles')
FILE: alembic/versions/a8007ce4c758_add_rbac_fields.py
"""add_rbac_fields

Revision ID: a8007ce4c758
Revises: 7d82d4f9f341
Create Date: 2025-12-04 09:41:34.520665

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa
from sqlalchemy.dialects import postgresql

revision: str = 'a8007ce4c758'
down_revision: Union[str, Sequence[str], None] = '7d82d4f9f341'
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None

def upgrade() -> None:
    """Upgrade schema."""
    op.alter_column('favorites', 'created_at',
               existing_type=postgresql.TIMESTAMP(timezone=True),
               type_=sa.DateTime(),
               nullable=True,
               existing_server_default=sa.text('now()'))
    op.add_column('posts', sa.Column('comment_count', sa.Integer(), nullable=True))
    op.add_column('posts', sa.Column('lock_reason', sa.String(length=500), nullable=True))
    op.add_column('posts', sa.Column('locked_at', sa.DateTime(), nullable=True))
    op.add_column('posts', sa.Column('deleted_at', sa.DateTime(), nullable=True))
    op.alter_column('posts', 'upvotes',
               existing_type=sa.INTEGER(),
               nullable=True)
    op.alter_column('posts', 'downvotes',
               existing_type=sa.INTEGER(),
               nullable=True)
    op.alter_column('posts', 'is_locked',
               existing_type=sa.BOOLEAN(),
               nullable=True)
    op.alter_column('posts', 'is_deleted',
               existing_type=sa.BOOLEAN(),
               nullable=True)
    op.alter_column('posts', 'created_at',
               existing_type=postgresql.TIMESTAMP(timezone=True),
               type_=sa.DateTime(),
               nullable=True,
               existing_server_default=sa.text('now()'))
    op.alter_column('posts', 'updated_at',
               existing_type=postgresql.TIMESTAMP(timezone=True),
               type_=sa.DateTime(),
               existing_nullable=True)
    op.add_column('users', sa.Column('ban_reason', sa.String(length=500), nullable=True))
    op.add_column('users', sa.Column('banned_at', sa.DateTime(), nullable=True))
    op.add_column('users', sa.Column('banned_by_id', sa.Integer(), nullable=True))
    op.alter_column('users', 'firebase_uid',
               existing_type=sa.VARCHAR(length=128),
               nullable=True)
    op.alter_column('users', 'bio',
               existing_type=sa.VARCHAR(length=500),
               type_=sa.Text(),
               existing_nullable=True)
    op.alter_column('users', 'role_id',
               existing_type=sa.INTEGER(),
               nullable=True)
    op.alter_column('users', 'is_active',
               existing_type=sa.BOOLEAN(),
               nullable=True)
    op.alter_column('users', 'is_banned',
               existing_type=sa.BOOLEAN(),
               nullable=True)
    op.alter_column('users', 'created_at',
               existing_type=postgresql.TIMESTAMP(timezone=True),
               type_=sa.DateTime(),
               nullable=True,
               existing_server_default=sa.text('now()'))
    op.alter_column('users', 'updated_at',
               existing_type=postgresql.TIMESTAMP(timezone=True),
               type_=sa.DateTime(),
               existing_nullable=True)
    op.create_foreign_key(None, 'users', 'users', ['banned_by_id'], ['id'])
    op.alter_column('votes', 'created_at',
               existing_type=postgresql.TIMESTAMP(timezone=True),
               type_=sa.DateTime(),
               nullable=True,
               existing_server_default=sa.text('now()'))

def downgrade() -> None:
    """Downgrade schema."""
    op.alter_column('votes', 'created_at',
               existing_type=sa.DateTime(),
               type_=postgresql.TIMESTAMP(timezone=True),
               nullable=False,
               existing_server_default=sa.text('now()'))
    op.drop_constraint(None, 'users', type_='foreignkey')
    op.alter_column('users', 'updated_at',
               existing_type=sa.DateTime(),
               type_=postgresql.TIMESTAMP(timezone=True),
               existing_nullable=True)
    op.alter_column('users', 'created_at',
               existing_type=sa.DateTime(),
               type_=postgresql.TIMESTAMP(timezone=True),
               nullable=False,
               existing_server_default=sa.text('now()'))
    op.alter_column('users', 'is_banned',
               existing_type=sa.BOOLEAN(),
               nullable=False)
    op.alter_column('users', 'is_active',
               existing_type=sa.BOOLEAN(),
               nullable=False)
    op.alter_column('users', 'role_id',
               existing_type=sa.INTEGER(),
               nullable=False)
    op.alter_column('users', 'bio',
               existing_type=sa.Text(),
               type_=sa.VARCHAR(length=500),
               existing_nullable=True)
    op.alter_column('users', 'firebase_uid',
               existing_type=sa.VARCHAR(length=128),
               nullable=False)
    op.drop_column('users', 'banned_by_id')
    op.drop_column('users', 'banned_at')
    op.drop_column('users', 'ban_reason')
    op.alter_column('posts', 'updated_at',
               existing_type=sa.DateTime(),
               type_=postgresql.TIMESTAMP(timezone=True),
               existing_nullable=True)
    op.alter_column('posts', 'created_at',
               existing_type=sa.DateTime(),
               type_=postgresql.TIMESTAMP(timezone=True),
               nullable=False,
               existing_server_default=sa.text('now()'))
    op.alter_column('posts', 'is_deleted',
               existing_type=sa.BOOLEAN(),
               nullable=False)
    op.alter_column('posts', 'is_locked',
               existing_type=sa.BOOLEAN(),
               nullable=False)
    op.alter_column('posts', 'downvotes',
               existing_type=sa.INTEGER(),
               nullable=False)
    op.alter_column('posts', 'upvotes',
               existing_type=sa.INTEGER(),
               nullable=False)
    op.drop_column('posts', 'deleted_at')
    op.drop_column('posts', 'locked_at')
    op.drop_column('posts', 'lock_reason')
    op.drop_column('posts', 'comment_count')
    op.alter_column('favorites', 'created_at',
               existing_type=sa.DateTime(),
               type_=postgresql.TIMESTAMP(timezone=True),
               nullable=False,
               existing_server_default=sa.text('now()'))
FILE: app/api/v1/__init__.py
from fastapi import APIRouter
from app.api.v1 import auth, posts, comments, users, websocket, admin

api_router = APIRouter()

api_router.include_router(auth.router)
api_router.include_router(posts.router)
api_router.include_router(comments.router)
api_router.include_router(users.router)
api_router.include_router(websocket.router)
api_router.include_router(admin.router)
FILE: app/api/v1/admin.py
from fastapi import APIRouter, Depends, HTTPException, status, Query
from sqlalchemy.orm import Session
from typing import Optional

from app.database import get_db
from app.dependencies import get_current_user
from app.core.permissions import (
    get_admin_user, get_moderator_user,
    Permissions, has_permission, is_admin, ROLE_PERMISSIONS, get_user_role
)
from app.models.user import User
from app.services.admin_service import AdminService
from app.schemas.admin import (
    UserListResponse, UserListItem, UserDetailResponse,
    BanUserRequest, ChangeRoleRequest, ActionResponse,
    PostAdminListResponse, PostAdminListItem, LockPostRequest,
    CommentAdminListResponse, CommentAdminListItem,
    DashboardResponse, RoleListResponse
)

router = APIRouter(prefix="/admin", tags=["admin"])

@router.get("/me/permissions")
async def get_my_permissions(
    current_user: User = Depends(get_current_user)
):
    """Get current user's role and permissions."""
    role = get_user_role(current_user)
    permissions = ROLE_PERMISSIONS.get(role, [])

    return {
        "user_id": current_user.id,
        "username": current_user.username,
        "role": role,
        "permissions": permissions,
        "is_admin": role == "admin",
        "is_moderator": role in ["admin", "moderator"]
    }

@router.get("/dashboard", response_model=DashboardResponse)
async def get_dashboard(
    current_user: User = Depends(get_admin_user),
    db: Session = Depends(get_db)
):
    """Get admin dashboard data."""
    service = AdminService(db)
    stats = service.get_dashboard_stats()
    activity = service.get_recent_activity()

    return DashboardResponse(stats=stats, recent_activity=activity)

@router.get("/users", response_model=UserListResponse)
async def get_users(
    page: int = Query(1, ge=1),
    page_size: int = Query(20, ge=1, le=100),
    search: Optional[str] = None,
    role: Optional[str] = None,
    status: Optional[str] = None,
    sort_by: str = "created_at",
    sort_order: str = "desc",
    current_user: User = Depends(get_admin_user),
    db: Session = Depends(get_db)
):
    """Get paginated list of users (Admin only)."""
    service = AdminService(db)
    users, total = service.get_users(
        page=page,
        page_size=page_size,
        search=search,
        role_filter=role,
        status_filter=status,
        sort_by=sort_by,
        sort_order=sort_order
    )

    user_items = []
    for user in users:
        post_count = len(user.posts) if hasattr(user, 'posts') and user.posts else 0
        comment_count = len(user.comments) if hasattr(user, 'comments') and user.comments else 0

        user_items.append(UserListItem(
            id=user.id,
            username=user.username,
            email=user.email,
            avatar_url=user.avatar_url,
            role=user.role.name if user.role else "user",
            is_active=user.is_active,
            is_banned=user.is_banned,
            created_at=user.created_at,
            post_count=post_count,
            comment_count=comment_count
        ))

    return UserListResponse(
        users=user_items,
        total=total,
        page=page,
        page_size=page_size,
        has_more=(page * page_size) < total
    )

@router.get("/users/{user_id}", response_model=UserDetailResponse)
async def get_user_detail(
    user_id: int,
    current_user: User = Depends(get_admin_user),
    db: Session = Depends(get_db)
):
    """Get detailed user information (Admin only)."""
    service = AdminService(db)
    user = service.get_user_detail(user_id)

    if not user:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="User not found"
        )

    post_count = len(user.posts) if hasattr(user, 'posts') and user.posts else 0
    comment_count = len(user.comments) if hasattr(user, 'comments') and user.comments else 0

    return UserDetailResponse(
        id=user.id,
        username=user.username,
        email=user.email,
        avatar_url=user.avatar_url,
        bio=user.bio,
        role=user.role.name if user.role else "user",
        is_active=user.is_active,
        is_banned=user.is_banned,
        ban_reason=getattr(user, 'ban_reason', None),
        created_at=user.created_at,
        updated_at=user.updated_at,
        post_count=post_count,
        comment_count=comment_count
    )

@router.post("/users/{user_id}/ban", response_model=ActionResponse)
async def ban_user(
    user_id: int,
    request: BanUserRequest,
    current_user: User = Depends(get_admin_user),
    db: Session = Depends(get_db)
):
    """Ban a user (Admin only)."""
    service = AdminService(db)

    try:
        user = service.ban_user(user_id, current_user.id, request.reason)
        if not user:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="User not found"
            )

        return ActionResponse(
            success=True,
            message=f"User {user.username} has been banned"
        )
    except ValueError as e:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=str(e)
        )

@router.post("/users/{user_id}/unban", response_model=ActionResponse)
async def unban_user(
    user_id: int,
    current_user: User = Depends(get_admin_user),
    db: Session = Depends(get_db)
):
    """Unban a user (Admin only)."""
    service = AdminService(db)
    user = service.unban_user(user_id)

    if not user:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="User not found"
        )

    return ActionResponse(
        success=True,
        message=f"User {user.username} has been unbanned"
    )

@router.post("/users/{user_id}/role", response_model=ActionResponse)
async def change_user_role(
    user_id: int,
    request: ChangeRoleRequest,
    current_user: User = Depends(get_admin_user),
    db: Session = Depends(get_db)
):
    """Change a user's role (Admin only)."""
    service = AdminService(db)

    try:
        user = service.change_user_role(user_id, request.role.value, current_user.id)
        if not user:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="User not found"
            )

        return ActionResponse(
            success=True,
            message=f"User {user.username} role changed to {request.role.value}"
        )
    except ValueError as e:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=str(e)
        )

@router.delete("/users/{user_id}", response_model=ActionResponse)
async def delete_user(
    user_id: int,
    current_user: User = Depends(get_admin_user),
    db: Session = Depends(get_db)
):
    """Delete a user (Admin only)."""
    service = AdminService(db)

    try:
        success = service.delete_user(user_id, current_user.id)
        if not success:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="User not found"
            )

        return ActionResponse(
            success=True,
            message="User has been deleted"
        )
    except ValueError as e:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=str(e)
        )

@router.get("/posts", response_model=PostAdminListResponse)
async def get_posts_admin(
    page: int = Query(1, ge=1),
    page_size: int = Query(20, ge=1, le=100),
    search: Optional[str] = None,
    status: Optional[str] = None,
    sort_by: str = "created_at",
    sort_order: str = "desc",
    current_user: User = Depends(get_moderator_user),
    db: Session = Depends(get_db)
):
    """Get paginated list of posts for moderation."""
    service = AdminService(db)
    posts, total = service.get_posts_admin(
        page=page,
        page_size=page_size,
        search=search,
        status_filter=status,
        sort_by=sort_by,
        sort_order=sort_order
    )

    post_items = []
    for post in posts:
        comment_count = post.comment_count if hasattr(post, 'comment_count') else 0
        post_items.append(PostAdminListItem(
            id=post.id,
            title=post.title,
            author_username=post.author.username if post.author else "Unknown",
            author_id=post.user_id,
            is_locked=post.is_locked,
            is_deleted=post.is_deleted,
            upvotes=post.upvotes,
            downvotes=post.downvotes,
            comment_count=comment_count,
            created_at=post.created_at,
            reports_count=0
        ))

    return PostAdminListResponse(
        posts=post_items,
        total=total,
        page=page,
        page_size=page_size,
        has_more=(page * page_size) < total
    )

@router.post("/posts/{post_id}/lock", response_model=ActionResponse)
async def lock_post(
    post_id: int,
    request: LockPostRequest,
    current_user: User = Depends(get_moderator_user),
    db: Session = Depends(get_db)
):
    """Lock a post to prevent new comments."""
    service = AdminService(db)
    post = service.lock_post(post_id, request.reason)

    if not post:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Post not found"
        )

    return ActionResponse(
        success=True,
        message=f"Post '{post.title}' has been locked"
    )

@router.post("/posts/{post_id}/unlock", response_model=ActionResponse)
async def unlock_post(
    post_id: int,
    current_user: User = Depends(get_moderator_user),
    db: Session = Depends(get_db)
):
    """Unlock a post."""
    service = AdminService(db)
    post = service.unlock_post(post_id)

    if not post:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Post not found"
        )

    return ActionResponse(
        success=True,
        message=f"Post '{post.title}' has been unlocked"
    )

@router.delete("/posts/{post_id}", response_model=ActionResponse)
async def delete_post_admin(
    post_id: int,
    current_user: User = Depends(get_moderator_user),
    db: Session = Depends(get_db)
):
    """Delete a post (moderator action)."""
    service = AdminService(db)
    success = service.delete_post_admin(post_id)

    if not success:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Post not found"
        )

    return ActionResponse(
        success=True,
        message="Post has been deleted"
    )

@router.post("/posts/{post_id}/restore", response_model=ActionResponse)
async def restore_post(
    post_id: int,
    current_user: User = Depends(get_admin_user),
    db: Session = Depends(get_db)
):
    """Restore a deleted post (Admin only)."""
    service = AdminService(db)
    post = service.restore_post(post_id)

    if not post:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Post not found"
        )

    return ActionResponse(
        success=True,
        message=f"Post '{post.title}' has been restored"
    )

@router.get("/comments", response_model=CommentAdminListResponse)
async def get_comments_admin(
    page: int = Query(1, ge=1),
    page_size: int = Query(20, ge=1, le=100),
    search: Optional[str] = None,
    post_id: Optional[int] = None,
    status: Optional[str] = None,
    current_user: User = Depends(get_moderator_user),
    db: Session = Depends(get_db)
):
    """Get paginated list of comments for moderation."""
    service = AdminService(db)
    comments, total = service.get_comments_admin(
        page=page,
        page_size=page_size,
        search=search,
        post_id=post_id,
        status_filter=status
    )

    comment_items = []
    for comment in comments:
        comment_items.append(CommentAdminListItem(
            id=comment.id,
            content=comment.content[:200] + "..." if len(comment.content) > 200 else comment.content,
            author_username=comment.author.username if comment.author else "Unknown",
            author_id=comment.user_id,
            post_id=comment.post_id,
            post_title=comment.post.title if comment.post else "Unknown",
            is_deleted=comment.is_deleted,
            upvotes=comment.upvotes,
            downvotes=comment.downvotes,
            created_at=comment.created_at,
            reports_count=0
        ))

    return CommentAdminListResponse(
        comments=comment_items,
        total=total,
        page=page,
        page_size=page_size,
        has_more=(page * page_size) < total
    )

@router.delete("/comments/{comment_id}", response_model=ActionResponse)
async def delete_comment_admin(
    comment_id: int,
    current_user: User = Depends(get_moderator_user),
    db: Session = Depends(get_db)
):
    """Delete a comment (moderator action)."""
    service = AdminService(db)
    success = service.delete_comment_admin(comment_id)

    if not success:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Comment not found"
        )

    return ActionResponse(
        success=True,
        message="Comment has been deleted"
    )

@router.get("/roles", response_model=RoleListResponse)
async def get_roles(
    current_user: User = Depends(get_admin_user),
    db: Session = Depends(get_db)
):
    """Get all roles with user counts (Admin only)."""
    service = AdminService(db)
    roles = service.get_roles()

    return RoleListResponse(roles=roles)
FILE: app/api/v1/auth.py
from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session
from app.database import get_db
from app.schemas.auth import RegisterRequest, FirebaseTokenRequest, TokenResponse
from app.services.auth_service import AuthService
from app.dependencies import get_current_user
from app.models.user import User
from app.utils.logger import app_logger

router = APIRouter(prefix="/auth", tags=["Authentication"])

@router.post("/register", response_model=TokenResponse)
async def register(
    register_data: RegisterRequest,
    db: Session = Depends(get_db),
):
    auth_service = AuthService(db)
    return auth_service.register_user(register_data)

@router.post("/login", response_model=TokenResponse)
async def login(
    login_data: FirebaseTokenRequest,
    db: Session = Depends(get_db),
):
    auth_service = AuthService(db)
    return auth_service.login_user(login_data.id_token)
FILE: app/api/v1/comments.py
from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.orm import Session
from typing import Optional
from app.database import get_db
from app.schemas.comment import CommentCreate, CommentUpdate, CommentResponse, CommentTreeResponse
from app.schemas.post import VoteCreate
from app.services.comment_service import CommentService
from app.dependencies import get_current_user, get_optional_user
from app.models.user import User

router = APIRouter(prefix="/comments", tags=["Comments"])

@router.post("", response_model=CommentResponse, status_code=201)
async def create_comment(
    comment_data: CommentCreate,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Create a new comment or reply."""
    comment_service = CommentService(db)
    return comment_service.create_comment(comment_data, current_user)

@router.get("/post/{post_id}", response_model=CommentTreeResponse)
async def get_post_comments(
    post_id: int,
    current_user: Optional[User] = Depends(get_optional_user),
    db: Session = Depends(get_db)
):
    """Get all comments for a post in tree structure."""
    comment_service = CommentService(db)
    return comment_service.get_post_comments(post_id, current_user)

@router.get("/{comment_id}", response_model=CommentResponse)
async def get_comment(
    comment_id: int,
    current_user: Optional[User] = Depends(get_optional_user),
    db: Session = Depends(get_db)
):
    """Get a specific comment by ID."""
    comment_service = CommentService(db)
    return comment_service.get_comment(comment_id, current_user)

@router.put("/{comment_id}", response_model=CommentResponse)
async def update_comment(
    comment_id: int,
    comment_data: CommentUpdate,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Update a comment."""
    comment_service = CommentService(db)
    return comment_service.update_comment(comment_id, comment_data, current_user)

@router.delete("/{comment_id}")
async def delete_comment(
    comment_id: int,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Delete a comment."""
    comment_service = CommentService(db)
    return comment_service.delete_comment(comment_id, current_user)

@router.post("/{comment_id}/vote", response_model=CommentResponse)
async def vote_comment(
    comment_id: int,
    vote_data: VoteCreate,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Vote on a comment."""
    comment_service = CommentService(db)
    return comment_service.vote_comment(comment_id, vote_data.vote_type, current_user)

@router.delete("/{comment_id}/vote", response_model=CommentResponse)
async def remove_vote(
    comment_id: int,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Remove vote from a comment."""
    comment_service = CommentService(db)
    return comment_service.remove_vote(comment_id, current_user)
FILE: app/api/v1/posts.py
from fastapi import APIRouter, Depends, Query, HTTPException
from sqlalchemy.orm import Session
from typing import Optional
from app.database import get_db
from app.schemas.post import PostCreate, PostUpdate, PostResponse, PostListResponse, VoteCreate
from app.services.post_service import PostService
from app.dependencies import get_current_user, get_optional_user
from app.models.user import User

router = APIRouter(prefix="/posts", tags=["Posts"])

@router.post("", response_model=PostResponse, status_code=201)
async def create_post(
    post_data: PostCreate,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Create a new post."""
    post_service = PostService(db)
    return post_service.create_post(post_data, current_user)

@router.get("", response_model=PostListResponse)
async def get_posts(
    page: int = Query(1, ge=1),
    page_size: int = Query(20, ge=1, le=100),
    tag: Optional[str] = Query(None),
    sort_by: str = Query("new", regex="^(new|hot|top)$"),
    current_user: Optional[User] = Depends(get_optional_user),
    db: Session = Depends(get_db)
):
    """
    Get paginated list of posts.

    - **page**: Page number (starts at 1)
    - **page_size**: Number of posts per page (max 100)
    - **tag**: Filter by tag
    - **sort_by**: Sort by 'new', 'hot', or 'top'
    """
    post_service = PostService(db)
    return post_service.get_posts(page, page_size, tag, sort_by, current_user)

@router.get("/favorites", response_model=PostListResponse)
async def get_favorites(
    page: int = Query(1, ge=1),
    page_size: int = Query(20, ge=1, le=100),
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Get user's favorite posts."""
    post_service = PostService(db)
    return post_service.get_favorites(page, page_size, current_user)

@router.get("/{post_id}", response_model=PostResponse)
async def get_post(
    post_id: int,
    current_user: Optional[User] = Depends(get_optional_user),
    db: Session = Depends(get_db)
):
    """Get a specific post by ID."""
    post_service = PostService(db)
    return post_service.get_post(post_id, current_user)

@router.put("/{post_id}", response_model=PostResponse)
async def update_post(
    post_id: int,
    post_data: PostUpdate,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Update a post."""
    post_service = PostService(db)
    return post_service.update_post(post_id, post_data, current_user)

@router.delete("/{post_id}")
async def delete_post(
    post_id: int,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Delete a post."""
    post_service = PostService(db)
    return post_service.delete_post(post_id, current_user)

@router.post("/{post_id}/vote", response_model=PostResponse)
async def vote_post(
    post_id: int,
    vote_data: VoteCreate,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Vote on a post (upvote or downvote)."""
    post_service = PostService(db)
    return post_service.vote_post(post_id, vote_data, current_user)

@router.delete("/{post_id}/vote", response_model=PostResponse)
async def remove_vote(
    post_id: int,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Remove vote from a post."""
    post_service = PostService(db)
    return post_service.remove_vote(post_id, current_user)

@router.post("/{post_id}/favorite")
async def favorite_post(
    post_id: int,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Add post to favorites."""
    post_service = PostService(db)
    return post_service.add_favorite(post_id, current_user)

@router.delete("/{post_id}/favorite")
async def unfavorite_post(
    post_id: int,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Remove post from favorites."""
    post_service = PostService(db)
    return post_service.remove_favorite(post_id, current_user)

@router.get("/user/{user_id}", response_model=PostListResponse)
async def get_user_posts(
    user_id: int,
    page: int = Query(1, ge=1),
    page_size: int = Query(20, ge=1, le=100),
    current_user: Optional[User] = Depends(get_optional_user),
    db: Session = Depends(get_db)
):
    """Get all posts by a specific user."""
    post_service = PostService(db)
    return post_service.get_user_posts(user_id, page, page_size, current_user)
FILE: app/api/v1/users.py
from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session
from app.database import get_db
from app.schemas.user import UserUpdate, UserResponse, UserProfile
from app.schemas.notification import NotificationListResponse
from app.repositories.user_repository import UserRepository
from app.services.notification_service import NotificationService
from app.dependencies import get_current_user
from app.models.user import User

router = APIRouter(prefix="/users", tags=["Users"])

@router.get("/me", response_model=UserResponse)
async def get_my_profile(current_user: User = Depends(get_current_user)):
    """Get current user's profile."""
    return current_user

@router.put("/me", response_model=UserResponse)
async def update_my_profile(
    user_data: UserUpdate,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Update current user's profile."""
    user_repo = UserRepository(db)
    return user_repo.update(current_user, user_data)

@router.get("/{user_id}", response_model=UserProfile)
async def get_user_profile(
    user_id: int,
    db: Session = Depends(get_db)
):
    """Get public profile of any user."""
    user_repo = UserRepository(db)
    user = user_repo.get_by_id(user_id)

    if not user:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="User not found"
        )

    return user

@router.get("/me/notifications", response_model=NotificationListResponse)
async def get_my_notifications(
    unread_only: bool = False,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Get current user's notifications."""
    notification_service = NotificationService(db)
    return notification_service.get_user_notifications(
        current_user.id,
        unread_only=unread_only
    )

@router.post("/me/notifications/{notification_id}/read")
async def mark_notification_read(
    notification_id: int,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Mark a notification as read."""
    notification_service = NotificationService(db)
    success = notification_service.mark_as_read(notification_id, current_user.id)

    if not success:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Notification not found"
        )

    return {"message": "Notification marked as read"}

@router.post("/me/notifications/read-all")
async def mark_all_notifications_read(
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Mark all notifications as read."""
    notification_service = NotificationService(db)
    count = notification_service.mark_all_as_read(current_user.id)
    return {"message": f"Marked {count} notifications as read"}
FILE: app/api/v1/websocket.py
from fastapi import APIRouter, WebSocket, WebSocketDisconnect, Depends, Query
from sqlalchemy.orm import Session
from app.database import get_db
from app.services.websocket_service import connection_manager
from app.core.security import verify_token
from app.repositories.user_repository import UserRepository
from app.utils.logger import app_logger

router = APIRouter(prefix="/ws", tags=["WebSocket"])

@router.websocket("")
async def websocket_endpoint(
    websocket: WebSocket,
    token: str = Query(...),
    db: Session = Depends(get_db)
):
    """
    WebSocket endpoint for real-time updates.

    Usage from frontend:
    ```javascript
    const ws = new WebSocket('ws://localhost:8000/api/v1/ws?token=YOUR_JWT_TOKEN');
    ```
    """
    try:
        payload = verify_token(token)
        user_id = payload.get("user_id")

        if not user_id:
            await websocket.close(code=1008, reason="Invalid token")
            return

        user_repo = UserRepository(db)
        user = user_repo.get_by_id(user_id)

        if not user or not user.is_active or user.is_banned:
            await websocket.close(code=1008, reason="User not authorized")
            return

        await connection_manager.connect(websocket, user_id)

        try:
            await websocket.send_json({
                "type": "connection",
                "message": "Connected to real-time updates",
                "user_id": user_id
            })

            while True:
                data = await websocket.receive_text()

                await websocket.send_json({
                    "type": "echo",
                    "message": data
                })

        except WebSocketDisconnect:
            connection_manager.disconnect(websocket, user_id)
            app_logger.info(f"WebSocket disconnected: User {user_id}")

    except Exception as e:
        app_logger.error(f"WebSocket error: {e}")
        try:
            await websocket.close(code=1011, reason="Internal server error")
        except:
            pass
FILE: app/config.py
from pydantic_settings import BaseSettings, SettingsConfigDict
from typing import List, Optional

class Settings(BaseSettings):
    """Application settings loaded from environment variables."""

    APP_NAME: str = "MemeForum"
    APP_VERSION: str = "1.0.0"
    DEBUG: bool = True
    ENVIRONMENT: str = "development"

    HOST: str = "0.0.0.0"
    PORT: int = 8000

    DATABASE_URL: str
    DB_ECHO: bool = False

    REDIS_HOST: str = "localhost"
    REDIS_PORT: int = 6379
    REDIS_DB: int = 0
    REDIS_PASSWORD: str = ""

    FIREBASE_CREDENTIALS_PATH: Optional[str] = None
    FIREBASE_PROJECT_ID: Optional[str] = None

    SECRET_KEY: str
    ALGORITHM: str = "HS256"
    ACCESS_TOKEN_EXPIRE_MINUTES: int = 30

    CORS_ORIGINS: List[str] = ["http://localhost:4200"]

    MAX_FILE_SIZE: int = 10485760
    ALLOWED_FILE_TYPES: List[str] = [
        "image/jpeg",
        "image/png",
        "image/gif",
        "image/webp"
    ]
    UPLOAD_DIR: str = "./uploads"

    RATE_LIMIT_PER_MINUTE: int = 60

    LOG_LEVEL: str = "INFO"
    LOG_FILE: str = "logs/app.log"

    model_config = SettingsConfigDict(
        env_file=".env",
        case_sensitive=True,
        extra="ignore"
    )

    @property
    def redis_url(self) -> str:
        """Construct Redis URL."""
        if self.REDIS_PASSWORD:
            return f"redis://:{self.REDIS_PASSWORD}@{self.REDIS_HOST}:{self.REDIS_PORT}/{self.REDIS_DB}"
        return f"redis://{self.REDIS_HOST}:{self.REDIS_PORT}/{self.REDIS_DB}"

settings = Settings()
FILE: app/core/firebase_auth.py
from functools import lru_cache
from typing import Any, Dict

import firebase_admin
from firebase_admin import auth as firebase_auth, credentials

from app.config import settings
from app.utils.logger import app_logger

@lru_cache(maxsize=1)
def _initialize_firebase() -> None:
    if firebase_admin._apps:
        return

    if settings.FIREBASE_CREDENTIALS_PATH:
        cred = credentials.Certificate(settings.FIREBASE_CREDENTIALS_PATH)
        firebase_admin.initialize_app(cred, {"projectId": settings.FIREBASE_PROJECT_ID})
    else:
        firebase_admin.initialize_app()

def verify_firebase_id_token(id_token: str) -> Dict[str, Any]:
    _initialize_firebase()
    try:
        return firebase_auth.verify_id_token(id_token , clock_skew_seconds=10)
    except Exception as exc:
        app_logger.error(f"Firebase token verification failed: {exc}")
        raise ValueError("Invalid Firebase ID token") from exc
FILE: app/core/permissions.py
from functools import wraps
from typing import Callable, List, Optional
from fastapi import HTTPException, status, Depends
from sqlalchemy.orm import Session

from app.database import get_db
from app.dependencies import get_current_user
from app.models.user import User

class Permissions:
    CREATE_POST = "create_post"
    EDIT_OWN_POST = "edit_own_post"
    DELETE_OWN_POST = "delete_own_post"
    CREATE_COMMENT = "create_comment"
    EDIT_OWN_COMMENT = "edit_own_comment"
    DELETE_OWN_COMMENT = "delete_own_comment"
    VOTE = "vote"
    FAVORITE = "favorite"

    DELETE_ANY_POST = "delete_any_post"
    DELETE_ANY_COMMENT = "delete_any_comment"
    LOCK_POST = "lock_post"
    UNLOCK_POST = "unlock_post"
    BAN_USER_FROM_THREAD = "ban_user_from_thread"
    VIEW_REPORTS = "view_reports"

    BAN_USER = "ban_user"
    UNBAN_USER = "unban_user"
    PROMOTE_USER = "promote_user"
    DEMOTE_USER = "demote_user"
    DELETE_USER = "delete_user"
    VIEW_ALL_USERS = "view_all_users"
    MANAGE_ROLES = "manage_roles"
    VIEW_ADMIN_DASHBOARD = "view_admin_dashboard"
    MANAGE_CATEGORIES = "manage_categories"

ROLE_PERMISSIONS = {
    "admin": [
        Permissions.CREATE_POST,
        Permissions.EDIT_OWN_POST,
        Permissions.DELETE_OWN_POST,
        Permissions.CREATE_COMMENT,
        Permissions.EDIT_OWN_COMMENT,
        Permissions.DELETE_OWN_COMMENT,
        Permissions.VOTE,
        Permissions.FAVORITE,
        Permissions.DELETE_ANY_POST,
        Permissions.DELETE_ANY_COMMENT,
        Permissions.LOCK_POST,
        Permissions.UNLOCK_POST,
        Permissions.BAN_USER_FROM_THREAD,
        Permissions.VIEW_REPORTS,
        Permissions.BAN_USER,
        Permissions.UNBAN_USER,
        Permissions.PROMOTE_USER,
        Permissions.DEMOTE_USER,
        Permissions.DELETE_USER,
        Permissions.VIEW_ALL_USERS,
        Permissions.MANAGE_ROLES,
        Permissions.VIEW_ADMIN_DASHBOARD,
        Permissions.MANAGE_CATEGORIES,
    ],
    "moderator": [
        Permissions.CREATE_POST,
        Permissions.EDIT_OWN_POST,
        Permissions.DELETE_OWN_POST,
        Permissions.CREATE_COMMENT,
        Permissions.EDIT_OWN_COMMENT,
        Permissions.DELETE_OWN_COMMENT,
        Permissions.VOTE,
        Permissions.FAVORITE,
        Permissions.DELETE_ANY_POST,
        Permissions.DELETE_ANY_COMMENT,
        Permissions.LOCK_POST,
        Permissions.UNLOCK_POST,
        Permissions.BAN_USER_FROM_THREAD,
        Permissions.VIEW_REPORTS,
    ],
    "user": [
        Permissions.CREATE_POST,
        Permissions.EDIT_OWN_POST,
        Permissions.DELETE_OWN_POST,
        Permissions.CREATE_COMMENT,
        Permissions.EDIT_OWN_COMMENT,
        Permissions.DELETE_OWN_COMMENT,
        Permissions.VOTE,
        Permissions.FAVORITE,
    ],
}

def get_user_role(user: User) -> str:
    """Get the role name for a user."""
    if user.role:
        return user.role.name
    return "user"

def has_permission(user: User, permission: str) -> bool:
    """Check if a user has a specific permission."""
    if not user or not user.is_active or user.is_banned:
        return False

    role_name = get_user_role(user)
    role_permissions = ROLE_PERMISSIONS.get(role_name, [])

    return permission in role_permissions

def has_any_permission(user: User, permissions: List[str]) -> bool:
    """Check if a user has any of the specified permissions."""
    return any(has_permission(user, p) for p in permissions)

def has_all_permissions(user: User, permissions: List[str]) -> bool:
    """Check if a user has all of the specified permissions."""
    return all(has_permission(user, p) for p in permissions)

def is_admin(user: User) -> bool:
    """Check if user is an admin."""
    return get_user_role(user) == "admin"

def is_moderator(user: User) -> bool:
    """Check if user is a moderator or admin."""
    return get_user_role(user) in ["admin", "moderator"]

def is_owner(user: User, resource_user_id: int) -> bool:
    """Check if user owns a resource."""
    return user.id == resource_user_id

def can_moderate_content(user: User, content_user_id: int) -> bool:
    """Check if user can moderate content (owner or moderator+)."""
    return is_owner(user, content_user_id) or is_moderator(user)

def check_resource_ownership(user: User, resource_user_id: int) -> bool:
    """Check if user owns the resource."""
    return user.id == resource_user_id

def require_permission(permission: str):
    """Decorator to require a specific permission."""
    def decorator(func: Callable):
        @wraps(func)
        async def wrapper(*args, **kwargs):
            current_user = kwargs.get("current_user")
            if not current_user:
                raise HTTPException(
                    status_code=status.HTTP_401_UNAUTHORIZED,
                    detail="Authentication required"
                )

            if not has_permission(current_user, permission):
                raise HTTPException(
                    status_code=status.HTTP_403_FORBIDDEN,
                    detail=f"Permission denied: {permission} required"
                )

            return await func(*args, **kwargs)
        return wrapper
    return decorator

def require_any_permission(permissions: List[str]):
    """Decorator to require any of the specified permissions."""
    def decorator(func: Callable):
        @wraps(func)
        async def wrapper(*args, **kwargs):
            current_user = kwargs.get("current_user")
            if not current_user:
                raise HTTPException(
                    status_code=status.HTTP_401_UNAUTHORIZED,
                    detail="Authentication required"
                )

            if not has_any_permission(current_user, permissions):
                raise HTTPException(
                    status_code=status.HTTP_403_FORBIDDEN,
                    detail="Permission denied"
                )

            return await func(*args, **kwargs)
        return wrapper
    return decorator

def require_role(roles: List[str]):
    """Decorator to require specific roles."""
    def decorator(func: Callable):
        @wraps(func)
        async def wrapper(*args, **kwargs):
            current_user = kwargs.get("current_user")
            if not current_user:
                raise HTTPException(
                    status_code=status.HTTP_401_UNAUTHORIZED,
                    detail="Authentication required"
                )

            user_role = get_user_role(current_user)
            if user_role not in roles:
                raise HTTPException(
                    status_code=status.HTTP_403_FORBIDDEN,
                    detail=f"Role {user_role} not authorized. Required: {', '.join(roles)}"
                )

            return await func(*args, **kwargs)
        return wrapper
    return decorator

def get_admin_user(current_user: User = Depends(get_current_user)) -> User:
    """Dependency that ensures user is an admin."""
    if not is_admin(current_user):
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Admin access required"
        )
    return current_user

def get_moderator_user(current_user: User = Depends(get_current_user)) -> User:
    """Dependency that ensures user is a moderator or admin."""
    if not is_moderator(current_user):
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Moderator access required"
        )
    return current_user

def check_not_banned(current_user: User = Depends(get_current_user)) -> User:
    """Dependency that ensures user is not banned."""
    if current_user.is_banned:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Your account has been banned"
        )
    return current_user
FILE: app/core/redis_client.py
import redis
from redis import Redis
from typing import Optional
from app.config import settings
from app.utils.logger import app_logger

class RedisClient:
    """Redis client wrapper for caching and pub/sub."""

    def __init__(self):
        self._client: Optional[Redis] = None

    def connect(self):
        """Establish Redis connection."""
        try:
            self._client = redis.from_url(
                settings.redis_url,
                decode_responses=True,
                socket_connect_timeout=5,
                socket_keepalive=True,
            )
            self._client.ping()
            app_logger.info(f"Redis connected: {settings.REDIS_HOST}:{settings.REDIS_PORT}")
        except Exception as e:
            app_logger.error(f"Redis connection failed: {e}")
            raise

    def disconnect(self):
        """Close Redis connection."""
        if self._client:
            self._client.close()
            app_logger.info("Redis disconnected")

    @property
    def client(self) -> Redis:
        """Get Redis client instance."""
        if not self._client:
            self.connect()
        return self._client

    def set_cache(self, key: str, value: str, expire: int = 300):
        """Set cache with expiration (default 5 minutes)."""
        return self.client.setex(key, expire, value)

    def get_cache(self, key: str) -> Optional[str]:
        """Get cached value."""
        return self.client.get(key)

    def delete_cache(self, key: str):
        """Delete cache key."""
        return self.client.delete(key)

    def exists(self, key: str) -> bool:
        """Check if key exists."""
        return bool(self.client.exists(key))

    def publish(self, channel: str, message: str):
        """Publish message to channel."""
        return self.client.publish(channel, message)

    def subscribe(self, channel: str):
        """Subscribe to channel."""
        pubsub = self.client.pubsub()
        pubsub.subscribe(channel)
        return pubsub

    def add_to_stream(self, stream: str, data: dict) -> str:
        """Add message to Redis stream."""
        return self.client.xadd(stream, data)

    def read_stream(self, stream: str, count: int = 10, block: int = 1000):
        """Read messages from stream."""
        return self.client.xread({stream: '0'}, count=count, block=block)

    def add_to_set(self, key: str, value: str):
        """Add value to set."""
        return self.client.sadd(key, value)

    def remove_from_set(self, key: str, value: str):
        """Remove value from set."""
        return self.client.srem(key, value)

    def get_set_members(self, key: str):
        """Get all members of set."""
        return self.client.smembers(key)

redis_client = RedisClient()
FILE: app/core/security.py
from datetime import datetime, timedelta
from typing import Optional
from jose import JWTError, jwt
from passlib.context import CryptContext
from fastapi import HTTPException, status, Depends
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from sqlalchemy.orm import Session
from app.config import settings
from app.database import get_db
from app.models.user import User
from app.utils.logger import app_logger

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

bearer_scheme = HTTPBearer()

def create_access_token(data: dict, expires_delta: Optional[timedelta] = None) -> str:
    """
    Create JWT access token.

    Args:
        data: Dictionary to encode in token
        expires_delta: Token expiration time

    Returns:
        Encoded JWT token
    """
    to_encode = data.copy()

    if expires_delta:
        expire = datetime.utcnow() + expires_delta
    else:
        expire = datetime.utcnow() + timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)

    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(to_encode, settings.SECRET_KEY, algorithm=settings.ALGORITHM)

    return encoded_jwt

def verify_token(token: str) -> dict:
    """
    Verify and decode JWT token.

    Args:
        token: JWT token string

    Returns:
        Decoded token payload

    Raises:
        HTTPException: If token is invalid
    """
    try:
        payload = jwt.decode(token, settings.SECRET_KEY, algorithms=[settings.ALGORITHM])
        return payload
    except JWTError as e:
        app_logger.error(f"Token verification failed: {e}")
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Could not validate credentials",
            headers={"WWW-Authenticate": "Bearer"},
        )

def verify_password(plain_password: str, hashed_password: str) -> bool:
    """Verify password against hash."""
    return pwd_context.verify(plain_password, hashed_password)

def get_password_hash(password: str) -> str:
    """Hash password."""
    return pwd_context.hash(password)
FILE: app/database.py
from sqlalchemy import create_engine
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker, Session
from typing import Generator
from app.config import settings
from app.utils.logger import app_logger

engine = create_engine(
    settings.DATABASE_URL,
    echo=settings.DB_ECHO,
    pool_pre_ping=True,
    pool_size=10,
    max_overflow=20,
)

SessionLocal = sessionmaker(
    autocommit=False,
    autoflush=False,
    bind=engine
)

Base = declarative_base()

def get_db() -> Generator[Session, None,None]:
    """
    Dependency function to get database session.
    """
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

def init_db():
    """Initialize database - create all tables."""
    from app.models import user, role, post, comment, notification

    app_logger.info("Creating database tables...")
    Base.metadata.create_all(bind=engine)
    app_logger.info("Database tables created successfully")
FILE: app/dependencies.py
from typing import Optional
from fastapi import Depends, HTTPException, status
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from sqlalchemy.orm import Session
from app.database import get_db
from app.core.security import verify_token
from app.models.user import User
from app.utils.logger import app_logger

bearer_scheme = HTTPBearer()

async def get_current_user(
    credentials: HTTPAuthorizationCredentials = Depends(bearer_scheme),
    db: Session = Depends(get_db)
) -> User:
    """
    Dependency to get current authenticated user.

    Usage:
        @router.get("/me")
        async def get_me(current_user: User = Depends(get_current_user)):
            return current_user
    """
    token = credentials.credentials

    payload = verify_token(token)
    user_id: int = payload.get("user_id")

    if user_id is None:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid authentication credentials"
        )

    user = db.query(User).filter(User.id == user_id).first()

    if user is None:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="User not found"
        )

    if not user.is_active:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="User account is inactive"
        )

    if user.is_banned:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="User account is banned"
        )

    return user

async def get_optional_user(
    credentials: Optional[HTTPAuthorizationCredentials] = Depends(bearer_scheme),
    db: Session = Depends(get_db)
) -> Optional[User]:
    """
    Dependency to get current user if authenticated, None otherwise.
    Useful for endpoints that work with or without authentication.
    """
    if not credentials:
        return None

    try:
        return await get_current_user(credentials, db)
    except HTTPException:
        return None
FILE: app/main.py
import asyncio
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from contextlib import asynccontextmanager
from app.config import settings
from app.database import init_db
from app.core.redis_client import redis_client
from app.middleware.logging import LoggingMiddleware
from app.middleware.rate_limit import RateLimitMiddleware
from app.utils.logger import app_logger

from app.services.notification_stream import (
    notification_stream_worker,
    stop_notification_worker,
)

from app.api.v1 import auth, posts, comments, users, websocket, admin

@asynccontextmanager
async def lifespan(app: FastAPI):
    """Startup and shutdown events."""
    app_logger.info("Starting %s v%s", settings.APP_NAME, settings.APP_VERSION)

    init_db()

    notification_task = None
    try:
        redis_client.connect()
        notification_task = asyncio.create_task(notification_stream_worker())
    except Exception as exc:
        app_logger.error(f"Redis initialization failed: {exc}")

    app_logger.info("Application started successfully")
    try:
        yield
    finally:
        app_logger.info("Shutting down application")
        await stop_notification_worker(notification_task)
        redis_client.disconnect()

app = FastAPI(
    title=settings.APP_NAME,
    version=settings.APP_VERSION,
    description="Real-time meme sharing forum API",
    lifespan=lifespan
)

app.add_middleware(
    CORSMiddleware,
    allow_origins=settings.CORS_ORIGINS,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
    expose_headers=["*"],
)

app.add_middleware(RateLimitMiddleware)
app.add_middleware(LoggingMiddleware)

app.include_router(auth.router, prefix="/api/v1")
app.include_router(posts.router, prefix="/api/v1")
app.include_router(comments.router, prefix="/api/v1")
app.include_router(users.router, prefix="/api/v1")
app.include_router(websocket.router, prefix="/api/v1")
app.include_router(admin.router, prefix="/api/v1")

@app.get("/")
async def root():
    """Root endpoint."""
    return {
        "message": f"Welcome to {settings.APP_NAME}",
        "version": settings.APP_VERSION,
        "docs": "/docs"
    }

@app.get("/health")
async def health_check():
    """Health check endpoint."""
    return {
        "status": "healthy",
        "app": settings.APP_NAME,
        "version": settings.APP_VERSION,
        "environment": settings.ENVIRONMENT
    }
FILE: app/middleware/logging.py
from fastapi import Request
from starlette.middleware.base import BaseHTTPMiddleware
from app.utils.logger import app_logger
import time

class LoggingMiddleware(BaseHTTPMiddleware):
    """Middleware to log all HTTP requests."""

    async def dispatch(self, request: Request, call_next):
        start_time = time.time()

        app_logger.info(
            f"Request: {request.method} {request.url.path} "
            f"from {request.client.host if request.client else 'unknown'}"
        )

        response = await call_next(request)

        process_time = time.time() - start_time

        app_logger.info(
            f"Response: {response.status_code} "
            f"for {request.method} {request.url.path} "
            f"in {process_time:.3f}s"
        )

        response.headers["X-Process-Time"] = str(process_time)

        return response
FILE: app/middleware/rate_limit.py
from fastapi import Request, HTTPException, status
from starlette.middleware.base import BaseHTTPMiddleware
from app.core.redis_client import redis_client
from app.config import settings
from app.utils.logger import app_logger
import time

class RateLimitMiddleware(BaseHTTPMiddleware):
    """Simple rate limiting middleware using Redis."""

    async def dispatch(self, request: Request, call_next):
        if request.url.path == "/health" or request.method == "OPTIONS":
            return await call_next(request)

        client_ip = request.client.host if request.client else "unknown"
        rate_limit_key = f"rate_limit:{client_ip}:{int(time.time() / 60)}"

        try:
            current_count = redis_client.get_cache(rate_limit_key)

            if current_count is None:
                redis_client.set_cache(rate_limit_key, "1", expire=60)
            else:
                count = int(current_count)

                if count >= settings.RATE_LIMIT_PER_MINUTE:
                    app_logger.warning(f"Rate limit exceeded for {client_ip}")
                    raise HTTPException(
                        status_code=status.HTTP_429_TOO_MANY_REQUESTS,
                        detail="Too many requests. Please try again later."
                    )

                redis_client.client.incr(rate_limit_key)

        except HTTPException:
            raise
        except Exception as e:
            app_logger.error(f"Rate limit check failed: {e}")

        return await call_next(request)
FILE: app/models/comment.py
from sqlalchemy import Column, Integer, String, Text, DateTime, ForeignKey, Boolean
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func
from app.database import Base

class Comment(Base):
    __tablename__ = "comments"

    id = Column(Integer, primary_key=True, index=True)
    post_id = Column(Integer, ForeignKey("posts.id", ondelete="CASCADE"), nullable=False, index=True)
    user_id = Column(Integer, ForeignKey("users.id", ondelete="CASCADE"), nullable=False)
    parent_id = Column(Integer, ForeignKey("comments.id", ondelete="CASCADE"), nullable=True, index=True)

    content = Column(Text, nullable=False)

    upvotes = Column(Integer, default=0, nullable=False)
    downvotes = Column(Integer, default=0, nullable=False)

    is_deleted = Column(Boolean, default=False, nullable=False)

    created_at = Column(DateTime(timezone=True), server_default=func.now(), nullable=False, index=True)
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())

    post = relationship("Post", back_populates="comments")
    author = relationship("User", back_populates="comments")

    replies = relationship(
        "Comment",
        backref="parent",
        remote_side=[id],
        cascade="all, delete-orphan",
        single_parent=True,
    )

    votes = relationship("Vote", back_populates="comment", cascade="all, delete-orphan")

    def __repr__(self):
        return f"<Comment {self.id} on Post {self.post_id}>"
FILE: app/models/notification.py
from sqlalchemy import Column, Integer, String, Text, DateTime, ForeignKey, Boolean
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func
from app.database import Base

class Notification(Base):
    __tablename__ = "notifications"

    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id", ondelete="CASCADE"), nullable=False, index=True)

    type = Column(String(50), nullable=False)
    message = Column(Text, nullable=False)
    link = Column(String(500), nullable=True)

    is_read = Column(Boolean, default=False, nullable=False, index=True)

    created_at = Column(DateTime(timezone=True), server_default=func.now(), nullable=False, index=True)

    user = relationship("User", back_populates="notifications")

    def __repr__(self):
        return f"<Notification {self.id} for user {self.user_id}>"
FILE: app/models/post.py
from sqlalchemy import Column, Integer, String, Boolean, DateTime, ForeignKey, Text
from sqlalchemy.orm import relationship
from datetime import datetime

from app.database import Base

class Post(Base):
    __tablename__ = "posts"

    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id", ondelete="CASCADE"), nullable=False)
    title = Column(String(300), nullable=False)
    description = Column(Text, nullable=True)
    tag = Column(String(50), nullable=True, index=True)
    image_url = Column(Text, nullable=True)

    upvotes = Column(Integer, default=0)
    downvotes = Column(Integer, default=0)
    comment_count = Column(Integer, default=0)

    is_locked = Column(Boolean, default=False)
    lock_reason = Column(String(500), nullable=True)
    locked_at = Column(DateTime, nullable=True)

    is_deleted = Column(Boolean, default=False)
    deleted_at = Column(DateTime, nullable=True)

    created_at = Column(DateTime, default=datetime.utcnow, index=True)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)

    author = relationship("User", back_populates="posts", foreign_keys=[user_id])
    comments = relationship("Comment", back_populates="post", cascade="all, delete-orphan")
    votes = relationship("Vote", back_populates="post", cascade="all, delete-orphan")
    favorites = relationship("Favorite", back_populates="post", cascade="all, delete-orphan")

    def __repr__(self):
        return f"<Post {self.id}: {self.title[:30]}>"

class Vote(Base):
    __tablename__ = "votes"

    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id", ondelete="CASCADE"), nullable=False)
    post_id = Column(Integer, ForeignKey("posts.id", ondelete="CASCADE"), nullable=True)
    comment_id = Column(Integer, ForeignKey("comments.id", ondelete="CASCADE"), nullable=True)
    vote_type = Column(String(10), nullable=False)
    created_at = Column(DateTime, default=datetime.utcnow)

    post = relationship("Post", back_populates="votes")
    comment = relationship("Comment", back_populates="votes")

    def __repr__(self):
        return f"<Vote {self.vote_type} by user {self.user_id}>"

class Favorite(Base):
    __tablename__ = "favorites"

    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id", ondelete="CASCADE"), nullable=False)
    post_id = Column(Integer, ForeignKey("posts.id", ondelete="CASCADE"), nullable=False)
    created_at = Column(DateTime, default=datetime.utcnow)

    post = relationship("Post", back_populates="favorites")

    def __repr__(self):
        return f"<Favorite post {self.post_id} by user {self.user_id}>"
FILE: app/models/role.py
from sqlalchemy import Column, Integer, String, JSON
from sqlalchemy.orm import relationship
from app.database import Base

class Role(Base):
    __tablename__ = "roles"

    id = Column(Integer, primary_key=True, index=True)
    name = Column(String(50), unique=True, nullable=False)
    permissions = Column(JSON, nullable=False, default=list)

    users = relationship("User", back_populates="role")

    def __repr__(self):
        return f"<Role {self.name}>"
FILE: app/models/user.py
from sqlalchemy import Column, Integer, String, Boolean, DateTime, ForeignKey, Text
from sqlalchemy.orm import relationship
from datetime import datetime

from app.database import Base

class User(Base):
    __tablename__ = "users"

    id = Column(Integer, primary_key=True, index=True)
    firebase_uid = Column(String(128), unique=True, index=True, nullable=True)
    email = Column(String(255), unique=True, index=True, nullable=False)
    username = Column(String(50), unique=True, index=True, nullable=False)
    avatar_url = Column(String(500), nullable=True)
    bio = Column(Text, nullable=True)

    role_id = Column(Integer, ForeignKey("roles.id"), default=3)

    is_active = Column(Boolean, default=True)
    is_banned = Column(Boolean, default=False)

    ban_reason = Column(String(500), nullable=True)
    banned_at = Column(DateTime, nullable=True)
    banned_by_id = Column(Integer, ForeignKey("users.id"), nullable=True)

    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)

    role = relationship("Role", back_populates="users")
    posts = relationship("Post", back_populates="author", foreign_keys="Post.user_id")
    comments = relationship("Comment", back_populates="author", foreign_keys="Comment.user_id")
    notifications = relationship("Notification", back_populates="user")
    banned_by = relationship("User", remote_side=[id], foreign_keys=[banned_by_id])

    def __repr__(self):
        return f"<User {self.username}>"
FILE: app/repositories/comment_repository.py
from typing import Optional, List
from sqlalchemy.orm import Session, joinedload
from sqlalchemy import desc
from app.models.comment import Comment
from app.models.post import Vote
from app.schemas.comment import CommentCreate, CommentUpdate
from app.utils.logger import app_logger

class CommentRepository:
    """Repository for Comment database operations."""

    def __init__(self, db: Session):
        self.db = db

    def create(self, comment_data: CommentCreate, user_id: int) -> Comment:
        """Create a new comment."""
        comment = Comment(
            post_id=comment_data.post_id,
            user_id=user_id,
            parent_id=comment_data.parent_id,
            content=comment_data.content
        )
        self.db.add(comment)
        self.db.commit()
        self.db.refresh(comment)
        app_logger.info(f"Comment created: ID {comment.id} on post {comment.post_id}")
        return comment

    def get_by_id(self, comment_id: int, include_deleted: bool = False) -> Optional[Comment]:
        """Get comment by ID."""
        query = self.db.query(Comment).options(joinedload(Comment.author)).filter(
            Comment.id == comment_id
        )

        if not include_deleted:
            query = query.filter(Comment.is_deleted == False)

        return query.first()

    def get_by_post(self, post_id: int, parent_id: Optional[int] = None) -> List[Comment]:
        """Get comments for a post (optionally filtered by parent)."""
        query = self.db.query(Comment).options(joinedload(Comment.author)).filter(
            Comment.post_id == post_id,
            Comment.is_deleted == False
        )

        if parent_id is not None:
            query = query.filter(Comment.parent_id == parent_id)
        else:
            query = query.filter(Comment.parent_id.is_(None))

        return query.order_by(Comment.created_at).all()

    def get_comment_tree(self, post_id: int) -> List[Comment]:
        """Get nested comment tree for a post using recursive query."""
        from sqlalchemy import text

        query = text("""
            WITH RECURSIVE comment_tree AS (
                -- Base case: top-level comments
                SELECT c.*, u.username as author_username, u.avatar_url as author_avatar
                FROM comments c
                JOIN users u ON c.user_id = u.id
                WHERE c.post_id = :post_id AND c.parent_id IS NULL AND c.is_deleted = FALSE

                UNION ALL

                -- Recursive case: child comments
                SELECT c.*, u.username as author_username, u.avatar_url as author_avatar
                FROM comments c
                JOIN users u ON c.user_id = u.id
                INNER JOIN comment_tree ct ON c.parent_id = ct.id
                WHERE c.is_deleted = FALSE
            )
            SELECT * FROM comment_tree ORDER BY created_at;
        """)

        result = self.db.execute(query, {"post_id": post_id})
        return result.fetchall()

    def count_by_post(self, post_id: int) -> int:
        """Count comments on a post."""
        return self.db.query(Comment).filter(
            Comment.post_id == post_id,
            Comment.is_deleted == False
        ).count()

    def update(self, comment: Comment, comment_data: CommentUpdate) -> Comment:
        """Update comment."""
        comment.content = comment_data.content
        self.db.commit()
        self.db.refresh(comment)
        app_logger.info(f"Comment updated: ID {comment.id}")
        return comment

    def soft_delete(self, comment: Comment) -> Comment:
        """Soft delete comment."""
        comment.is_deleted = True
        comment.content = "[deleted]"
        self.db.commit()
        self.db.refresh(comment)
        app_logger.info(f"Comment soft deleted: ID {comment.id}")
        return comment

    def get_user_vote(self, comment_id: int, user_id: int) -> Optional[Vote]:
        """Get user's vote on a comment."""
        return self.db.query(Vote).filter(
            Vote.comment_id == comment_id,
            Vote.user_id == user_id
        ).first()

    def create_vote(self, comment_id: int, user_id: int, vote_type: str) -> Vote:
        """Create or update vote on comment."""
        existing_vote = self.get_user_vote(comment_id, user_id)

        if existing_vote:
            old_type = existing_vote.vote_type
            existing_vote.vote_type = vote_type

            comment = self.get_by_id(comment_id, include_deleted=True)
            if old_type == "up":
                comment.upvotes -= 1
            else:
                comment.downvotes -= 1

            if vote_type == "up":
                comment.upvotes += 1
            else:
                comment.downvotes += 1

            self.db.commit()
            return existing_vote

        vote = Vote(comment_id=comment_id, user_id=user_id, vote_type=vote_type)
        self.db.add(vote)

        comment = self.get_by_id(comment_id, include_deleted=True)
        if vote_type == "up":
            comment.upvotes += 1
        else:
            comment.downvotes += 1

        self.db.commit()
        self.db.refresh(vote)
        app_logger.info(f"Vote created: {vote_type} on comment {comment_id}")
        return vote

    def remove_vote(self, comment_id: int, user_id: int) -> None:
        """Remove vote from comment."""
        vote = self.get_user_vote(comment_id, user_id)
        if vote:
            comment = self.get_by_id(comment_id, include_deleted=True)
            if vote.vote_type == "up":
                comment.upvotes -= 1
            else:
                comment.downvotes -= 1

            self.db.delete(vote)
            self.db.commit()
            app_logger.info(f"Vote removed from comment {comment_id}")
FILE: app/repositories/post_repository.py
from typing import Optional, List
from sqlalchemy.orm import Session, joinedload
from sqlalchemy import desc, or_
from app.models.post import Post, Vote, Favorite
from app.models.user import User
from app.schemas.post import PostCreate, PostUpdate
from app.utils.logger import app_logger

class PostRepository:
    """Repository for Post database operations."""

    def __init__(self, db: Session):
        self.db = db

    def create(self, post_data: PostCreate, user_id: int) -> Post:
        """Create a new post."""
        post = Post(
            user_id=user_id,
            title=post_data.title,
            description=post_data.description,
            tag=post_data.tag,
            image_url=post_data.image_url
        )
        self.db.add(post)
        self.db.commit()
        self.db.refresh(post)
        app_logger.info(f"Post created: ID {post.id} by user {user_id}")
        return post

    def get_by_id(self, post_id: int, include_deleted: bool = False) -> Optional[Post]:
        """Get post by ID."""
        query = self.db.query(Post).options(joinedload(Post.author)).filter(Post.id == post_id)

        if not include_deleted:
            query = query.filter(Post.is_deleted == False)

        return query.first()

    def get_all(
        self,
        skip: int = 0,
        limit: int = 20,
        tag: Optional[str] = None,
        user_id: Optional[int] = None,
        sort_by: str = "new"
    ) -> List[Post]:
        """Get all posts with filters and pagination."""
        query = self.db.query(Post).options(joinedload(Post.author)).filter(
            Post.is_deleted == False
        )

        if tag:
            query = query.filter(Post.tag == tag)

        if user_id:
            query = query.filter(Post.user_id == user_id)

        if sort_by == "new":
            query = query.order_by(desc(Post.created_at))
        elif sort_by == "hot":
            query = query.order_by(desc(Post.upvotes - Post.downvotes))
        elif sort_by == "top":
            query = query.order_by(desc(Post.upvotes))

        return query.offset(skip).limit(limit).all()

    def count_all(self, tag: Optional[str] = None, user_id: Optional[int] = None) -> int:
        """Count total posts with filters."""
        query = self.db.query(Post).filter(Post.is_deleted == False)

        if tag:
            query = query.filter(Post.tag == tag)

        if user_id:
            query = query.filter(Post.user_id == user_id)

        return query.count()

    def search(self, query_text: str, skip: int = 0, limit: int = 20) -> List[Post]:
        """Search posts by title or description."""
        search_filter = or_(
            Post.title.ilike(f"%{query_text}%"),
            Post.description.ilike(f"%{query_text}%")
        )

        return self.db.query(Post).options(joinedload(Post.author)).filter(
            Post.is_deleted == False,
            search_filter
        ).order_by(desc(Post.created_at)).offset(skip).limit(limit).all()

    def update(self, post: Post, post_data: PostUpdate) -> Post:
        """Update post."""
        update_data = post_data.model_dump(exclude_unset=True)

        for field, value in update_data.items():
            setattr(post, field, value)

        self.db.commit()
        self.db.refresh(post)
        app_logger.info(f"Post updated: ID {post.id}")
        return post

    def soft_delete(self, post: Post) -> Post:
        """Soft delete post."""
        post.is_deleted = True
        self.db.commit()
        self.db.refresh(post)
        app_logger.info(f"Post soft deleted: ID {post.id}")
        return post

    def lock_post(self, post: Post) -> Post:
        """Lock post (prevent new comments)."""
        post.is_locked = True
        self.db.commit()
        self.db.refresh(post)
        app_logger.info(f"Post locked: ID {post.id}")
        return post

    def unlock_post(self, post: Post) -> Post:
        """Unlock post."""
        post.is_locked = False
        self.db.commit()
        self.db.refresh(post)
        app_logger.info(f"Post unlocked: ID {post.id}")
        return post

    def get_user_vote(self, post_id: int, user_id: int) -> Optional[Vote]:
        """Get user's vote on a post."""
        return self.db.query(Vote).filter(
            Vote.post_id == post_id,
            Vote.user_id == user_id
        ).first()

    def create_vote(self, post_id: int, user_id: int, vote_type: str) -> Vote:
        """Create or update vote."""
        existing_vote = self.get_user_vote(post_id, user_id)

        if existing_vote:
            old_type = existing_vote.vote_type
            existing_vote.vote_type = vote_type

            post = self.get_by_id(post_id, include_deleted=True)
            if old_type == "up":
                post.upvotes -= 1
            else:
                post.downvotes -= 1

            if vote_type == "up":
                post.upvotes += 1
            else:
                post.downvotes += 1

            self.db.commit()
            return existing_vote

        vote = Vote(post_id=post_id, user_id=user_id, vote_type=vote_type)
        self.db.add(vote)

        post = self.get_by_id(post_id, include_deleted=True)
        if vote_type == "up":
            post.upvotes += 1
        else:
            post.downvotes += 1

        self.db.commit()
        self.db.refresh(vote)
        app_logger.info(f"Vote created: {vote_type} on post {post_id} by user {user_id}")
        return vote

    def remove_vote(self, post_id: int, user_id: int) -> None:
        """Remove vote."""
        vote = self.get_user_vote(post_id, user_id)
        if vote:
            post = self.get_by_id(post_id, include_deleted=True)
            if vote.vote_type == "up":
                post.upvotes -= 1
            else:
                post.downvotes -= 1

            self.db.delete(vote)
            self.db.commit()
            app_logger.info(f"Vote removed from post {post_id} by user {user_id}")

    def add_favorite(self, post_id: int, user_id: int) -> Favorite:
        """Add post to favorites."""
        existing = self.db.query(Favorite).filter(
            Favorite.post_id == post_id,
            Favorite.user_id == user_id
        ).first()

        if existing:
            return existing

        favorite = Favorite(post_id=post_id, user_id=user_id)
        self.db.add(favorite)
        self.db.commit()
        self.db.refresh(favorite)
        app_logger.info(f"Post {post_id} favorited by user {user_id}")
        return favorite

    def remove_favorite(self, post_id: int, user_id: int) -> None:
        """Remove post from favorites."""
        favorite = self.db.query(Favorite).filter(
            Favorite.post_id == post_id,
            Favorite.user_id == user_id
        ).first()

        if favorite:
            self.db.delete(favorite)
            self.db.commit()
            app_logger.info(f"Post {post_id} unfavorited by user {user_id}")

    def is_favorited(self, post_id: int, user_id: int) -> bool:
        """Check if post is favorited by user."""
        return self.db.query(Favorite).filter(
            Favorite.post_id == post_id,
            Favorite.user_id == user_id
        ).first() is not None

    def get_user_favorites(self, user_id: int, skip: int = 0, limit: int = 20) -> List[Post]:
        """Get user's favorite posts."""
        return self.db.query(Post).join(Favorite).options(joinedload(Post.author)).filter(
            Favorite.user_id == user_id,
            Post.is_deleted == False
        ).order_by(desc(Favorite.created_at)).offset(skip).limit(limit).all()
FILE: app/repositories/user_repository.py
from typing import Optional, List
from sqlalchemy.orm import Session, joinedload
from app.models.user import User
from app.models.role import Role
from app.schemas.user import UserCreate, UserUpdate
from app.utils.logger import app_logger

class UserRepository:
    """Repository for User database operations."""

    def __init__(self, db: Session):
        self.db = db

    def create(self, user_data: UserCreate) -> User:
        """Create a new user."""
        user = User(
            firebase_uid=user_data.firebase_uid,
            email=user_data.email,
            username=user_data.username,
            avatar_url=user_data.avatar_url,
            role_id=3
        )
        self.db.add(user)
        self.db.commit()
        self.db.refresh(user)
        app_logger.info(f"User created: {user.username} (ID: {user.id})")
        return user

    def get_by_id(self, user_id: int) -> Optional[User]:
        """Get user by ID."""
        return self.db.query(User).options(joinedload(User.role)).filter(User.id == user_id).first()

    def get_by_firebase_uid(self, firebase_uid: str) -> Optional[User]:
        """Get user by Firebase UID."""
        return self.db.query(User).options(joinedload(User.role)).filter(
            User.firebase_uid == firebase_uid
        ).first()

    def get_by_email(self, email: str) -> Optional[User]:
        """Get user by email."""
        return self.db.query(User).options(joinedload(User.role)).filter(
            User.email == email
        ).first()

    def get_by_username(self, username: str) -> Optional[User]:
        """Get user by username."""
        return self.db.query(User).options(joinedload(User.role)).filter(
            User.username == username
        ).first()

    def update(self, user: User, user_data: UserUpdate) -> User:
        """Update user information."""
        update_data = user_data.model_dump(exclude_unset=True)

        for field, value in update_data.items():
            setattr(user, field, value)

        self.db.commit()
        self.db.refresh(user)
        app_logger.info(f"User updated: {user.username} (ID: {user.id})")
        return user

    def ban_user(self, user: User) -> User:
        """Ban a user."""
        user.is_banned = True
        user.is_active = False
        self.db.commit()
        self.db.refresh(user)
        app_logger.warning(f"User banned: {user.username} (ID: {user.id})")
        return user

    def unban_user(self, user: User) -> User:
        """Unban a user."""
        user.is_banned = False
        user.is_active = True
        self.db.commit()
        self.db.refresh(user)
        app_logger.info(f"User unbanned: {user.username} (ID: {user.id})")
        return user

    def delete(self, user: User) -> None:
        """Delete a user."""
        username = user.username
        self.db.delete(user)
        self.db.commit()
        app_logger.warning(f"User deleted: {username}")
FILE: app/schemas/__init__.py
"""Pydantic schemas for request/response validation."""

from app.schemas.user import UserCreate, UserUpdate, UserResponse
from app.schemas.post import PostCreate, PostUpdate, PostResponse
from app.schemas.comment import CommentCreate, CommentUpdate, CommentResponse
from app.schemas.auth import RegisterRequest, TokenResponse
FILE: app/schemas/admin.py
from pydantic import BaseModel, Field
from typing import Optional, List
from datetime import datetime
from enum import Enum

class RoleEnum(str, Enum):
    ADMIN = "admin"
    MODERATOR = "moderator"
    USER = "user"

class UserListItem(BaseModel):
    id: int
    username: str
    email: str
    avatar_url: Optional[str] = None
    role: str
    is_active: bool
    is_banned: bool
    created_at: datetime
    post_count: int = 0
    comment_count: int = 0

    class Config:
        from_attributes = True

class UserListResponse(BaseModel):
    users: List[UserListItem]
    total: int
    page: int
    page_size: int
    has_more: bool

class UserDetailResponse(BaseModel):
    id: int
    username: str
    email: str
    avatar_url: Optional[str] = None
    bio: Optional[str] = None
    role: str
    is_active: bool
    is_banned: bool
    ban_reason: Optional[str] = None
    created_at: datetime
    updated_at: Optional[datetime] = None
    post_count: int = 0
    comment_count: int = 0

    class Config:
        from_attributes = True

class BanUserRequest(BaseModel):
    reason: Optional[str] = Field(None, max_length=500)

class ChangeRoleRequest(BaseModel):
    role: RoleEnum

class UserUpdateRequest(BaseModel):
    username: Optional[str] = Field(None, min_length=3, max_length=50)
    email: Optional[str] = None
    bio: Optional[str] = Field(None, max_length=500)
    is_active: Optional[bool] = None

class PostAdminListItem(BaseModel):
    id: int
    title: str
    author_username: str
    author_id: int
    is_locked: bool
    is_deleted: bool
    upvotes: int
    downvotes: int
    comment_count: int
    created_at: datetime
    reports_count: int = 0

    class Config:
        from_attributes = True

class PostAdminListResponse(BaseModel):
    posts: List[PostAdminListItem]
    total: int
    page: int
    page_size: int
    has_more: bool

class LockPostRequest(BaseModel):
    reason: Optional[str] = Field(None, max_length=500)

class CommentAdminListItem(BaseModel):
    id: int
    content: str
    author_username: str
    author_id: int
    post_id: int
    post_title: str
    is_deleted: bool
    upvotes: int
    downvotes: int
    created_at: datetime
    reports_count: int = 0

    class Config:
        from_attributes = True

class CommentAdminListResponse(BaseModel):
    comments: List[CommentAdminListItem]
    total: int
    page: int
    page_size: int
    has_more: bool

class DashboardStats(BaseModel):
    total_users: int
    active_users: int
    banned_users: int
    total_posts: int
    total_comments: int
    posts_today: int
    comments_today: int
    new_users_today: int

class RecentActivity(BaseModel):
    type: str
    message: str
    timestamp: datetime
    user_id: Optional[int] = None
    post_id: Optional[int] = None

class DashboardResponse(BaseModel):
    stats: DashboardStats
    recent_activity: List[RecentActivity]

class RoleInfo(BaseModel):
    id: int
    name: str
    permissions: List[str]
    user_count: int

    class Config:
        from_attributes = True

class RoleListResponse(BaseModel):
    roles: List[RoleInfo]

class ThreadBanRequest(BaseModel):
    user_id: int
    post_id: int
    reason: Optional[str] = Field(None, max_length=500)

class ThreadBanResponse(BaseModel):
    id: int
    user_id: int
    post_id: int
    banned_by_id: int
    reason: Optional[str]
    created_at: datetime

    class Config:
        from_attributes = True

class ActionResponse(BaseModel):
    success: bool
    message: str
FILE: app/schemas/auth.py
from pydantic import BaseModel, EmailStr

class FirebaseTokenRequest(BaseModel):
    id_token: str

class RegisterRequest(BaseModel):
    id_token: str
    firebase_uid: str
    email: EmailStr
    username: str
    avatar_url: str | None = None

class TokenUser(BaseModel):
    id: int
    username: str
    email: EmailStr
    avatar_url: str | None = None
    role: str

class TokenResponse(BaseModel):
    access_token: str
    token_type: str = "bearer"
    user: TokenUser
FILE: app/schemas/comment.py
from pydantic import BaseModel, Field, ConfigDict
from typing import Optional
from datetime import datetime

class CommentBase(BaseModel):
    """Base comment schema."""
    content: str = Field(..., min_length=1, max_length=10000)

class CommentCreate(CommentBase):
    """Schema for creating a comment."""
    post_id: int
    parent_id: Optional[int] = None

class CommentUpdate(BaseModel):
    """Schema for updating a comment."""
    content: str = Field(..., min_length=1, max_length=10000)

class CommentResponse(CommentBase):
    """Schema for comment response."""
    id: int
    post_id: int
    user_id: int
    parent_id: Optional[int] = None
    upvotes: int
    downvotes: int
    is_deleted: bool
    created_at: datetime
    updated_at: Optional[datetime] = None

    author_username: str
    author_avatar: Optional[str] = None

    user_vote: Optional[str] = None
    replies: list["CommentResponse"] = []

    model_config = ConfigDict(from_attributes=True)

class CommentTreeResponse(BaseModel):
    """Nested comment tree."""
    comments: list[CommentResponse]
    total: int
FILE: app/schemas/notification.py
from pydantic import BaseModel, ConfigDict
from datetime import datetime
from typing import Optional

class NotificationCreate(BaseModel):
    """Schema for creating notification."""
    user_id: int
    type: str
    message: str
    link: Optional[str] = None

class NotificationResponse(BaseModel):
    """Schema for notification response."""
    id: int
    user_id: int
    type: str
    message: str
    link: Optional[str] = None
    is_read: bool
    created_at: datetime

    model_config = ConfigDict(from_attributes=True)

class NotificationListResponse(BaseModel):
    """List of notifications."""
    notifications: list[NotificationResponse]
    unread_count: int
FILE: app/schemas/post.py
from pydantic import BaseModel, Field, ConfigDict
from typing import Optional
from datetime import datetime

class PostBase(BaseModel):
    """Base post schema."""
    title: str = Field(..., min_length=1, max_length=300)
    description: Optional[str] = None
    tag: Optional[str] = Field(None, max_length=50)

class PostCreate(PostBase):
    """Schema for creating a post."""
    image_url: Optional[str] = None

class PostUpdate(BaseModel):
    """Schema for updating a post."""
    title: Optional[str] = Field(None, min_length=1, max_length=300)
    description: Optional[str] = None
    tag: Optional[str] = Field(None, max_length=50)

class PostResponse(PostBase):
    """Schema for post response."""
    id: int
    user_id: int
    image_url: Optional[str] = None
    upvotes: int
    downvotes: int
    is_locked: bool
    is_deleted: bool
    created_at: datetime
    updated_at: Optional[datetime] = None

    author_username: str
    author_avatar: Optional[str] = None

    comment_count: int = 0
    user_vote: Optional[str] = None
    is_favorited: bool = False

    model_config = ConfigDict(from_attributes=True)

class PostListResponse(BaseModel):
    """Paginated list of posts."""
    posts: list[PostResponse]
    total: int
    page: int
    page_size: int
    has_more: bool

class VoteCreate(BaseModel):
    """Schema for voting."""
    vote_type: str = Field(..., pattern="^(up|down)$")

class VoteResponse(BaseModel):
    """Vote response."""
    id: int
    user_id: int
    post_id: Optional[int] = None
    comment_id: Optional[int] = None
    vote_type: str
    created_at: datetime

    model_config = ConfigDict(from_attributes=True)
FILE: app/schemas/user.py
from pydantic import BaseModel, EmailStr, Field, ConfigDict
from typing import Optional
from datetime import datetime

class UserBase(BaseModel):
    """Base user schema with common attributes."""
    email: EmailStr
    username: str = Field(..., min_length=3, max_length=50)

class UserCreate(UserBase):
    """Schema for user registration."""
    firebase_uid: str
    avatar_url: Optional[str] = None

class UserUpdate(BaseModel):
    """Schema for updating user profile."""
    username: Optional[str] = Field(None, min_length=3, max_length=50)
    bio: Optional[str] = Field(None, max_length=500)
    avatar_url: Optional[str] = None

class UserResponse(UserBase):
    """Schema for user response."""
    id: int
    avatar_url: Optional[str] = None
    bio: Optional[str] = None
    role_id: int
    is_active: bool
    is_banned: bool
    created_at: datetime

    model_config = ConfigDict(from_attributes=True)

class UserWithRole(UserResponse):
    """User response with role information."""
    role_name: str
    permissions: list[str]

class UserProfile(BaseModel):
    """Public user profile."""
    id: int
    username: str
    avatar_url: Optional[str] = None
    bio: Optional[str] = None
    created_at: datetime

    model_config = ConfigDict(from_attributes=True)
FILE: app/services/admin_service.py
from typing import Optional, List, Tuple
from datetime import datetime, timedelta
from sqlalchemy.orm import Session
from sqlalchemy import func, or_, and_

from app.models.user import User
from app.models.role import Role
from app.models.post import Post
from app.models.comment import Comment
from app.schemas.admin import (
    UserListItem, UserDetailResponse, DashboardStats,
    RecentActivity, PostAdminListItem, CommentAdminListItem,
    RoleInfo
)

class AdminService:
    def __init__(self, db: Session):
        self.db = db


    def get_users(
        self,
        page: int = 1,
        page_size: int = 20,
        search: Optional[str] = None,
        role_filter: Optional[str] = None,
        status_filter: Optional[str] = None,
        sort_by: str = "created_at",
        sort_order: str = "desc"
    ) -> Tuple[List[User], int]:
        """Get paginated list of users with filters."""
        query = self.db.query(User)

        if search:
            search_term = f"%{search}%"
            query = query.filter(
                or_(
                    User.username.ilike(search_term),
                    User.email.ilike(search_term)
                )
            )

        if role_filter:
            query = query.join(Role).filter(Role.name == role_filter)

        if status_filter == "active":
            query = query.filter(User.is_active == True, User.is_banned == False)
        elif status_filter == "banned":
            query = query.filter(User.is_banned == True)
        elif status_filter == "inactive":
            query = query.filter(User.is_active == False)

        total = query.count()

        sort_column = getattr(User, sort_by, User.created_at)
        if sort_order == "desc":
            query = query.order_by(sort_column.desc())
        else:
            query = query.order_by(sort_column.asc())

        offset = (page - 1) * page_size
        users = query.offset(offset).limit(page_size).all()

        return users, total

    def get_user_detail(self, user_id: int) -> Optional[User]:
        """Get detailed user information."""
        return self.db.query(User).filter(User.id == user_id).first()

    def ban_user(self, user_id: int, admin_id: int, reason: Optional[str] = None) -> Optional[User]:
        """Ban a user."""
        user = self.db.query(User).filter(User.id == user_id).first()
        if not user:
            return None

        if user.role and user.role.name == "admin":
            raise ValueError("Cannot ban an admin user")

        if user_id == admin_id:
            raise ValueError("Cannot ban yourself")

        user.is_banned = True
        user.ban_reason = reason
        user.banned_at = datetime.utcnow()
        user.banned_by_id = admin_id

        self.db.commit()
        self.db.refresh(user)
        return user

    def unban_user(self, user_id: int) -> Optional[User]:
        """Unban a user."""
        user = self.db.query(User).filter(User.id == user_id).first()
        if not user:
            return None

        user.is_banned = False
        user.ban_reason = None
        user.banned_at = None
        user.banned_by_id = None

        self.db.commit()
        self.db.refresh(user)
        return user

    def change_user_role(self, user_id: int, new_role: str, admin_id: int) -> Optional[User]:
        """Change a user's role."""
        user = self.db.query(User).filter(User.id == user_id).first()
        if not user:
            return None

        if user_id == admin_id and new_role != "admin":
            raise ValueError("Cannot demote yourself")

        role = self.db.query(Role).filter(Role.name == new_role).first()
        if not role:
            raise ValueError(f"Role '{new_role}' not found")

        user.role_id = role.id

        self.db.commit()
        self.db.refresh(user)
        return user

    def delete_user(self, user_id: int, admin_id: int) -> bool:
        """Delete a user (soft delete by deactivating)."""
        user = self.db.query(User).filter(User.id == user_id).first()
        if not user:
            return False

        if user_id == admin_id:
            raise ValueError("Cannot delete yourself")

        if user.role and user.role.name == "admin":
            raise ValueError("Cannot delete an admin user")

        user.is_active = False
        user.is_banned = True
        user.email = f"deleted_{user.id}@deleted.local"
        user.username = f"deleted_user_{user.id}"

        self.db.commit()
        return True


    def get_posts_admin(
        self,
        page: int = 1,
        page_size: int = 20,
        search: Optional[str] = None,
        status_filter: Optional[str] = None,
        sort_by: str = "created_at",
        sort_order: str = "desc"
    ) -> Tuple[List[Post], int]:
        """Get paginated list of posts for admin."""
        query = self.db.query(Post)

        if search:
            search_term = f"%{search}%"
            query = query.filter(Post.title.ilike(search_term))

        if status_filter == "locked":
            query = query.filter(Post.is_locked == True)
        elif status_filter == "deleted":
            query = query.filter(Post.is_deleted == True)
        elif status_filter == "active":
            query = query.filter(Post.is_locked == False, Post.is_deleted == False)

        total = query.count()

        sort_column = getattr(Post, sort_by, Post.created_at)
        if sort_order == "desc":
            query = query.order_by(sort_column.desc())
        else:
            query = query.order_by(sort_column.asc())

        offset = (page - 1) * page_size
        posts = query.offset(offset).limit(page_size).all()

        return posts, total

    def lock_post(self, post_id: int, reason: Optional[str] = None) -> Optional[Post]:
        """Lock a post to prevent new comments."""
        post = self.db.query(Post).filter(Post.id == post_id).first()
        if not post:
            return None

        post.is_locked = True
        post.lock_reason = reason
        post.locked_at = datetime.utcnow()

        self.db.commit()
        self.db.refresh(post)
        return post

    def unlock_post(self, post_id: int) -> Optional[Post]:
        """Unlock a post."""
        post = self.db.query(Post).filter(Post.id == post_id).first()
        if not post:
            return None

        post.is_locked = False
        post.lock_reason = None
        post.locked_at = None

        self.db.commit()
        self.db.refresh(post)
        return post

    def delete_post_admin(self, post_id: int) -> bool:
        """Admin delete a post (soft delete)."""
        post = self.db.query(Post).filter(Post.id == post_id).first()
        if not post:
            return False

        post.is_deleted = True
        post.deleted_at = datetime.utcnow()

        self.db.commit()
        return True

    def restore_post(self, post_id: int) -> Optional[Post]:
        """Restore a deleted post."""
        post = self.db.query(Post).filter(Post.id == post_id).first()
        if not post:
            return None

        post.is_deleted = False
        post.deleted_at = None

        self.db.commit()
        self.db.refresh(post)
        return post


    def get_comments_admin(
        self,
        page: int = 1,
        page_size: int = 20,
        search: Optional[str] = None,
        post_id: Optional[int] = None,
        status_filter: Optional[str] = None
    ) -> Tuple[List[Comment], int]:
        """Get paginated list of comments for admin."""
        query = self.db.query(Comment)

        if search:
            search_term = f"%{search}%"
            query = query.filter(Comment.content.ilike(search_term))

        if post_id:
            query = query.filter(Comment.post_id == post_id)

        if status_filter == "deleted":
            query = query.filter(Comment.is_deleted == True)
        elif status_filter == "active":
            query = query.filter(Comment.is_deleted == False)

        total = query.count()

        offset = (page - 1) * page_size
        comments = query.order_by(Comment.created_at.desc()).offset(offset).limit(page_size).all()

        return comments, total

    def delete_comment_admin(self, comment_id: int) -> bool:
        """Admin delete a comment (soft delete)."""
        comment = self.db.query(Comment).filter(Comment.id == comment_id).first()
        if not comment:
            return False

        comment.is_deleted = True
        comment.content = "[Comment deleted by moderator]"

        self.db.commit()
        return True


    def get_dashboard_stats(self) -> DashboardStats:
        """Get dashboard statistics."""
        today = datetime.utcnow().date()
        today_start = datetime.combine(today, datetime.min.time())

        total_users = self.db.query(User).count()
        active_users = self.db.query(User).filter(
            User.is_active == True,
            User.is_banned == False
        ).count()
        banned_users = self.db.query(User).filter(User.is_banned == True).count()
        total_posts = self.db.query(Post).filter(Post.is_deleted == False).count()
        total_comments = self.db.query(Comment).filter(Comment.is_deleted == False).count()

        posts_today = self.db.query(Post).filter(
            Post.created_at >= today_start,
            Post.is_deleted == False
        ).count()

        comments_today = self.db.query(Comment).filter(
            Comment.created_at >= today_start,
            Comment.is_deleted == False
        ).count()

        new_users_today = self.db.query(User).filter(
            User.created_at >= today_start
        ).count()

        return DashboardStats(
            total_users=total_users,
            active_users=active_users,
            banned_users=banned_users,
            total_posts=total_posts,
            total_comments=total_comments,
            posts_today=posts_today,
            comments_today=comments_today,
            new_users_today=new_users_today
        )

    def get_recent_activity(self, limit: int = 10) -> List[RecentActivity]:
        """Get recent activity for dashboard."""
        activities = []

        recent_users = self.db.query(User).order_by(
            User.created_at.desc()
        ).limit(5).all()

        for user in recent_users:
            activities.append(RecentActivity(
                type="user_joined",
                message=f"New user joined: {user.username}",
                timestamp=user.created_at,
                user_id=user.id
            ))

        recent_posts = self.db.query(Post).filter(
            Post.is_deleted == False
        ).order_by(Post.created_at.desc()).limit(5).all()

        for post in recent_posts:
            activities.append(RecentActivity(
                type="post_created",
                message=f"New post: {post.title[:50]}...",
                timestamp=post.created_at,
                user_id=post.user_id,
                post_id=post.id
            ))

        activities.sort(key=lambda x: x.timestamp, reverse=True)
        return activities[:limit]


    def get_roles(self) -> List[RoleInfo]:
        """Get all roles with user counts."""
        roles = self.db.query(Role).all()
        result = []

        for role in roles:
            user_count = self.db.query(User).filter(User.role_id == role.id).count()
            result.append(RoleInfo(
                id=role.id,
                name=role.name,
                permissions=role.permissions or [],
                user_count=user_count
            ))

        return result

    def get_user_count_by_role(self, role_name: str) -> int:
        """Get count of users with a specific role."""
        return self.db.query(User).join(Role).filter(Role.name == role_name).count()
FILE: app/services/auth_service.py
from datetime import timedelta

from fastapi import HTTPException, status
from sqlalchemy.orm import Session

from app.config import settings
from app.core.firebase_auth import verify_firebase_id_token
from app.models.user import User
from app.repositories.user_repository import UserRepository
from app.schemas.auth import RegisterRequest, TokenResponse, TokenUser
from app.schemas.user import UserCreate
from app.core.security import create_access_token
from app.utils.logger import app_logger

class AuthService:
    """Service for authentication and authorization."""

    def __init__(self, db: Session):
        self.db = db
        self.user_repo = UserRepository(db)

    def register_user(self, register_data: RegisterRequest) -> TokenResponse:
        """Create a user after verifying the Firebase token."""
        try:
            claims = verify_firebase_id_token(register_data.id_token)
        except ValueError:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Invalid Firebase credentials",
            ) from None

        firebase_uid = claims["uid"]
        if firebase_uid != register_data.firebase_uid:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Firebase UID mismatch",
            )

        email = claims.get("email")
        if email and email.lower() != register_data.email.lower():
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Email does not match Firebase token",
            )

        if self.user_repo.get_by_firebase_uid(firebase_uid):
            app_logger.info("User already exists, issuing token")
            existing_user = self.user_repo.get_by_firebase_uid(firebase_uid)
            return self._generate_token_response(existing_user)

        if self.user_repo.get_by_email(register_data.email):
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Email already registered",
            )

        if self.user_repo.get_by_username(register_data.username):
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Username already taken",
            )

        avatar = register_data.avatar_url or claims.get("picture")
        user = self.user_repo.create(
            UserCreate(
                firebase_uid=firebase_uid,
                email=register_data.email,
                username=register_data.username,
                avatar_url=avatar,
            )
        )
        app_logger.info("New user registered: %s", user.username)
        return self._generate_token_response(user)

    def login_user(self, id_token: str) -> TokenResponse:
        """Authenticate a user using a Firebase ID token."""
        try:
            claims = verify_firebase_id_token(id_token)
        except ValueError:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Invalid Firebase credentials",
            ) from None

        firebase_uid = claims["uid"]
        user = self.user_repo.get_by_firebase_uid(firebase_uid)
        if not user:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="User not found. Please register first.",
            )

        if not user.is_active:
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail="User account is inactive",
            )

        if user.is_banned:
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail="User account is banned",
            )

        return self._generate_token_response(user)

    def _generate_token_response(self, user: User) -> TokenResponse:
        access_token_expires = timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)
        access_token = create_access_token(
            data={"user_id": user.id, "username": user.username},
            expires_delta=access_token_expires,
        )

        return TokenResponse(
            access_token=access_token,
            user=TokenUser(
                id=user.id,
                username=user.username,
                email=user.email,
                avatar_url=user.avatar_url,
                role=user.role.name if user.role else "user",
            ),
        )
FILE: app/services/comment_service.py
from typing import List, Optional
from fastapi import HTTPException, status
from sqlalchemy.orm import Session
from app.models.comment import Comment
from app.models.user import User
from app.schemas.comment import (
    CommentCreate, CommentUpdate, CommentResponse, CommentTreeResponse
)
from app.repositories.comment_repository import CommentRepository
from app.repositories.post_repository import PostRepository
from app.services.notification_service import NotificationService
from app.schemas.notification import NotificationCreate
from app.core.permissions import has_permission, check_resource_ownership
from app.utils.logger import app_logger

class CommentService:
    """Service for comment operations."""

    def __init__(self, db: Session):
        self.db = db
        self.comment_repo = CommentRepository(db)
        self.post_repo = PostRepository(db)
        self.notification_service = NotificationService(db)

    def create_comment(self, comment_data: CommentCreate, current_user: User) -> CommentResponse:
        """Create a new comment or reply."""
        if not has_permission(current_user, "comment:create"):
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail="You don't have permission to create comments"
            )

        post = self.post_repo.get_by_id(comment_data.post_id)
        if not post:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Post not found"
            )

        if post.is_locked:
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail="Post is locked. Cannot add comments."
            )

        if comment_data.parent_id:
            parent = self.comment_repo.get_by_id(comment_data.parent_id)
            if not parent:
                raise HTTPException(
                    status_code=status.HTTP_404_NOT_FOUND,
                    detail="Parent comment not found"
                )

            if parent.post_id != comment_data.post_id:
                raise HTTPException(
                    status_code=status.HTTP_400_BAD_REQUEST,
                    detail="Parent comment does not belong to this post"
                )

        comment = self.comment_repo.create(comment_data, current_user.id)

        if post.user_id != current_user.id:
            notification_data = NotificationCreate(
                user_id=post.user_id,
                type="new_comment",
                message=f"{current_user.username} commented on your post: {post.title[:50]}",
                link=f"/posts/{post.id}"
            )
            self.notification_service.create_notification(notification_data)

        if comment_data.parent_id and parent.user_id != current_user.id:
            notification_data = NotificationCreate(
                user_id=parent.user_id,
                type="reply",
                message=f"{current_user.username} replied to your comment",
                link=f"/posts/{post.id}
            )
            self.notification_service.create_notification(notification_data)

        return self._comment_to_response(comment, current_user)

    def get_comment(self, comment_id: int, current_user: Optional[User] = None) -> CommentResponse:
        """Get comment by ID."""
        comment = self.comment_repo.get_by_id(comment_id)

        if not comment:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Comment not found"
            )

        return self._comment_to_response(comment, current_user)

    def get_post_comments(
        self,
        post_id: int,
        current_user: Optional[User] = None
    ) -> CommentTreeResponse:
        """Get all comments for a post in tree structure."""
        post = self.post_repo.get_by_id(post_id)
        if not post:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Post not found"
            )

        top_level_comments = self.comment_repo.get_by_post(post_id)

        comment_responses = []
        for comment in top_level_comments:
            comment_responses.append(self._build_comment_tree(comment, current_user))

        total = self.comment_repo.count_by_post(post_id)

        return CommentTreeResponse(
            comments=comment_responses,
            total=total
        )

    def update_comment(
        self,
        comment_id: int,
        comment_data: CommentUpdate,
        current_user: User
    ) -> CommentResponse:
        """Update a comment."""
        comment = self.comment_repo.get_by_id(comment_id)

        if not comment:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Comment not found"
            )

        if not check_resource_ownership(current_user, comment.user_id):
            if not has_permission(current_user, "comment:edit:any"):
                raise HTTPException(
                    status_code=status.HTTP_403_FORBIDDEN,
                    detail="You don't have permission to edit this comment"
                )

        updated_comment = self.comment_repo.update(comment, comment_data)
        return self._comment_to_response(updated_comment, current_user)

    def delete_comment(self, comment_id: int, current_user: User) -> dict:
        """Delete a comment (soft delete)."""
        comment = self.comment_repo.get_by_id(comment_id)

        if not comment:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Comment not found"
            )

        if not check_resource_ownership(current_user, comment.user_id):
            if not has_permission(current_user, "comment:delete:any"):
                raise HTTPException(
                    status_code=status.HTTP_403_FORBIDDEN,
                    detail="You don't have permission to delete this comment"
                )

        self.comment_repo.soft_delete(comment)
        return {"message": "Comment deleted successfully"}

    def vote_comment(
        self,
        comment_id: int,
        vote_type: str,
        current_user: User
    ) -> CommentResponse:
        """Vote on a comment."""
        if not has_permission(current_user, "vote:create"):
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail="You don't have permission to vote"
            )

        comment = self.comment_repo.get_by_id(comment_id)

        if not comment:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Comment not found"
            )

        self.comment_repo.create_vote(comment_id, current_user.id, vote_type)

        updated_comment = self.comment_repo.get_by_id(comment_id)
        return self._comment_to_response(updated_comment, current_user)

    def remove_vote(self, comment_id: int, current_user: User) -> CommentResponse:
        """Remove vote from comment."""
        comment = self.comment_repo.get_by_id(comment_id)

        if not comment:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Comment not found"
            )

        self.comment_repo.remove_vote(comment_id, current_user.id)

        updated_comment = self.comment_repo.get_by_id(comment_id)
        return self._comment_to_response(updated_comment, current_user)

    def _comment_to_response(
        self,
        comment: Comment,
        current_user: Optional[User] = None
    ) -> CommentResponse:
        """Convert Comment model to CommentResponse schema."""
        user_vote = None
        if current_user:
            vote = self.comment_repo.get_user_vote(comment.id, current_user.id)
            if vote:
                user_vote = vote.vote_type

        return CommentResponse(
            id=comment.id,
            post_id=comment.post_id,
            user_id=comment.user_id,
            parent_id=comment.parent_id,
            content=comment.content,
            upvotes=comment.upvotes,
            downvotes=comment.downvotes,
            is_deleted=comment.is_deleted,
            created_at=comment.created_at,
            updated_at=comment.updated_at,
            author_username=comment.author.username,
            author_avatar=comment.author.avatar_url,
            user_vote=user_vote,
            replies=[]
        )

    def _build_comment_tree(
        self,
        comment: Comment,
        current_user: Optional[User] = None
    ) -> CommentResponse:
        """Recursively build comment tree with replies."""
        comment_response = self._comment_to_response(comment, current_user)

        replies = self.comment_repo.get_by_post(comment.post_id, parent_id=comment.id)

        comment_response.replies = [
            self._build_comment_tree(reply, current_user) for reply in replies
        ]

        return comment_response
FILE: app/services/notification_service.py
from typing import List
from sqlalchemy.orm import Session
from app.models.notification import Notification
from app.models.user import User
from app.schemas.notification import NotificationCreate, NotificationResponse, NotificationListResponse
from app.core.redis_client import redis_client
from app.utils.logger import app_logger
import json

class NotificationService:
    """Service for notification operations."""

    def __init__(self, db: Session):
        self.db = db

    def create_notification(self, notification_data: NotificationCreate) -> Notification:
        """Create a new notification."""
        notification = Notification(
            user_id=notification_data.user_id,
            type=notification_data.type,
            message=notification_data.message,
            link=notification_data.link
        )

        self.db.add(notification)
        self.db.commit()
        self.db.refresh(notification)

        app_logger.info(f"Notification created for user {notification.user_id}")

        self._publish_to_stream(notification)

        return notification

    def get_user_notifications(
        self,
        user_id: int,
        skip: int = 0,
        limit: int = 20,
        unread_only: bool = False
    ) -> NotificationListResponse:
        """Get notifications for a user."""
        query = self.db.query(Notification).filter(Notification.user_id == user_id)

        if unread_only:
            query = query.filter(Notification.is_read == False)

        notifications = query.order_by(Notification.created_at.desc()).offset(skip).limit(limit).all()

        unread_count = self.db.query(Notification).filter(
            Notification.user_id == user_id,
            Notification.is_read == False
        ).count()

        notification_responses = [
            NotificationResponse(
                id=n.id,
                user_id=n.user_id,
                type=n.type,
                message=n.message,
                link=n.link,
                is_read=n.is_read,
                created_at=n.created_at
            ) for n in notifications
        ]

        return NotificationListResponse(
            notifications=notification_responses,
            unread_count=unread_count
        )

    def mark_as_read(self, notification_id: int, user_id: int) -> bool:
        notification = self.db.query(Notification).filter(
            Notification.id == notification_id,
            Notification.user_id == user_id
        ).first()

        if notification:
            notification.is_read = True
            self.db.commit()
            app_logger.info(f"Notification {notification_id} marked as read")
            return True

        return False

    def mark_all_as_read(self, user_id: int) -> int:
        count = self.db.query(Notification).filter(
            Notification.user_id == user_id,
            Notification.is_read == False
        ).update({"is_read": True})

        self.db.commit()
        app_logger.info(f"Marked {count} notifications as read for user {user_id}")
        return count

    def _publish_to_stream(self, notification: Notification):
        try:
            notification_data = {
                "id": str(notification.id),
                "user_id": str(notification.user_id),
                "type": notification.type,
                "message": notification.message,
                "link": notification.link or "",
                "created_at": notification.created_at.isoformat()
            }

            redis_client.add_to_stream("notifications:stream", notification_data)
            app_logger.debug(f"Notification published to stream: {notification.id}")
        except Exception as e:
            app_logger.error(f"Failed to publish notification to stream: {e}")
FILE: app/services/notification_stream.py
import asyncio
from contextlib import suppress

from app.core.redis_client import redis_client
from app.services.websocket_service import connection_manager
from app.utils.logger import app_logger

STREAM_KEY = "notifications:stream"
READ_BLOCK_MS = 5000
BATCH_COUNT = 20

async def notification_stream_worker():
    """
    Pump Redis stream entries into WebSocket connections.
    Runs forever; cancel on shutdown.
    """
    last_id = "0-0"

    while True:
        try:
            await asyncio.sleep(0)
            result = await asyncio.to_thread(
                redis_client.client.xread,
                {STREAM_KEY: last_id},
                block=READ_BLOCK_MS,
                count=BATCH_COUNT,
            )

            if not result:
                continue

            for _, messages in result:
                for entry_id, data in messages:
                    last_id = entry_id
                    user_id = data.get("user_id")
                    if not user_id:
                        continue

                    await connection_manager.send_personal_message(
                        {
                            "type": "notification",
                            "notification": {
                                "id": int(data["id"]),
                                "user_id": int(user_id),
                                "type": data.get("type", ""),
                                "message": data.get("message", ""),
                                "link": data.get("link") or None,
                                "created_at": data.get("created_at"),
                            },
                        },
                        int(user_id),
                    )
        except asyncio.CancelledError:
            raise
        except Exception as exc:
            app_logger.error(f"Notification stream worker error: {exc}")
            await asyncio.sleep(2)

async def stop_notification_worker(task: asyncio.Task | None):
    if task:
        task.cancel()
        with suppress(asyncio.CancelledError):
            await task
FILE: app/services/post_service.py
from typing import List, Optional
from fastapi import HTTPException, status
from sqlalchemy.orm import Session
from app.models.post import Post, Favorite
from app.models.user import User
from app.schemas.post import (
    PostCreate, PostUpdate, PostResponse, PostListResponse, VoteCreate
)
from app.repositories.post_repository import PostRepository
from app.repositories.comment_repository import CommentRepository
from app.core.permissions import has_permission, check_resource_ownership
from app.utils.logger import app_logger

class PostService:
    """Service for post operations."""

    def __init__(self, db: Session):
        self.db = db
        self.post_repo = PostRepository(db)
        self.comment_repo = CommentRepository(db)

    def create_post(self, post_data: PostCreate, current_user: User) -> PostResponse:
        """Create a new post."""
        if not has_permission(current_user, "post:create"):
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail="You don't have permission to create posts"
            )

        post = self.post_repo.create(post_data, current_user.id)
        return self._post_to_response(post, current_user)

    def get_post(self, post_id: int, current_user: Optional[User] = None) -> PostResponse:
        """Get post by ID."""
        post = self.post_repo.get_by_id(post_id)

        if not post:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Post not found"
            )

        return self._post_to_response(post, current_user)

    def get_posts(
        self,
        page: int = 1,
        page_size: int = 20,
        tag: Optional[str] = None,
        sort_by: str = "new",
        current_user: Optional[User] = None
    ) -> PostListResponse:
        """Get paginated list of posts."""
        skip = (page - 1) * page_size

        posts = self.post_repo.get_all(
            skip=skip,
            limit=page_size,
            tag=tag,
            sort_by=sort_by
        )

        total = self.post_repo.count_all(tag=tag)

        post_responses = [self._post_to_response(post, current_user) for post in posts]

        return PostListResponse(
            posts=post_responses,
            total=total,
            page=page,
            page_size=page_size,
            has_more=skip + page_size < total
        )

    def get_favorites(
        self,
        page: int = 1,
        page_size: int = 20,
        current_user: User = None
    ) -> PostListResponse:
        """Get user's favorite posts."""
        skip = (page - 1) * page_size

        posts = self.post_repo.get_user_favorites(
            user_id=current_user.id,
            skip=skip,
            limit=page_size
        )

        total = self.db.query(Favorite).filter(
            Favorite.user_id == current_user.id
        ).count()

        post_responses = [self._post_to_response(post, current_user) for post in posts]

        return PostListResponse(
            posts=post_responses,
            total=total,
            page=page,
            page_size=page_size,
            has_more=skip + page_size < total
        )

    def get_user_posts(
        self,
        user_id: int,
        page: int = 1,
        page_size: int = 20,
        current_user: Optional[User] = None
    ) -> PostListResponse:
        """Get posts by specific user."""
        skip = (page - 1) * page_size

        posts = self.post_repo.get_all(
            skip=skip,
            limit=page_size,
            user_id=user_id,
            sort_by="new"
        )

        total = self.post_repo.count_all(user_id=user_id)

        post_responses = [self._post_to_response(post, current_user) for post in posts]

        return PostListResponse(
            posts=post_responses,
            total=total,
            page=page,
            page_size=page_size,
            has_more=skip + page_size < total
        )

    def update_post(
        self,
        post_id: int,
        post_data: PostUpdate,
        current_user: User
    ) -> PostResponse:
        """Update a post."""
        post = self.post_repo.get_by_id(post_id)

        if not post:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Post not found"
            )

        if not check_resource_ownership(current_user, post.user_id):
            if not has_permission(current_user, "post:edit:any"):
                raise HTTPException(
                    status_code=status.HTTP_403_FORBIDDEN,
                    detail="You don't have permission to edit this post"
                )

        updated_post = self.post_repo.update(post, post_data)
        return self._post_to_response(updated_post, current_user)

    def delete_post(self, post_id: int, current_user: User) -> dict:
        """Delete a post."""
        post = self.post_repo.get_by_id(post_id)

        if not post:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Post not found"
            )

        if not check_resource_ownership(current_user, post.user_id):
            if not has_permission(current_user, "post:delete:any"):
                raise HTTPException(
                    status_code=status.HTTP_403_FORBIDDEN,
                    detail="You don't have permission to delete this post"
                )

        self.post_repo.soft_delete(post)
        return {"message": "Post deleted successfully"}

    def vote_post(self, post_id: int, vote_data: VoteCreate, current_user: User) -> PostResponse:
        """Vote on a post."""
        if not has_permission(current_user, "vote:create"):
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail="You don't have permission to vote"
            )

        post = self.post_repo.get_by_id(post_id)

        if not post:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Post not found"
            )

        self.post_repo.create_vote(post_id, current_user.id, vote_data.vote_type)

        updated_post = self.post_repo.get_by_id(post_id)
        return self._post_to_response(updated_post, current_user)

    def remove_vote(self, post_id: int, current_user: User) -> PostResponse:
        """Remove vote from post."""
        post = self.post_repo.get_by_id(post_id)

        if not post:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Post not found"
            )

        self.post_repo.remove_vote(post_id, current_user.id)

        updated_post = self.post_repo.get_by_id(post_id)
        return self._post_to_response(updated_post, current_user)

    def add_favorite(self, post_id: int, current_user: User) -> dict:
        """Add post to favorites."""
        post = self.post_repo.get_by_id(post_id)

        if not post:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Post not found"
            )

        if self.post_repo.is_favorited(post_id, current_user.id):
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Post already favorited"
            )

        self.post_repo.add_favorite(post_id, current_user.id)
        app_logger.info(f"Post {post_id} favorited by user {current_user.id}")

        return {
            "message": "Post added to favorites",
            "is_favorited": True
        }

    def remove_favorite(self, post_id: int, current_user: User) -> dict:
        """Remove post from favorites."""
        post = self.post_repo.get_by_id(post_id)

        if not post:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Post not found"
            )

        if not self.post_repo.is_favorited(post_id, current_user.id):
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Post not in favorites"
            )

        self.post_repo.remove_favorite(post_id, current_user.id)
        app_logger.info(f"Post {post_id} unfavorited by user {current_user.id}")

        return {
            "message": "Post removed from favorites",
            "is_favorited": False
        }

    def _post_to_response(self, post: Post, current_user: Optional[User] = None) -> PostResponse:
        """Convert Post model to PostResponse schema."""
        comment_count = self.comment_repo.count_by_post(post.id)

        user_vote = None
        is_favorited = False

        if current_user:
            vote = self.post_repo.get_user_vote(post.id, current_user.id)
            if vote:
                user_vote = vote.vote_type

            is_favorited = self.post_repo.is_favorited(post.id, current_user.id)

        return PostResponse(
            id=post.id,
            user_id=post.user_id,
            title=post.title,
            description=post.description,
            tag=post.tag,
            image_url=post.image_url,
            upvotes=post.upvotes,
            downvotes=post.downvotes,
            is_locked=post.is_locked,
            is_deleted=post.is_deleted,
            created_at=post.created_at,
            updated_at=post.updated_at,
            author_username=post.author.username,
            author_avatar=post.author.avatar_url,
            comment_count=comment_count,
            user_vote=user_vote,
            is_favorited=is_favorited
        )
FILE: app/services/websocket_service.py
from typing import Dict, Set
from fastapi import WebSocket
from app.utils.logger import app_logger
import json

class ConnectionManager:
    """Manage WebSocket connections."""

    def __init__(self):
        self.active_connections: Dict[int, Set[WebSocket]] = {}

    async def connect(self, websocket: WebSocket, user_id: int):
        """Accept WebSocket connection."""
        await websocket.accept()

        if user_id not in self.active_connections:
            self.active_connections[user_id] = set()

        self.active_connections[user_id].add(websocket)
        app_logger.info(f"WebSocket connected: User {user_id}")

    def disconnect(self, websocket: WebSocket, user_id: int):
        """Remove WebSocket connection."""
        if user_id in self.active_connections:
            self.active_connections[user_id].discard(websocket)

            if not self.active_connections[user_id]:
                del self.active_connections[user_id]

        app_logger.info(f"WebSocket disconnected: User {user_id}")

    async def send_personal_message(self, message: dict, user_id: int):
        """Send message to specific user (all their connections)."""
        if user_id in self.active_connections:
            disconnected = set()

            for connection in self.active_connections[user_id]:
                try:
                    await connection.send_json(message)
                except Exception as e:
                    app_logger.error(f"Failed to send message to user {user_id}: {e}")
                    disconnected.add(connection)

            for connection in disconnected:
                self.active_connections[user_id].discard(connection)

    async def broadcast(self, message: dict):
        """Broadcast message to all connected users."""
        disconnected = []

        for user_id, connections in self.active_connections.items():
            for connection in connections:
                try:
                    await connection.send_json(message)
                except Exception as e:
                    app_logger.error(f"Failed to broadcast to user {user_id}: {e}")
                    disconnected.append((user_id, connection))

        for user_id, connection in disconnected:
            self.disconnect(connection, user_id)

    def is_user_online(self, user_id: int) -> bool:
        """Check if user is online."""
        return user_id in self.active_connections and len(self.active_connections[user_id]) > 0

    def get_online_count(self) -> int:
        """Get total number of online users."""
        return len(self.active_connections)

connection_manager = ConnectionManager()
FILE: app/utils/logger.py
import sys
from pathlib import Path
from loguru import logger
from app.config import settings

def setup_logger():
    """Configure Loguru logger."""

    logger.remove()

    logger.add(
        sys.stdout,
        format="<green>{time:YYYY-MM-DD HH:mm:ss}</green> | <level>{level: <8}</level> | <cyan>{name}</cyan>:<cyan>{function}</cyan>:<cyan>{line}</cyan> - <level>{message}</level>",
        level=settings.LOG_LEVEL,
        colorize=True,
    )

    log_path = Path(settings.LOG_FILE)
    log_path.parent.mkdir(parents=True, exist_ok=True)

    logger.add(
        settings.LOG_FILE,
        format="{time:YYYY-MM-DD HH:mm:ss} | {level: <8} | {name}:{function}:{line} - {message}",
        level=settings.LOG_LEVEL,
        rotation="10 MB",
        retention="1 week",
        compression="zip",
    )

    logger.info(f"Logger initialized - Level: {settings.LOG_LEVEL}")

    return logger

app_logger = setup_logger()
FILE: firebase-service-account.json
{
  "type": "service_account",
  "project_id": "my-metkit18",
  "private_key_id": "446969e143adf1fb7ef28d2a9e3fac88a6f252a4",
  "private_key": "-----BEGIN PRIVATE KEY-----\nMIIEvgIBADANBgkqhkiG9w0BAQEFAASCBKgwggSkAgEAAoIBAQCy9IWNIJPpW9zy\nzOiCoed54OiSgehOLVf5TnAOlB0iHzimWWJbiQ5yhbYYdIE3kuxv+2kl86GbvLWm\nekrI4LwrWDV+nuCsPnNjxwUCIv2xFtPdcF81SjX9cbDwGQGNoWFdpCWhCLC5NBGx\nqp+Zub2Ykn9nDE4s36pfzk/iVde2Zb8aG8VPBzoFXKJ5IpF2l9znPcGwph3WJ0Bo\nhsATlEo0rbm7LwzT3qR0UOhB9I6RrqzuK78Ita/LLUNjYQDFW7RHoSP3Uwwq6j2i\niTPJP3Cs7Up68R3HFDTBHaTQ9CtYfA39gueqMPpGngCc0CTS57KwXDY0mSqneL4z\ns/ALZPD/AgMBAAECggEAAOnTlq1QY/QGlCyskSIfatVVio3kMCX2GX0ngEOMRITR\nRrQVFu+Dpdz92XEaybxTvZyUZE+yhvd3G+Lq58yR2UzJdRx9fBOThjJZWbHxBord\nyPcOXVjEHseKRidyhRUKSK6STJidQky8PGJpDyFOEO3Kfa2n5n27wmJssPSMNc+b\n7oSyf2+34lZVIF4pPf8vQQPRwIxdtFg5XNIQHlwBj6TaxnUpihp55eMfAIbta26R\nFNNWgCGyMFNzbpnDdmCZDWWOyTTC07Uw64PtFT94iACw7U+0slMIGk2zF8iLVX9x\nDbRWMxT4/wQf+E/PC2BxTy9PGXPslqFT/OPJvd4DsQKBgQDzvxzIl8qAceox2xim\nr7eFf3t4QOUiDf/qX7N8sGCO6Fnu1l2v8scNvwReX1x3Z9d8HXxtl8c+gplbTmzC\n8JlkaeXvq7xtpeRezCmC9ncNFMbWLq+aIQ75mpztrheuFu1k8xHMozj6uj92ps/9\nxZOCXvZ4xXdzZcubdvv91qf1DwKBgQC785Q2ZS60LRxeep0oQ64FXP0DINXWHrCN\nfHIdLkyqWKMQrocg+xniMmoWl0OQMR8e6Z6dOzVfSBaUPV3OwG6QKEQOl7OtFaej\nXfQWeljSNBsHPNkKtGMJ6c+fbJwcyxqswXAH9NoXSCm+DSEr4nsT509UAIZS9TVF\nxnThQAWlEQKBgQDJwaxqobI95Yzr3aYm+xXWi7JA1L6VFK97aeHg2QHj6JHgb1I3\nPKblSvKrxxV7xNmJ48JF2LdUl7em62B9b7gYdMueOjILNKC2kxndTHM4wbTgPt6d\nnrWNiBxTZKI3OMUhpU1bbNPSPe4gIW3SagNyi3ZKe3EndOA2/CMTduWpowKBgEwa\nyFPySqQIdClJiuNn7EodqhGfNRcbnC/eSTLJsZ90fqrdkLfpFUUDVvPI0kHLsidJ\nP8G43Na1EPd7lcWHI/3ZYB1sjgOy9gtvmsuTRO3wzVTz7YqpGkVEWJ7cUqZSE34K\nYbvHCJxOyyA6nsjvTxjzG6sO/1UOF0Emp+MhkmeRAoGBAPI/mHdrYDyD+oQC0ID0\nrBOXK3yyp2CO8wsDGniZtDOpQaYjb8BDYVmrmyv4KcCgdC4dzeHcodD5D9F9KT/l\nA6xScwGyh9FI233+hbOZdnZ+zgHS1OMVXiSiL44VJuTlCNhINyVGjMZvrLybeG++\nT9ciLDKN83it+R9oIoo+w2Ml\n-----END PRIVATE KEY-----\n",
  "client_email": "firebase-adminsdk-ckpgc@my-metkit18.iam.gserviceaccount.com",
  "client_id": "101296791156231089871",
  "auth_uri": "https://accounts.google.com/o/oauth2/auth",
  "token_uri": "https://oauth2.googleapis.com/token",
  "auth_provider_x509_cert_url": "https://www.googleapis.com/oauth2/v1/certs",
  "client_x509_cert_url": "https://www.googleapis.com/robot/v1/metadata/x509/firebase-adminsdk-ckpgc%40my-metkit18.iam.gserviceaccount.com",
  "universe_domain": "googleapis.com"
}
FILE: main.py
"""
Entry point for running the FastAPI application.

Usage:
    uv run python main.py

Or with uvicorn directly:
    uv run uvicorn app.main:app --reload --host 0.0.0.0 --port 8000
"""
from fastapi import FastAPI

app = FastAPI()
import uvicorn
from app.config import settings

if __name__ == "__main__":
    uvicorn.run(
        "app.main:app",
        host=settings.HOST,
        port=settings.PORT,
        reload=settings.DEBUG,
        log_level=settings.LOG_LEVEL.lower()
    )
FILE: seed.py
"""
Database seeding script for Seddit.
Creates default roles and optionally sample data.
"""

from sqlalchemy.orm import Session
from app.database import SessionLocal, engine, Base

from app.models.role import Role
from app.models.user import User
from app.models.post import Post
from app.models.comment import Comment
from app.models.notification import Notification

from app.utils.logger import app_logger

def seed_roles(db: Session):
    """Seed default roles."""
    roles = [
        {
            "id": 1,
            "name": "user",
            "permissions": ["read", "write", "comment", "vote"],
        },
        {
            "id": 2,
            "name": "moderator",
            "permissions": [
                "read",
                "write",
                "comment",
                "vote",
                "delete_post",
                "delete_comment",
                "lock_post",
                "ban_user",
            ],
        },
        {
            "id": 3,
            "name": "admin",
            "permissions": [
                "read",
                "write",
                "comment",
                "vote",
                "delete_post",
                "delete_comment",
                "lock_post",
                "ban_user",
                "manage_roles",
                "manage_users",
                "admin_panel",
            ],
        },
    ]

    for role_data in roles:
        existing = db.query(Role).filter(Role.id == role_data["id"]).first()
        if existing:
            existing.name = role_data["name"]
            existing.permissions = role_data["permissions"]
            app_logger.info(f"Updated role: {role_data['name']}")
        else:
            role = Role(**role_data)
            db.add(role)
            app_logger.info(f"Created role: {role_data['name']}")

    db.commit()
    app_logger.info("Roles seeded successfully!")

def seed_admin_user(db: Session):
    """Seed default admin user if not exists."""
    admin_email = "admin@seddit.com"

    existing = db.query(User).filter(User.email == admin_email).first()
    if existing:
        app_logger.info(f"Admin user already exists: {admin_email}")
        return

    admin_role = db.query(Role).filter(Role.name == "admin").first()
    if not admin_role:
        app_logger.error("Admin role not found! Run seed_roles first.")
        return

    admin_user = User(
        username="admin",
        email=admin_email,
        firebase_uid="admin_firebase_uid_placeholder",
        role_id=admin_role.id,
        is_active=True,
        is_banned=False,
    )

    db.add(admin_user)
    db.commit()
    app_logger.info(f"Created admin user: {admin_email}")

def run_seed():
    """Main seeding function."""
    print("=" * 50)
    print("Starting database seeding...")
    print("=" * 50)

    Base.metadata.create_all(bind=engine)

    db = SessionLocal()
    try:
        seed_roles(db)
        seed_admin_user(db)

        print("=" * 50)
        print("Database seeding completed successfully!")
        print("=" * 50)
    except Exception as e:
        app_logger.error(f"Seeding failed: {e}")
        db.rollback()
        raise
    finally:
        db.close()

if __name__ == "__main__":
    run_seed()
SUMMARY
Total files: 50
Original size: 159,529 chars
Processed size: 151,007 chars
Reduction: 5.3%

File types:
 .py: 46
 [no extension]: 2
 .example: 1
 .json: 1
